   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.comm	straight_speed,4,4
  18              		.comm	medium_speed,4,4
  19              		.comm	turn_speed,4,4
  20              		.comm	brake_speed,4,4
  21              		.comm	speedC,4,4
  22              		.comm	LineScanData,200,4
  23              		.comm	histogram,4096,4
  24              		.comm	kp,8,8
  25              		.comm	ki,8,8
  26              		.comm	kd,8,8
  27              		.comm	lastError,8,8
  28              		.comm	llastError,8,8
  29              		.comm	lastOutput,4,4
  30              		.comm	AccData,6,4
  31              		.comm	Xout,2,2
  32              		.comm	Yout,2,2
  33              		.comm	Zout,2,2
  34              		.comm	Xoffset,1,1
  35              		.comm	Yoffset,1,1
  36              		.comm	Zoffset,1,1
  37              		.comm	ramp,4,4
  38              		.section	.text.InitUARTs,"ax",%progbits
  39              		.align	2
  40              		.global	InitUARTs
  41              		.code	16
  42              		.thumb_func
  44              	InitUARTs:
  45              	.LFB0:
  46              		.file 1 "../Sources/UART.c"
   1:../Sources/UART.c **** #include "Config.h"
   2:../Sources/UART.c **** #include "UART.h"
   3:../Sources/UART.c **** 
   4:../Sources/UART.c **** void uart0_init(int sysclk, int baud);
   5:../Sources/UART.c **** 
   6:../Sources/UART.c **** void InitUARTs() {
  47              		.loc 1 6 0
  48              		.cfi_startproc
  49 0000 80B5     		push	{r7, lr}
  50              	.LCFI0:
  51              		.cfi_def_cfa_offset 8
  52              		.cfi_offset 7, -8
  53              		.cfi_offset 14, -4
  54 0002 00AF     		add	r7, sp, #0
  55              	.LCFI1:
  56              		.cfi_def_cfa_register 7
   7:../Sources/UART.c **** 	SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
  57              		.loc 1 7 0
  58 0004 194A     		ldr	r2, .L2
  59 0006 1949     		ldr	r1, .L2
  60 0008 194B     		ldr	r3, .L2+4
  61 000a CB58     		ldr	r3, [r1, r3]
  62 000c 8021     		mov	r1, #128
  63 000e 8900     		lsl	r1, r1, #2
  64 0010 1943     		orr	r1, r3
  65 0012 174B     		ldr	r3, .L2+4
  66 0014 D150     		str	r1, [r2, r3]
   8:../Sources/UART.c **** 
   9:../Sources/UART.c **** 	PORTA_PCR1 = PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
  67              		.loc 1 9 0
  68 0016 174B     		ldr	r3, .L2+8
  69 0018 9022     		mov	r2, #144
  70 001a 9200     		lsl	r2, r2, #2
  71 001c 5A60     		str	r2, [r3, #4]
  10:../Sources/UART.c **** 	PORTA_PCR2 = PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
  72              		.loc 1 10 0
  73 001e 154B     		ldr	r3, .L2+8
  74 0020 9022     		mov	r2, #144
  75 0022 9200     		lsl	r2, r2, #2
  76 0024 9A60     		str	r2, [r3, #8]
  11:../Sources/UART.c **** 
  12:../Sources/UART.c **** 	//Select PLL/2 Clock
  13:../Sources/UART.c **** 	SIM_SOPT2 &= ~(3 << 26);
  77              		.loc 1 13 0
  78 0026 114A     		ldr	r2, .L2
  79 0028 1049     		ldr	r1, .L2
  80 002a 134B     		ldr	r3, .L2+12
  81 002c C958     		ldr	r1, [r1, r3]
  82 002e 134B     		ldr	r3, .L2+16
  83 0030 1940     		and	r1, r3
  84 0032 114B     		ldr	r3, .L2+12
  85 0034 D150     		str	r1, [r2, r3]
  14:../Sources/UART.c **** 	SIM_SOPT2 |= SIM_SOPT2_UART0SRC(1);
  86              		.loc 1 14 0
  87 0036 0D4A     		ldr	r2, .L2
  88 0038 0C49     		ldr	r1, .L2
  89 003a 0F4B     		ldr	r3, .L2+12
  90 003c CB58     		ldr	r3, [r1, r3]
  91 003e 8021     		mov	r1, #128
  92 0040 C904     		lsl	r1, r1, #19
  93 0042 1943     		orr	r1, r3
  94 0044 0C4B     		ldr	r3, .L2+12
  95 0046 D150     		str	r1, [r2, r3]
  15:../Sources/UART.c **** 	SIM_SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK;
  96              		.loc 1 15 0
  97 0048 084A     		ldr	r2, .L2
  98 004a 0849     		ldr	r1, .L2
  99 004c 0A4B     		ldr	r3, .L2+12
 100 004e CB58     		ldr	r3, [r1, r3]
 101 0050 8021     		mov	r1, #128
 102 0052 4902     		lsl	r1, r1, #9
 103 0054 1943     		orr	r1, r3
 104 0056 084B     		ldr	r3, .L2+12
 105 0058 D150     		str	r1, [r2, r3]
  16:../Sources/UART.c **** 
  17:../Sources/UART.c **** 	//We have to feed this function the clock in KHz!
  18:../Sources/UART.c **** 	uart0_init(CORE_CLOCK / 2 / 1000, SDA_SERIAL_BAUD);
 106              		.loc 1 18 0
 107 005a 094A     		ldr	r2, .L2+20
 108 005c E123     		mov	r3, #225
 109 005e 5B02     		lsl	r3, r3, #9
 110 0060 101C     		mov	r0, r2
 111 0062 191C     		mov	r1, r3
 112 0064 FFF7FEFF 		bl	uart0_init
  19:../Sources/UART.c **** }
 113              		.loc 1 19 0
 114 0068 BD46     		mov	sp, r7
 115              		@ sp needed for prologue
 116 006a 80BD     		pop	{r7, pc}
 117              	.L3:
 118              		.align	2
 119              	.L2:
 120 006c 00700440 		.word	1074032640
 121 0070 38100000 		.word	4152
 122 0074 00900440 		.word	1074040832
 123 0078 04100000 		.word	4100
 124 007c FFFFFFF3 		.word	-201326593
 125 0080 C05D0000 		.word	24000
 126              		.cfi_endproc
 127              	.LFE0:
 129              		.global	__aeabi_uidiv
 130              		.section	.text.uart0_init,"ax",%progbits
 131              		.align	2
 132              		.global	uart0_init
 133              		.code	16
 134              		.thumb_func
 136              	uart0_init:
 137              	.LFB1:
  20:../Sources/UART.c **** 
  21:../Sources/UART.c **** void uart0_init(int sysclk, int baud) {
 138              		.loc 1 21 0
 139              		.cfi_startproc
 140 0000 80B5     		push	{r7, lr}
 141              	.LCFI2:
 142              		.cfi_def_cfa_offset 8
 143              		.cfi_offset 7, -8
 144              		.cfi_offset 14, -4
 145 0002 8CB0     		sub	sp, sp, #48
 146              	.LCFI3:
 147              		.cfi_def_cfa_offset 56
 148 0004 00AF     		add	r7, sp, #0
 149              	.LCFI4:
 150              		.cfi_def_cfa_register 7
 151 0006 7860     		str	r0, [r7, #4]
 152 0008 3960     		str	r1, [r7]
  22:../Sources/UART.c **** 	uint8 i;
  23:../Sources/UART.c **** 	uint32 calculated_baud = 0;
 153              		.loc 1 23 0
 154 000a 0023     		mov	r3, #0
 155 000c FB61     		str	r3, [r7, #28]
  24:../Sources/UART.c **** 	uint32 baud_diff = 0;
 156              		.loc 1 24 0
 157 000e 0023     		mov	r3, #0
 158 0010 BB62     		str	r3, [r7, #40]
  25:../Sources/UART.c **** 	uint32 osr_val = 0;
 159              		.loc 1 25 0
 160 0012 0023     		mov	r3, #0
 161 0014 7B62     		str	r3, [r7, #36]
  26:../Sources/UART.c **** 	uint32 sbr_val, uart0clk;
  27:../Sources/UART.c **** 	uint32 baud_rate;
  28:../Sources/UART.c **** 	uint32 reg_temp = 0;
 162              		.loc 1 28 0
 163 0016 0023     		mov	r3, #0
 164 0018 BB61     		str	r3, [r7, #24]
  29:../Sources/UART.c **** 	uint32 temp = 0;
 165              		.loc 1 29 0
 166 001a 0023     		mov	r3, #0
 167 001c 3B62     		str	r3, [r7, #32]
  30:../Sources/UART.c **** 
  31:../Sources/UART.c **** 	SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
 168              		.loc 1 31 0
 169 001e 7D4A     		ldr	r2, .L17
 170 0020 7C49     		ldr	r1, .L17
 171 0022 7D4B     		ldr	r3, .L17+4
 172 0024 CB58     		ldr	r3, [r1, r3]
 173 0026 8021     		mov	r1, #128
 174 0028 C900     		lsl	r1, r1, #3
 175 002a 1943     		orr	r1, r3
 176 002c 7A4B     		ldr	r3, .L17+4
 177 002e D150     		str	r1, [r2, r3]
  32:../Sources/UART.c **** 
  33:../Sources/UART.c **** 	// Disable UART0 before changing registers
  34:../Sources/UART.c **** 	UART0_C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
 178              		.loc 1 34 0
 179 0030 7A4B     		ldr	r3, .L17+8
 180 0032 7A4A     		ldr	r2, .L17+8
 181 0034 D278     		ldrb	r2, [r2, #3]
 182 0036 D2B2     		uxtb	r2, r2
 183 0038 0C21     		mov	r1, #12
 184 003a 8A43     		bic	r2, r1
 185 003c D2B2     		uxtb	r2, r2
 186 003e DA70     		strb	r2, [r3, #3]
  35:../Sources/UART.c **** 
  36:../Sources/UART.c **** 	// Verify that a valid clock value has been passed to the function 
  37:../Sources/UART.c **** 	if ((sysclk > 50000) || (sysclk < 32)) {
 187              		.loc 1 37 0
 188 0040 7A68     		ldr	r2, [r7, #4]
 189 0042 774B     		ldr	r3, .L17+12
 190 0044 9A42     		cmp	r2, r3
 191 0046 02DC     		bgt	.L5
 192              		.loc 1 37 0 is_stmt 0
 193 0048 7B68     		ldr	r3, [r7, #4]
 194 004a 1F2B     		cmp	r3, #31
 195 004c 0EDC     		bgt	.L6
 196              	.L5:
  38:../Sources/UART.c **** 		sysclk = 0;
 197              		.loc 1 38 0 is_stmt 1
 198 004e 0023     		mov	r3, #0
 199 0050 7B60     		str	r3, [r7, #4]
  39:../Sources/UART.c **** 		reg_temp = SIM_SOPT2;
 200              		.loc 1 39 0
 201 0052 704A     		ldr	r2, .L17
 202 0054 734B     		ldr	r3, .L17+16
 203 0056 D358     		ldr	r3, [r2, r3]
 204 0058 BB61     		str	r3, [r7, #24]
  40:../Sources/UART.c **** 		reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
 205              		.loc 1 40 0
 206 005a BA69     		ldr	r2, [r7, #24]
 207 005c 724B     		ldr	r3, .L17+20
 208 005e 1340     		and	r3, r2
 209 0060 BB61     		str	r3, [r7, #24]
  41:../Sources/UART.c **** 		reg_temp |= SIM_SOPT2_UART0SRC(0);
  42:../Sources/UART.c **** 		SIM_SOPT2 = reg_temp;
 210              		.loc 1 42 0
 211 0062 6C4A     		ldr	r2, .L17
 212 0064 6F4B     		ldr	r3, .L17+16
 213 0066 B969     		ldr	r1, [r7, #24]
 214 0068 D150     		str	r1, [r2, r3]
 215              	.L7:
  43:../Sources/UART.c **** 
  44:../Sources/UART.c **** 		// Enter inifinite loop because the 
  45:../Sources/UART.c **** 		// the desired system clock value is 
  46:../Sources/UART.c **** 		// invalid!!
  47:../Sources/UART.c **** 		while (1) {
  48:../Sources/UART.c **** 		}
 216              		.loc 1 48 0
 217 006a FEE7     		b	.L7
 218              	.L6:
  49:../Sources/UART.c **** 	}
  50:../Sources/UART.c **** 
  51:../Sources/UART.c **** 	// Initialize baud rate
  52:../Sources/UART.c **** 	baud_rate = baud;
 219              		.loc 1 52 0
 220 006c 3B68     		ldr	r3, [r7]
 221 006e 7B61     		str	r3, [r7, #20]
  53:../Sources/UART.c **** 
  54:../Sources/UART.c **** 	// Change units to Hz
  55:../Sources/UART.c **** 	uart0clk = sysclk * 1000;
 222              		.loc 1 55 0
 223 0070 7B68     		ldr	r3, [r7, #4]
 224 0072 FA22     		mov	r2, #250
 225 0074 9200     		lsl	r2, r2, #2
 226 0076 5343     		mul	r3, r2
 227 0078 3B61     		str	r3, [r7, #16]
  56:../Sources/UART.c **** 	// Calculate the first baud rate using the lowest OSR value possible.  
  57:../Sources/UART.c **** 	i = 4;
 228              		.loc 1 57 0
 229 007a 3B1C     		mov	r3, r7
 230 007c 2F33     		add	r3, r3, #47
 231 007e 0422     		mov	r2, #4
 232 0080 1A70     		strb	r2, [r3]
  58:../Sources/UART.c **** 	sbr_val = (uint32) (uart0clk / (baud_rate * i));
 233              		.loc 1 58 0
 234 0082 3B1C     		mov	r3, r7
 235 0084 2F33     		add	r3, r3, #47
 236 0086 1B78     		ldrb	r3, [r3]
 237 0088 7A69     		ldr	r2, [r7, #20]
 238 008a 5343     		mul	r3, r2
 239 008c 3869     		ldr	r0, [r7, #16]
 240 008e 191C     		mov	r1, r3
 241 0090 FFF7FEFF 		bl	__aeabi_uidiv
 242 0094 031C     		mov	r3, r0
 243 0096 FB60     		str	r3, [r7, #12]
  59:../Sources/UART.c **** 	calculated_baud = (uart0clk / (i * sbr_val));
 244              		.loc 1 59 0
 245 0098 3B1C     		mov	r3, r7
 246 009a 2F33     		add	r3, r3, #47
 247 009c 1B78     		ldrb	r3, [r3]
 248 009e FA68     		ldr	r2, [r7, #12]
 249 00a0 5343     		mul	r3, r2
 250 00a2 3869     		ldr	r0, [r7, #16]
 251 00a4 191C     		mov	r1, r3
 252 00a6 FFF7FEFF 		bl	__aeabi_uidiv
 253 00aa 031C     		mov	r3, r0
 254 00ac FB61     		str	r3, [r7, #28]
  60:../Sources/UART.c **** 
  61:../Sources/UART.c **** 	if (calculated_baud > baud_rate)
 255              		.loc 1 61 0
 256 00ae FA69     		ldr	r2, [r7, #28]
 257 00b0 7B69     		ldr	r3, [r7, #20]
 258 00b2 9A42     		cmp	r2, r3
 259 00b4 04D9     		bls	.L8
  62:../Sources/UART.c **** 		baud_diff = calculated_baud - baud_rate;
 260              		.loc 1 62 0
 261 00b6 FA69     		ldr	r2, [r7, #28]
 262 00b8 7B69     		ldr	r3, [r7, #20]
 263 00ba D31A     		sub	r3, r2, r3
 264 00bc BB62     		str	r3, [r7, #40]
 265 00be 03E0     		b	.L9
 266              	.L8:
  63:../Sources/UART.c **** 	else
  64:../Sources/UART.c **** 		baud_diff = baud_rate - calculated_baud;
 267              		.loc 1 64 0
 268 00c0 7A69     		ldr	r2, [r7, #20]
 269 00c2 FB69     		ldr	r3, [r7, #28]
 270 00c4 D31A     		sub	r3, r2, r3
 271 00c6 BB62     		str	r3, [r7, #40]
 272              	.L9:
  65:../Sources/UART.c **** 
  66:../Sources/UART.c **** 	osr_val = i;
 273              		.loc 1 66 0
 274 00c8 3B1C     		mov	r3, r7
 275 00ca 2F33     		add	r3, r3, #47
 276 00cc 1B78     		ldrb	r3, [r3]
 277 00ce 7B62     		str	r3, [r7, #36]
  67:../Sources/UART.c **** 
  68:../Sources/UART.c **** 	// Select the best OSR value
  69:../Sources/UART.c **** 	for (i = 5; i <= 32; i++) {
 278              		.loc 1 69 0
 279 00d0 3B1C     		mov	r3, r7
 280 00d2 2F33     		add	r3, r3, #47
 281 00d4 0522     		mov	r2, #5
 282 00d6 1A70     		strb	r2, [r3]
 283 00d8 33E0     		b	.L10
 284              	.L14:
  70:../Sources/UART.c **** 		sbr_val = (uint32) (uart0clk / (baud_rate * i));
 285              		.loc 1 70 0
 286 00da 3B1C     		mov	r3, r7
 287 00dc 2F33     		add	r3, r3, #47
 288 00de 1B78     		ldrb	r3, [r3]
 289 00e0 7A69     		ldr	r2, [r7, #20]
 290 00e2 5343     		mul	r3, r2
 291 00e4 3869     		ldr	r0, [r7, #16]
 292 00e6 191C     		mov	r1, r3
 293 00e8 FFF7FEFF 		bl	__aeabi_uidiv
 294 00ec 031C     		mov	r3, r0
 295 00ee FB60     		str	r3, [r7, #12]
  71:../Sources/UART.c **** 		calculated_baud = (uart0clk / (i * sbr_val));
 296              		.loc 1 71 0
 297 00f0 3B1C     		mov	r3, r7
 298 00f2 2F33     		add	r3, r3, #47
 299 00f4 1B78     		ldrb	r3, [r3]
 300 00f6 FA68     		ldr	r2, [r7, #12]
 301 00f8 5343     		mul	r3, r2
 302 00fa 3869     		ldr	r0, [r7, #16]
 303 00fc 191C     		mov	r1, r3
 304 00fe FFF7FEFF 		bl	__aeabi_uidiv
 305 0102 031C     		mov	r3, r0
 306 0104 FB61     		str	r3, [r7, #28]
  72:../Sources/UART.c **** 
  73:../Sources/UART.c **** 		if (calculated_baud > baud_rate)
 307              		.loc 1 73 0
 308 0106 FA69     		ldr	r2, [r7, #28]
 309 0108 7B69     		ldr	r3, [r7, #20]
 310 010a 9A42     		cmp	r2, r3
 311 010c 04D9     		bls	.L11
  74:../Sources/UART.c **** 			temp = calculated_baud - baud_rate;
 312              		.loc 1 74 0
 313 010e FA69     		ldr	r2, [r7, #28]
 314 0110 7B69     		ldr	r3, [r7, #20]
 315 0112 D31A     		sub	r3, r2, r3
 316 0114 3B62     		str	r3, [r7, #32]
 317 0116 03E0     		b	.L12
 318              	.L11:
  75:../Sources/UART.c **** 		else
  76:../Sources/UART.c **** 			temp = baud_rate - calculated_baud;
 319              		.loc 1 76 0
 320 0118 7A69     		ldr	r2, [r7, #20]
 321 011a FB69     		ldr	r3, [r7, #28]
 322 011c D31A     		sub	r3, r2, r3
 323 011e 3B62     		str	r3, [r7, #32]
 324              	.L12:
  77:../Sources/UART.c **** 
  78:../Sources/UART.c **** 		if (temp <= baud_diff) {
 325              		.loc 1 78 0
 326 0120 3A6A     		ldr	r2, [r7, #32]
 327 0122 BB6A     		ldr	r3, [r7, #40]
 328 0124 9A42     		cmp	r2, r3
 329 0126 05D8     		bhi	.L13
  79:../Sources/UART.c **** 			baud_diff = temp;
 330              		.loc 1 79 0
 331 0128 3B6A     		ldr	r3, [r7, #32]
 332 012a BB62     		str	r3, [r7, #40]
  80:../Sources/UART.c **** 			osr_val = i;
 333              		.loc 1 80 0
 334 012c 3B1C     		mov	r3, r7
 335 012e 2F33     		add	r3, r3, #47
 336 0130 1B78     		ldrb	r3, [r3]
 337 0132 7B62     		str	r3, [r7, #36]
 338              	.L13:
  69:../Sources/UART.c **** 	for (i = 5; i <= 32; i++) {
 339              		.loc 1 69 0
 340 0134 3B1C     		mov	r3, r7
 341 0136 2F33     		add	r3, r3, #47
 342 0138 3A1C     		mov	r2, r7
 343 013a 2F32     		add	r2, r2, #47
 344 013c 1278     		ldrb	r2, [r2]
 345 013e 0132     		add	r2, r2, #1
 346 0140 1A70     		strb	r2, [r3]
 347              	.L10:
  69:../Sources/UART.c **** 	for (i = 5; i <= 32; i++) {
 348              		.loc 1 69 0 is_stmt 0
 349 0142 3B1C     		mov	r3, r7
 350 0144 2F33     		add	r3, r3, #47
 351 0146 1B78     		ldrb	r3, [r3]
 352 0148 202B     		cmp	r3, #32
 353 014a C6D9     		bls	.L14
  81:../Sources/UART.c **** 		}
  82:../Sources/UART.c **** 	}
  83:../Sources/UART.c **** 
  84:../Sources/UART.c **** 	if (baud_diff < ((baud_rate / 100) * 3)) {
 354              		.loc 1 84 0 is_stmt 1
 355 014c 7B69     		ldr	r3, [r7, #20]
 356 014e 181C     		mov	r0, r3
 357 0150 6421     		mov	r1, #100
 358 0152 FFF7FEFF 		bl	__aeabi_uidiv
 359 0156 031C     		mov	r3, r0
 360 0158 1A1C     		mov	r2, r3
 361 015a 131C     		mov	r3, r2
 362 015c 5B00     		lsl	r3, r3, #1
 363 015e 9A18     		add	r2, r3, r2
 364 0160 BB6A     		ldr	r3, [r7, #40]
 365 0162 9A42     		cmp	r2, r3
 366 0164 52D9     		bls	.L4
  85:../Sources/UART.c **** 		// If the OSR is between 4x and 8x then both
  86:../Sources/UART.c **** 		// edge sampling MUST be turned on.  
  87:../Sources/UART.c **** 		if ((osr_val > 3) && (osr_val < 9))
 367              		.loc 1 87 0
 368 0166 7B6A     		ldr	r3, [r7, #36]
 369 0168 032B     		cmp	r3, #3
 370 016a 0AD9     		bls	.L16
 371              		.loc 1 87 0 is_stmt 0
 372 016c 7B6A     		ldr	r3, [r7, #36]
 373 016e 082B     		cmp	r3, #8
 374 0170 07D8     		bhi	.L16
  88:../Sources/UART.c **** 			UART0_C5 |= UART0_C5_BOTHEDGE_MASK;
 375              		.loc 1 88 0 is_stmt 1
 376 0172 2A4B     		ldr	r3, .L17+8
 377 0174 294A     		ldr	r2, .L17+8
 378 0176 D27A     		ldrb	r2, [r2, #11]
 379 0178 D2B2     		uxtb	r2, r2
 380 017a 0221     		mov	r1, #2
 381 017c 0A43     		orr	r2, r1
 382 017e D2B2     		uxtb	r2, r2
 383 0180 DA72     		strb	r2, [r3, #11]
 384              	.L16:
  89:../Sources/UART.c **** 
  90:../Sources/UART.c **** 		// Setup OSR value 
  91:../Sources/UART.c **** 		reg_temp = UART0_C4;
 385              		.loc 1 91 0
 386 0182 264B     		ldr	r3, .L17+8
 387 0184 9B7A     		ldrb	r3, [r3, #10]
 388 0186 DBB2     		uxtb	r3, r3
 389 0188 BB61     		str	r3, [r7, #24]
  92:../Sources/UART.c **** 		reg_temp &= ~UART0_C4_OSR_MASK;
 390              		.loc 1 92 0
 391 018a BB69     		ldr	r3, [r7, #24]
 392 018c 1F22     		mov	r2, #31
 393 018e 9343     		bic	r3, r2
 394 0190 BB61     		str	r3, [r7, #24]
  93:../Sources/UART.c **** 		reg_temp |= UART0_C4_OSR(osr_val-1);
 395              		.loc 1 93 0
 396 0192 7B6A     		ldr	r3, [r7, #36]
 397 0194 DBB2     		uxtb	r3, r3
 398 0196 013B     		sub	r3, r3, #1
 399 0198 DBB2     		uxtb	r3, r3
 400 019a 1A1C     		mov	r2, r3
 401 019c 1F23     		mov	r3, #31
 402 019e 1340     		and	r3, r2
 403 01a0 BA69     		ldr	r2, [r7, #24]
 404 01a2 1343     		orr	r3, r2
 405 01a4 BB61     		str	r3, [r7, #24]
  94:../Sources/UART.c **** 
  95:../Sources/UART.c **** 		// Write reg_temp to C4 register
  96:../Sources/UART.c **** 		UART0_C4 = reg_temp;
 406              		.loc 1 96 0
 407 01a6 1D4B     		ldr	r3, .L17+8
 408 01a8 BA69     		ldr	r2, [r7, #24]
 409 01aa D2B2     		uxtb	r2, r2
 410 01ac 9A72     		strb	r2, [r3, #10]
  97:../Sources/UART.c **** 
  98:../Sources/UART.c **** 		reg_temp = (reg_temp & UART0_C4_OSR_MASK) + 1;
 411              		.loc 1 98 0
 412 01ae BA69     		ldr	r2, [r7, #24]
 413 01b0 1F23     		mov	r3, #31
 414 01b2 1340     		and	r3, r2
 415 01b4 0133     		add	r3, r3, #1
 416 01b6 BB61     		str	r3, [r7, #24]
  99:../Sources/UART.c **** 		sbr_val = (uint32) ((uart0clk) / (baud_rate * (reg_temp)));
 417              		.loc 1 99 0
 418 01b8 7B69     		ldr	r3, [r7, #20]
 419 01ba BA69     		ldr	r2, [r7, #24]
 420 01bc 5343     		mul	r3, r2
 421 01be 3869     		ldr	r0, [r7, #16]
 422 01c0 191C     		mov	r1, r3
 423 01c2 FFF7FEFF 		bl	__aeabi_uidiv
 424 01c6 031C     		mov	r3, r0
 425 01c8 FB60     		str	r3, [r7, #12]
 100:../Sources/UART.c **** 
 101:../Sources/UART.c **** 		/* Save off the current value of the uartx_BDH except for the SBR field */
 102:../Sources/UART.c **** 		reg_temp = UART0_BDH & ~(UART0_BDH_SBR(0x1F));
 426              		.loc 1 102 0
 427 01ca 144B     		ldr	r3, .L17+8
 428 01cc 1B78     		ldrb	r3, [r3]
 429 01ce DBB2     		uxtb	r3, r3
 430 01d0 1F22     		mov	r2, #31
 431 01d2 9343     		bic	r3, r2
 432 01d4 BB61     		str	r3, [r7, #24]
 103:../Sources/UART.c **** 
 104:../Sources/UART.c **** 		UART0_BDH = reg_temp | UART0_BDH_SBR(((sbr_val & 0x1F00) >> 8));
 433              		.loc 1 104 0
 434 01d6 114B     		ldr	r3, .L17+8
 435 01d8 F968     		ldr	r1, [r7, #12]
 436 01da F822     		mov	r2, #248
 437 01dc 5201     		lsl	r2, r2, #5
 438 01de 0A40     		and	r2, r1
 439 01e0 120A     		lsr	r2, r2, #8
 440 01e2 D1B2     		uxtb	r1, r2
 441 01e4 1F22     		mov	r2, #31
 442 01e6 0A40     		and	r2, r1
 443 01e8 D1B2     		uxtb	r1, r2
 444 01ea BA69     		ldr	r2, [r7, #24]
 445 01ec D2B2     		uxtb	r2, r2
 446 01ee 0A43     		orr	r2, r1
 447 01f0 D2B2     		uxtb	r2, r2
 448 01f2 1A70     		strb	r2, [r3]
 105:../Sources/UART.c **** 		UART0_BDL = (uint8) (sbr_val & UART0_BDL_SBR_MASK);
 449              		.loc 1 105 0
 450 01f4 094B     		ldr	r3, .L17+8
 451 01f6 FA68     		ldr	r2, [r7, #12]
 452 01f8 D2B2     		uxtb	r2, r2
 453 01fa 5A70     		strb	r2, [r3, #1]
 106:../Sources/UART.c **** 
 107:../Sources/UART.c **** 		/* Enable receiver and transmitter */
 108:../Sources/UART.c **** 		UART0_C2 |= (UART0_C2_TE_MASK | UART0_C2_RE_MASK);
 454              		.loc 1 108 0
 455 01fc 074B     		ldr	r3, .L17+8
 456 01fe 074A     		ldr	r2, .L17+8
 457 0200 D278     		ldrb	r2, [r2, #3]
 458 0202 D2B2     		uxtb	r2, r2
 459 0204 0C21     		mov	r1, #12
 460 0206 0A43     		orr	r2, r1
 461 0208 D2B2     		uxtb	r2, r2
 462 020a DA70     		strb	r2, [r3, #3]
 463              	.L4:
 109:../Sources/UART.c **** 	} else {
 110:../Sources/UART.c **** 		// Unacceptable baud rate difference
 111:../Sources/UART.c **** 		// More than 3% difference!!
 112:../Sources/UART.c **** 		// Enter infinite loop!
 113:../Sources/UART.c **** 		//while(1)
 114:../Sources/UART.c **** 		//	{}
 115:../Sources/UART.c **** 	}
 116:../Sources/UART.c **** 
 117:../Sources/UART.c **** }
 464              		.loc 1 117 0
 465 020c BD46     		mov	sp, r7
 466 020e 0CB0     		add	sp, sp, #48
 467              		@ sp needed for prologue
 468 0210 80BD     		pop	{r7, pc}
 469              	.L18:
 470 0212 C046     		.align	2
 471              	.L17:
 472 0214 00700440 		.word	1074032640
 473 0218 34100000 		.word	4148
 474 021c 00A00640 		.word	1074176000
 475 0220 50C30000 		.word	50000
 476 0224 04100000 		.word	4100
 477 0228 FFFFFFF3 		.word	-201326593
 478              		.cfi_endproc
 479              	.LFE1:
 481              		.section	.text.uart_getchar,"ax",%progbits
 482              		.align	2
 483              		.global	uart_getchar
 484              		.code	16
 485              		.thumb_func
 487              	uart_getchar:
 488              	.LFB2:
 118:../Sources/UART.c **** 
 119:../Sources/UART.c **** char uart_getchar() {
 489              		.loc 1 119 0
 490              		.cfi_startproc
 491 0000 80B5     		push	{r7, lr}
 492              	.LCFI5:
 493              		.cfi_def_cfa_offset 8
 494              		.cfi_offset 7, -8
 495              		.cfi_offset 14, -4
 496 0002 00AF     		add	r7, sp, #0
 497              	.LCFI6:
 498              		.cfi_def_cfa_register 7
 120:../Sources/UART.c **** 	/* Wait until character has been received */
 121:../Sources/UART.c **** 	while (!(UART0_S1 & UART_S1_RDRF_MASK));
 499              		.loc 1 121 0
 500 0004 C046     		mov	r8, r8
 501              	.L20:
 502              		.loc 1 121 0 is_stmt 0
 503 0006 064B     		ldr	r3, .L22
 504 0008 1B79     		ldrb	r3, [r3, #4]
 505 000a DBB2     		uxtb	r3, r3
 506 000c 1A1C     		mov	r2, r3
 507 000e 2023     		mov	r3, #32
 508 0010 1340     		and	r3, r2
 509 0012 F8D0     		beq	.L20
 122:../Sources/UART.c **** 
 123:../Sources/UART.c **** 	/* Return the 8-bit data from the receiver */
 124:../Sources/UART.c **** 	return UART0_D;
 510              		.loc 1 124 0 is_stmt 1
 511 0014 024B     		ldr	r3, .L22
 512 0016 DB79     		ldrb	r3, [r3, #7]
 513 0018 DBB2     		uxtb	r3, r3
 125:../Sources/UART.c **** }
 514              		.loc 1 125 0
 515 001a 181C     		mov	r0, r3
 516 001c BD46     		mov	sp, r7
 517              		@ sp needed for prologue
 518 001e 80BD     		pop	{r7, pc}
 519              	.L23:
 520              		.align	2
 521              	.L22:
 522 0020 00A00640 		.word	1074176000
 523              		.cfi_endproc
 524              	.LFE2:
 526              		.section	.text.uart_putchar,"ax",%progbits
 527              		.align	2
 528              		.global	uart_putchar
 529              		.code	16
 530              		.thumb_func
 532              	uart_putchar:
 533              	.LFB3:
 126:../Sources/UART.c **** 
 127:../Sources/UART.c **** 
 128:../Sources/UART.c **** void uart_putchar(char ch) {
 534              		.loc 1 128 0
 535              		.cfi_startproc
 536 0000 80B5     		push	{r7, lr}
 537              	.LCFI7:
 538              		.cfi_def_cfa_offset 8
 539              		.cfi_offset 7, -8
 540              		.cfi_offset 14, -4
 541 0002 82B0     		sub	sp, sp, #8
 542              	.LCFI8:
 543              		.cfi_def_cfa_offset 16
 544 0004 00AF     		add	r7, sp, #0
 545              	.LCFI9:
 546              		.cfi_def_cfa_register 7
 547 0006 021C     		mov	r2, r0
 548 0008 FB1D     		add	r3, r7, #7
 549 000a 1A70     		strb	r2, [r3]
 129:../Sources/UART.c **** 	/* Wait until space is available in the FIFO */
 130:../Sources/UART.c **** 	while (!(UART0_S1 & UART_S1_TDRE_MASK))
 550              		.loc 1 130 0
 551 000c C046     		mov	r8, r8
 552              	.L25:
 553              		.loc 1 130 0 is_stmt 0
 554 000e 074B     		ldr	r3, .L26
 555 0010 1B79     		ldrb	r3, [r3, #4]
 556 0012 DBB2     		uxtb	r3, r3
 557 0014 DBB2     		uxtb	r3, r3
 558 0016 5BB2     		sxtb	r3, r3
 559 0018 002B     		cmp	r3, #0
 560 001a F8DA     		bge	.L25
 131:../Sources/UART.c **** 		;
 132:../Sources/UART.c **** 
 133:../Sources/UART.c **** 	/* Send the character */
 134:../Sources/UART.c **** 	UART0_D = (uint8) ch;
 561              		.loc 1 134 0 is_stmt 1
 562 001c 034B     		ldr	r3, .L26
 563 001e FA1D     		add	r2, r7, #7
 564 0020 1278     		ldrb	r2, [r2]
 565 0022 DA71     		strb	r2, [r3, #7]
 135:../Sources/UART.c **** }
 566              		.loc 1 135 0
 567 0024 BD46     		mov	sp, r7
 568 0026 02B0     		add	sp, sp, #8
 569              		@ sp needed for prologue
 570 0028 80BD     		pop	{r7, pc}
 571              	.L27:
 572 002a C046     		.align	2
 573              	.L26:
 574 002c 00A00640 		.word	1074176000
 575              		.cfi_endproc
 576              	.LFE3:
 578              		.section	.text.uart_getchar_present,"ax",%progbits
 579              		.align	2
 580              		.global	uart_getchar_present
 581              		.code	16
 582              		.thumb_func
 584              	uart_getchar_present:
 585              	.LFB4:
 136:../Sources/UART.c **** 
 137:../Sources/UART.c **** int uart_getchar_present() {
 586              		.loc 1 137 0
 587              		.cfi_startproc
 588 0000 80B5     		push	{r7, lr}
 589              	.LCFI10:
 590              		.cfi_def_cfa_offset 8
 591              		.cfi_offset 7, -8
 592              		.cfi_offset 14, -4
 593 0002 00AF     		add	r7, sp, #0
 594              	.LCFI11:
 595              		.cfi_def_cfa_register 7
 138:../Sources/UART.c **** 	return (UART0_S1 & UART_S1_RDRF_MASK);
 596              		.loc 1 138 0
 597 0004 044B     		ldr	r3, .L30
 598 0006 1B79     		ldrb	r3, [r3, #4]
 599 0008 DBB2     		uxtb	r3, r3
 600 000a 1A1C     		mov	r2, r3
 601 000c 2023     		mov	r3, #32
 602 000e 1340     		and	r3, r2
 139:../Sources/UART.c **** }
 603              		.loc 1 139 0
 604 0010 181C     		mov	r0, r3
 605 0012 BD46     		mov	sp, r7
 606              		@ sp needed for prologue
 607 0014 80BD     		pop	{r7, pc}
 608              	.L31:
 609 0016 C046     		.align	2
 610              	.L30:
 611 0018 00A00640 		.word	1074176000
 612              		.cfi_endproc
 613              	.LFE4:
 615              		.text
 616              	.Letext0:
 617              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 618              		.file 3 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/MKL25Z4.h"
 619              		.file 4 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/system\\arm_cm0.h"
 620              		.file 5 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/Control.h"
 621              		.file 6 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/LineScanCamera.h"
 622              		.file 7 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/PID.h"
 623              		.file 8 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/Accel.h"
DEFINED SYMBOLS
                            *ABS*:00000000 UART.c
                            *COM*:00000004 straight_speed
                            *COM*:00000004 medium_speed
                            *COM*:00000004 turn_speed
                            *COM*:00000004 brake_speed
                            *COM*:00000004 speedC
                            *COM*:000000c8 LineScanData
                            *COM*:00001000 histogram
                            *COM*:00000008 kp
                            *COM*:00000008 ki
                            *COM*:00000008 kd
                            *COM*:00000008 lastError
                            *COM*:00000008 llastError
                            *COM*:00000004 lastOutput
                            *COM*:00000006 AccData
                            *COM*:00000002 Xout
                            *COM*:00000002 Yout
                            *COM*:00000002 Zout
                            *COM*:00000001 Xoffset
                            *COM*:00000001 Yoffset
                            *COM*:00000001 Zoffset
                            *COM*:00000004 ramp
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:39     .text.InitUARTs:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:44     .text.InitUARTs:00000000 InitUARTs
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:136    .text.uart0_init:00000000 uart0_init
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:120    .text.InitUARTs:0000006c $d
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:131    .text.uart0_init:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:472    .text.uart0_init:00000214 $d
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:482    .text.uart_getchar:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:487    .text.uart_getchar:00000000 uart_getchar
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:522    .text.uart_getchar:00000020 $d
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:527    .text.uart_putchar:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:532    .text.uart_putchar:00000000 uart_putchar
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:574    .text.uart_putchar:0000002c $d
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:579    .text.uart_getchar_present:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:584    .text.uart_getchar_present:00000000 uart_getchar_present
C:\Users\BRENTD~1\AppData\Local\Temp\cceGHg7i.s:611    .text.uart_getchar_present:00000018 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidiv
