   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"ADC.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.comm	straight_speed,4,4
  18              		.comm	medium_speed,4,4
  19              		.comm	turn_speed,4,4
  20              		.comm	brake_speed,4,4
  21              		.comm	speedC,4,4
  22              		.comm	LineScanData,200,4
  23              		.comm	histogram,4096,4
  24              		.comm	kp,8,8
  25              		.comm	ki,8,8
  26              		.comm	kd,8,8
  27              		.comm	lastError,8,8
  28              		.comm	llastError,8,8
  29              		.comm	lastOutput,4,4
  30              		.comm	AccData,6,4
  31              		.comm	Xout,2,2
  32              		.comm	Yout,2,2
  33              		.comm	Zout,2,2
  34              		.comm	Xoffset,1,1
  35              		.comm	Yoffset,1,1
  36              		.comm	Zoffset,1,1
  37              		.comm	ramp,4,4
  38              		.section	.bss.CurrentADC_State,"aw",%nobits
  41              	CurrentADC_State:
  42 0000 00       		.space	1
  43              		.global	CurrentLineScanPixel
  44              		.section	.bss.CurrentLineScanPixel,"aw",%nobits
  47              	CurrentLineScanPixel:
  48 0000 00       		.space	1
  49              		.global	CurrentLineScanChannel
  50              		.section	.bss.CurrentLineScanChannel,"aw",%nobits
  53              	CurrentLineScanChannel:
  54 0000 00       		.space	1
  55              		.global	BatSenseADC_Value
  56              		.section	.bss.BatSenseADC_Value,"aw",%nobits
  57              		.align	1
  60              	BatSenseADC_Value:
  61 0000 0000     		.space	2
  62              		.section	.text.ADC_Cal,"ax",%progbits
  63              		.align	2
  64              		.global	ADC_Cal
  65              		.code	16
  66              		.thumb_func
  68              	ADC_Cal:
  69              	.LFB0:
  70              		.file 1 "../Sources/ADC.c"
   1:../Sources/ADC.c **** #include "Config.h"
   2:../Sources/ADC.c **** 
   3:../Sources/ADC.c **** //ADC globals
   4:../Sources/ADC.c **** static uint8_t CurrentADC_State = ADC_STATE_INIT;
   5:../Sources/ADC.c **** volatile uint8_t CurrentLineScanPixel = 0;
   6:../Sources/ADC.c **** volatile uint8_t CurrentLineScanChannel = 0;
   7:../Sources/ADC.c **** volatile uint16_t BatSenseADC_Value = 0; 
   8:../Sources/ADC.c **** 
   9:../Sources/ADC.c **** /******************************************************************************
  10:../Sources/ADC.c ****  Function 1. Name	AUTO CAL ROUTINE   
  11:../Sources/ADC.c **** 
  12:../Sources/ADC.c ****  Parameters		ADC module pointer points to adc0 or adc1 register map 
  13:../Sources/ADC.c ****  base address.
  14:../Sources/ADC.c ****  Returns			Zero indicates success.
  15:../Sources/ADC.c ****  Notes         		Calibrates the ADC16. Required to meet specifications 
  16:../Sources/ADC.c ****  after reset and before a conversion is initiated.
  17:../Sources/ADC.c ****  ******************************************************************************/
  18:../Sources/ADC.c **** unsigned char ADC_Cal(ADC_MemMapPtr adcmap)
  19:../Sources/ADC.c **** {
  71              		.loc 1 19 0
  72              		.cfi_startproc
  73 0000 80B5     		push	{r7, lr}
  74              	.LCFI0:
  75              		.cfi_def_cfa_offset 8
  76              		.cfi_offset 7, -8
  77              		.cfi_offset 14, -4
  78 0002 84B0     		sub	sp, sp, #16
  79              	.LCFI1:
  80              		.cfi_def_cfa_offset 24
  81 0004 00AF     		add	r7, sp, #0
  82              	.LCFI2:
  83              		.cfi_def_cfa_register 7
  84 0006 7860     		str	r0, [r7, #4]
  20:../Sources/ADC.c **** 
  21:../Sources/ADC.c **** 	unsigned short cal_var;
  22:../Sources/ADC.c **** 
  23:../Sources/ADC.c **** 	ADC_SC2_REG(adcmap) &= ~ADC_SC2_ADTRG_MASK; // Enable Software Conversion Trigger for Calibration 
  85              		.loc 1 23 0
  86 0008 7B68     		ldr	r3, [r7, #4]
  87 000a 1B6A     		ldr	r3, [r3, #32]
  88 000c 4022     		mov	r2, #64
  89 000e 191C     		mov	r1, r3
  90 0010 9143     		bic	r1, r2
  91 0012 0A1C     		mov	r2, r1
  92 0014 7B68     		ldr	r3, [r7, #4]
  93 0016 1A62     		str	r2, [r3, #32]
  24:../Sources/ADC.c **** 	ADC_SC3_REG(adcmap) &= (~ADC_SC3_ADCO_MASK & ~ADC_SC3_AVGS_MASK); // set single conversion, clear 
  94              		.loc 1 24 0
  95 0018 7B68     		ldr	r3, [r7, #4]
  96 001a 5B6A     		ldr	r3, [r3, #36]
  97 001c 0B22     		mov	r2, #11
  98 001e 191C     		mov	r1, r3
  99 0020 9143     		bic	r1, r2
 100 0022 0A1C     		mov	r2, r1
 101 0024 7B68     		ldr	r3, [r7, #4]
 102 0026 5A62     		str	r2, [r3, #36]
  25:../Sources/ADC.c **** 	ADC_SC3_REG(adcmap) |= (ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(AVGS_32)); // Turn averaging ON and set a
 103              		.loc 1 25 0
 104 0028 7B68     		ldr	r3, [r7, #4]
 105 002a 5B6A     		ldr	r3, [r3, #36]
 106 002c 0722     		mov	r2, #7
 107 002e 1A43     		orr	r2, r3
 108 0030 7B68     		ldr	r3, [r7, #4]
 109 0032 5A62     		str	r2, [r3, #36]
  26:../Sources/ADC.c **** 
  27:../Sources/ADC.c **** 	ADC_SC3_REG(adcmap) |= ADC_SC3_CAL_MASK;      // Start CAL
 110              		.loc 1 27 0
 111 0034 7B68     		ldr	r3, [r7, #4]
 112 0036 5B6A     		ldr	r3, [r3, #36]
 113 0038 8022     		mov	r2, #128
 114 003a 1A43     		orr	r2, r3
 115 003c 7B68     		ldr	r3, [r7, #4]
 116 003e 5A62     		str	r2, [r3, #36]
  28:../Sources/ADC.c **** 	while ((ADC_SC1_REG(adcmap,A)& ADC_SC1_COCO_MASK ) == COCO_NOT ); // Wait calibration end
 117              		.loc 1 28 0
 118 0040 C046     		mov	r8, r8
 119              	.L2:
 120              		.loc 1 28 0 is_stmt 0
 121 0042 7B68     		ldr	r3, [r7, #4]
 122 0044 1A68     		ldr	r2, [r3]
 123 0046 8023     		mov	r3, #128
 124 0048 1340     		and	r3, r2
 125 004a FAD0     		beq	.L2
  29:../Sources/ADC.c **** 
  30:../Sources/ADC.c **** 	if ((ADC_SC3_REG(adcmap) & ADC_SC3_CALF_MASK) == CALF_FAIL)
 126              		.loc 1 30 0 is_stmt 1
 127 004c 7B68     		ldr	r3, [r7, #4]
 128 004e 5A6A     		ldr	r2, [r3, #36]
 129 0050 4023     		mov	r3, #64
 130 0052 1340     		and	r3, r2
 131 0054 01D0     		beq	.L3
  31:../Sources/ADC.c **** 	{
  32:../Sources/ADC.c **** 		return (1);    // Check for Calibration fail error and return 
 132              		.loc 1 32 0
 133 0056 0123     		mov	r3, #1
 134 0058 A6E0     		b	.L4
 135              	.L3:
  33:../Sources/ADC.c **** 	}
  34:../Sources/ADC.c **** 	// Calculate plus-side calibration
  35:../Sources/ADC.c **** 	cal_var = 0x00;
 136              		.loc 1 35 0
 137 005a 3B1C     		mov	r3, r7
 138 005c 0E33     		add	r3, r3, #14
 139 005e 0022     		mov	r2, #0
 140 0060 1A80     		strh	r2, [r3]
  36:../Sources/ADC.c **** 
  37:../Sources/ADC.c **** 	cal_var = ADC_CLP0_REG(adcmap);
 141              		.loc 1 37 0
 142 0062 7B68     		ldr	r3, [r7, #4]
 143 0064 DA6C     		ldr	r2, [r3, #76]
 144 0066 3B1C     		mov	r3, r7
 145 0068 0E33     		add	r3, r3, #14
 146 006a 1A80     		strh	r2, [r3]
  38:../Sources/ADC.c **** 	cal_var += ADC_CLP1_REG(adcmap);
 147              		.loc 1 38 0
 148 006c 7B68     		ldr	r3, [r7, #4]
 149 006e 9B6C     		ldr	r3, [r3, #72]
 150 0070 99B2     		uxth	r1, r3
 151 0072 3B1C     		mov	r3, r7
 152 0074 0E33     		add	r3, r3, #14
 153 0076 3A1C     		mov	r2, r7
 154 0078 0E32     		add	r2, r2, #14
 155 007a 1288     		ldrh	r2, [r2]
 156 007c 8A18     		add	r2, r1, r2
 157 007e 1A80     		strh	r2, [r3]
  39:../Sources/ADC.c **** 	cal_var += ADC_CLP2_REG(adcmap);
 158              		.loc 1 39 0
 159 0080 7B68     		ldr	r3, [r7, #4]
 160 0082 5B6C     		ldr	r3, [r3, #68]
 161 0084 99B2     		uxth	r1, r3
 162 0086 3B1C     		mov	r3, r7
 163 0088 0E33     		add	r3, r3, #14
 164 008a 3A1C     		mov	r2, r7
 165 008c 0E32     		add	r2, r2, #14
 166 008e 1288     		ldrh	r2, [r2]
 167 0090 8A18     		add	r2, r1, r2
 168 0092 1A80     		strh	r2, [r3]
  40:../Sources/ADC.c **** 	cal_var += ADC_CLP3_REG(adcmap);
 169              		.loc 1 40 0
 170 0094 7B68     		ldr	r3, [r7, #4]
 171 0096 1B6C     		ldr	r3, [r3, #64]
 172 0098 99B2     		uxth	r1, r3
 173 009a 3B1C     		mov	r3, r7
 174 009c 0E33     		add	r3, r3, #14
 175 009e 3A1C     		mov	r2, r7
 176 00a0 0E32     		add	r2, r2, #14
 177 00a2 1288     		ldrh	r2, [r2]
 178 00a4 8A18     		add	r2, r1, r2
 179 00a6 1A80     		strh	r2, [r3]
  41:../Sources/ADC.c **** 	cal_var += ADC_CLP4_REG(adcmap);
 180              		.loc 1 41 0
 181 00a8 7B68     		ldr	r3, [r7, #4]
 182 00aa DB6B     		ldr	r3, [r3, #60]
 183 00ac 99B2     		uxth	r1, r3
 184 00ae 3B1C     		mov	r3, r7
 185 00b0 0E33     		add	r3, r3, #14
 186 00b2 3A1C     		mov	r2, r7
 187 00b4 0E32     		add	r2, r2, #14
 188 00b6 1288     		ldrh	r2, [r2]
 189 00b8 8A18     		add	r2, r1, r2
 190 00ba 1A80     		strh	r2, [r3]
  42:../Sources/ADC.c **** 	cal_var += ADC_CLPS_REG(adcmap);
 191              		.loc 1 42 0
 192 00bc 7B68     		ldr	r3, [r7, #4]
 193 00be 9B6B     		ldr	r3, [r3, #56]
 194 00c0 99B2     		uxth	r1, r3
 195 00c2 3B1C     		mov	r3, r7
 196 00c4 0E33     		add	r3, r3, #14
 197 00c6 3A1C     		mov	r2, r7
 198 00c8 0E32     		add	r2, r2, #14
 199 00ca 1288     		ldrh	r2, [r2]
 200 00cc 8A18     		add	r2, r1, r2
 201 00ce 1A80     		strh	r2, [r3]
  43:../Sources/ADC.c **** 
  44:../Sources/ADC.c **** 	cal_var = cal_var / 2;
 202              		.loc 1 44 0
 203 00d0 3B1C     		mov	r3, r7
 204 00d2 0E33     		add	r3, r3, #14
 205 00d4 3A1C     		mov	r2, r7
 206 00d6 0E32     		add	r2, r2, #14
 207 00d8 1288     		ldrh	r2, [r2]
 208 00da 5208     		lsr	r2, r2, #1
 209 00dc 1A80     		strh	r2, [r3]
  45:../Sources/ADC.c **** 	cal_var |= 0x8000; // Set MSB
 210              		.loc 1 45 0
 211 00de 3B1C     		mov	r3, r7
 212 00e0 0E33     		add	r3, r3, #14
 213 00e2 3A1C     		mov	r2, r7
 214 00e4 0E32     		add	r2, r2, #14
 215 00e6 1288     		ldrh	r2, [r2]
 216 00e8 3149     		ldr	r1, .L5
 217 00ea 0A43     		orr	r2, r1
 218 00ec 1A80     		strh	r2, [r3]
  46:../Sources/ADC.c **** 
  47:../Sources/ADC.c **** 	ADC_PG_REG(adcmap) = ADC_PG_PG(cal_var);
 219              		.loc 1 47 0
 220 00ee 3B1C     		mov	r3, r7
 221 00f0 0E33     		add	r3, r3, #14
 222 00f2 1A88     		ldrh	r2, [r3]
 223 00f4 7B68     		ldr	r3, [r7, #4]
 224 00f6 DA62     		str	r2, [r3, #44]
  48:../Sources/ADC.c **** 
  49:../Sources/ADC.c **** 	// Calculate minus-side calibration
  50:../Sources/ADC.c **** 	cal_var = 0x00;
 225              		.loc 1 50 0
 226 00f8 3B1C     		mov	r3, r7
 227 00fa 0E33     		add	r3, r3, #14
 228 00fc 0022     		mov	r2, #0
 229 00fe 1A80     		strh	r2, [r3]
  51:../Sources/ADC.c **** 
  52:../Sources/ADC.c **** 	cal_var = ADC_CLM0_REG(adcmap);
 230              		.loc 1 52 0
 231 0100 7B68     		ldr	r3, [r7, #4]
 232 0102 DA6E     		ldr	r2, [r3, #108]
 233 0104 3B1C     		mov	r3, r7
 234 0106 0E33     		add	r3, r3, #14
 235 0108 1A80     		strh	r2, [r3]
  53:../Sources/ADC.c **** 	cal_var += ADC_CLM1_REG(adcmap);
 236              		.loc 1 53 0
 237 010a 7B68     		ldr	r3, [r7, #4]
 238 010c 9B6E     		ldr	r3, [r3, #104]
 239 010e 99B2     		uxth	r1, r3
 240 0110 3B1C     		mov	r3, r7
 241 0112 0E33     		add	r3, r3, #14
 242 0114 3A1C     		mov	r2, r7
 243 0116 0E32     		add	r2, r2, #14
 244 0118 1288     		ldrh	r2, [r2]
 245 011a 8A18     		add	r2, r1, r2
 246 011c 1A80     		strh	r2, [r3]
  54:../Sources/ADC.c **** 	cal_var += ADC_CLM2_REG(adcmap);
 247              		.loc 1 54 0
 248 011e 7B68     		ldr	r3, [r7, #4]
 249 0120 5B6E     		ldr	r3, [r3, #100]
 250 0122 99B2     		uxth	r1, r3
 251 0124 3B1C     		mov	r3, r7
 252 0126 0E33     		add	r3, r3, #14
 253 0128 3A1C     		mov	r2, r7
 254 012a 0E32     		add	r2, r2, #14
 255 012c 1288     		ldrh	r2, [r2]
 256 012e 8A18     		add	r2, r1, r2
 257 0130 1A80     		strh	r2, [r3]
  55:../Sources/ADC.c **** 	cal_var += ADC_CLM3_REG(adcmap);
 258              		.loc 1 55 0
 259 0132 7B68     		ldr	r3, [r7, #4]
 260 0134 1B6E     		ldr	r3, [r3, #96]
 261 0136 99B2     		uxth	r1, r3
 262 0138 3B1C     		mov	r3, r7
 263 013a 0E33     		add	r3, r3, #14
 264 013c 3A1C     		mov	r2, r7
 265 013e 0E32     		add	r2, r2, #14
 266 0140 1288     		ldrh	r2, [r2]
 267 0142 8A18     		add	r2, r1, r2
 268 0144 1A80     		strh	r2, [r3]
  56:../Sources/ADC.c **** 	cal_var += ADC_CLM4_REG(adcmap);
 269              		.loc 1 56 0
 270 0146 7B68     		ldr	r3, [r7, #4]
 271 0148 DB6D     		ldr	r3, [r3, #92]
 272 014a 99B2     		uxth	r1, r3
 273 014c 3B1C     		mov	r3, r7
 274 014e 0E33     		add	r3, r3, #14
 275 0150 3A1C     		mov	r2, r7
 276 0152 0E32     		add	r2, r2, #14
 277 0154 1288     		ldrh	r2, [r2]
 278 0156 8A18     		add	r2, r1, r2
 279 0158 1A80     		strh	r2, [r3]
  57:../Sources/ADC.c **** 	cal_var += ADC_CLMS_REG(adcmap);
 280              		.loc 1 57 0
 281 015a 7B68     		ldr	r3, [r7, #4]
 282 015c 9B6D     		ldr	r3, [r3, #88]
 283 015e 99B2     		uxth	r1, r3
 284 0160 3B1C     		mov	r3, r7
 285 0162 0E33     		add	r3, r3, #14
 286 0164 3A1C     		mov	r2, r7
 287 0166 0E32     		add	r2, r2, #14
 288 0168 1288     		ldrh	r2, [r2]
 289 016a 8A18     		add	r2, r1, r2
 290 016c 1A80     		strh	r2, [r3]
  58:../Sources/ADC.c **** 
  59:../Sources/ADC.c **** 	cal_var = cal_var / 2;
 291              		.loc 1 59 0
 292 016e 3B1C     		mov	r3, r7
 293 0170 0E33     		add	r3, r3, #14
 294 0172 3A1C     		mov	r2, r7
 295 0174 0E32     		add	r2, r2, #14
 296 0176 1288     		ldrh	r2, [r2]
 297 0178 5208     		lsr	r2, r2, #1
 298 017a 1A80     		strh	r2, [r3]
  60:../Sources/ADC.c **** 
  61:../Sources/ADC.c **** 	cal_var |= 0x8000; // Set MSB
 299              		.loc 1 61 0
 300 017c 3B1C     		mov	r3, r7
 301 017e 0E33     		add	r3, r3, #14
 302 0180 3A1C     		mov	r2, r7
 303 0182 0E32     		add	r2, r2, #14
 304 0184 1288     		ldrh	r2, [r2]
 305 0186 0A49     		ldr	r1, .L5
 306 0188 0A43     		orr	r2, r1
 307 018a 1A80     		strh	r2, [r3]
  62:../Sources/ADC.c **** 
  63:../Sources/ADC.c **** 	ADC_MG_REG(adcmap) = ADC_MG_MG(cal_var);
 308              		.loc 1 63 0
 309 018c 3B1C     		mov	r3, r7
 310 018e 0E33     		add	r3, r3, #14
 311 0190 1A88     		ldrh	r2, [r3]
 312 0192 7B68     		ldr	r3, [r7, #4]
 313 0194 1A63     		str	r2, [r3, #48]
  64:../Sources/ADC.c **** 
  65:../Sources/ADC.c **** 	ADC_SC3_REG(adcmap) &= ~ADC_SC3_CAL_MASK; /* Clear CAL bit */
 314              		.loc 1 65 0
 315 0196 7B68     		ldr	r3, [r7, #4]
 316 0198 5B6A     		ldr	r3, [r3, #36]
 317 019a 8022     		mov	r2, #128
 318 019c 191C     		mov	r1, r3
 319 019e 9143     		bic	r1, r2
 320 01a0 0A1C     		mov	r2, r1
 321 01a2 7B68     		ldr	r3, [r7, #4]
 322 01a4 5A62     		str	r2, [r3, #36]
  66:../Sources/ADC.c **** 
  67:../Sources/ADC.c **** 	return (0);
 323              		.loc 1 67 0
 324 01a6 0023     		mov	r3, #0
 325              	.L4:
  68:../Sources/ADC.c **** }
 326              		.loc 1 68 0
 327 01a8 181C     		mov	r0, r3
 328 01aa BD46     		mov	sp, r7
 329 01ac 04B0     		add	sp, sp, #16
 330              		@ sp needed for prologue
 331 01ae 80BD     		pop	{r7, pc}
 332              	.L6:
 333              		.align	2
 334              	.L5:
 335 01b0 0080FFFF 		.word	-32768
 336              		.cfi_endproc
 337              	.LFE0:
 339              		.section	.text.ADC_Config_Alt,"ax",%progbits
 340              		.align	2
 341              		.global	ADC_Config_Alt
 342              		.code	16
 343              		.thumb_func
 345              	ADC_Config_Alt:
 346              	.LFB1:
  69:../Sources/ADC.c **** 
  70:../Sources/ADC.c **** /******************************************************************************
  71:../Sources/ADC.c ****  Function 2 Name 	ADC_Config_Alt 
  72:../Sources/ADC.c ****  Parameters		the register values to be set in the adc in a structure
  73:../Sources/ADC.c ****  Returns			NONE
  74:../Sources/ADC.c ****  Notes         		Configures ADC0 or ADC1 depending on adcmap
  75:../Sources/ADC.c ****  Prior to calling this function populate the structure
  76:../Sources/ADC.c ****  elements with the desired ADC configuration.
  77:../Sources/ADC.c ****  ******************************************************************************/
  78:../Sources/ADC.c **** 
  79:../Sources/ADC.c **** void ADC_Config_Alt(ADC_MemMapPtr adcmap, tADC_ConfigPtr ADC_CfgPtr)
  80:../Sources/ADC.c **** {
 347              		.loc 1 80 0
 348              		.cfi_startproc
 349 0000 80B5     		push	{r7, lr}
 350              	.LCFI3:
 351              		.cfi_def_cfa_offset 8
 352              		.cfi_offset 7, -8
 353              		.cfi_offset 14, -4
 354 0002 82B0     		sub	sp, sp, #8
 355              	.LCFI4:
 356              		.cfi_def_cfa_offset 16
 357 0004 00AF     		add	r7, sp, #0
 358              	.LCFI5:
 359              		.cfi_def_cfa_register 7
 360 0006 7860     		str	r0, [r7, #4]
 361 0008 3960     		str	r1, [r7]
  81:../Sources/ADC.c **** 	ADC_CFG1_REG(adcmap) = ADC_CfgPtr->CONFIG1;
 362              		.loc 1 81 0
 363 000a 3B68     		ldr	r3, [r7]
 364 000c 1B78     		ldrb	r3, [r3]
 365 000e 1A1C     		mov	r2, r3
 366 0010 7B68     		ldr	r3, [r7, #4]
 367 0012 9A60     		str	r2, [r3, #8]
  82:../Sources/ADC.c **** 	ADC_CFG2_REG(adcmap) = ADC_CfgPtr->CONFIG2;
 368              		.loc 1 82 0
 369 0014 3B68     		ldr	r3, [r7]
 370 0016 5B78     		ldrb	r3, [r3, #1]
 371 0018 1A1C     		mov	r2, r3
 372 001a 7B68     		ldr	r3, [r7, #4]
 373 001c DA60     		str	r2, [r3, #12]
  83:../Sources/ADC.c **** 	ADC_CV1_REG(adcmap) = ADC_CfgPtr->COMPARE1;
 374              		.loc 1 83 0
 375 001e 3B68     		ldr	r3, [r7]
 376 0020 5B88     		ldrh	r3, [r3, #2]
 377 0022 1A1C     		mov	r2, r3
 378 0024 7B68     		ldr	r3, [r7, #4]
 379 0026 9A61     		str	r2, [r3, #24]
  84:../Sources/ADC.c **** 	ADC_CV2_REG(adcmap) = ADC_CfgPtr->COMPARE2;
 380              		.loc 1 84 0
 381 0028 3B68     		ldr	r3, [r7]
 382 002a 9B88     		ldrh	r3, [r3, #4]
 383 002c 1A1C     		mov	r2, r3
 384 002e 7B68     		ldr	r3, [r7, #4]
 385 0030 DA61     		str	r2, [r3, #28]
  85:../Sources/ADC.c **** 	ADC_SC2_REG(adcmap) = ADC_CfgPtr->STATUS2;
 386              		.loc 1 85 0
 387 0032 3B68     		ldr	r3, [r7]
 388 0034 9B79     		ldrb	r3, [r3, #6]
 389 0036 1A1C     		mov	r2, r3
 390 0038 7B68     		ldr	r3, [r7, #4]
 391 003a 1A62     		str	r2, [r3, #32]
  86:../Sources/ADC.c **** 	ADC_SC3_REG(adcmap) = ADC_CfgPtr->STATUS3;
 392              		.loc 1 86 0
 393 003c 3B68     		ldr	r3, [r7]
 394 003e DB79     		ldrb	r3, [r3, #7]
 395 0040 1A1C     		mov	r2, r3
 396 0042 7B68     		ldr	r3, [r7, #4]
 397 0044 5A62     		str	r2, [r3, #36]
  87:../Sources/ADC.c **** 	//ADC_PGA_REG(adcmap)  = ADC_CfgPtr->PGA;
  88:../Sources/ADC.c **** 	ADC_SC1_REG(adcmap,A)= ADC_CfgPtr->STATUS1A;
 398              		.loc 1 88 0
 399 0046 3B68     		ldr	r3, [r7]
 400 0048 1B7A     		ldrb	r3, [r3, #8]
 401 004a 1A1C     		mov	r2, r3
 402 004c 7B68     		ldr	r3, [r7, #4]
 403 004e 1A60     		str	r2, [r3]
  89:../Sources/ADC.c **** 	ADC_SC1_REG(adcmap,B)= ADC_CfgPtr->STATUS1B;
 404              		.loc 1 89 0
 405 0050 3B68     		ldr	r3, [r7]
 406 0052 5B7A     		ldrb	r3, [r3, #9]
 407 0054 1A1C     		mov	r2, r3
 408 0056 7B68     		ldr	r3, [r7, #4]
 409 0058 5A60     		str	r2, [r3, #4]
  90:../Sources/ADC.c **** }
 410              		.loc 1 90 0
 411 005a BD46     		mov	sp, r7
 412 005c 02B0     		add	sp, sp, #8
 413              		@ sp needed for prologue
 414 005e 80BD     		pop	{r7, pc}
 415              		.cfi_endproc
 416              	.LFE1:
 418              		.section	.text.ADC_Read_Cal,"ax",%progbits
 419              		.align	2
 420              		.global	ADC_Read_Cal
 421              		.code	16
 422              		.thumb_func
 424              	ADC_Read_Cal:
 425              	.LFB2:
  91:../Sources/ADC.c **** 
  92:../Sources/ADC.c **** void ADC_Read_Cal(ADC_MemMapPtr adcmap, tADC_Cal_Blk *blk)
  93:../Sources/ADC.c **** {
 426              		.loc 1 93 0
 427              		.cfi_startproc
 428 0000 80B5     		push	{r7, lr}
 429              	.LCFI6:
 430              		.cfi_def_cfa_offset 8
 431              		.cfi_offset 7, -8
 432              		.cfi_offset 14, -4
 433 0002 82B0     		sub	sp, sp, #8
 434              	.LCFI7:
 435              		.cfi_def_cfa_offset 16
 436 0004 00AF     		add	r7, sp, #0
 437              	.LCFI8:
 438              		.cfi_def_cfa_register 7
 439 0006 7860     		str	r0, [r7, #4]
 440 0008 3960     		str	r1, [r7]
  94:../Sources/ADC.c **** 	blk->OFS = ADC_OFS_REG(adcmap);
 441              		.loc 1 94 0
 442 000a 7B68     		ldr	r3, [r7, #4]
 443 000c 9B6A     		ldr	r3, [r3, #40]
 444 000e 9AB2     		uxth	r2, r3
 445 0010 3B68     		ldr	r3, [r7]
 446 0012 1A80     		strh	r2, [r3]
  95:../Sources/ADC.c **** 	blk->PG = ADC_PG_REG(adcmap);
 447              		.loc 1 95 0
 448 0014 7B68     		ldr	r3, [r7, #4]
 449 0016 DB6A     		ldr	r3, [r3, #44]
 450 0018 9AB2     		uxth	r2, r3
 451 001a 3B68     		ldr	r3, [r7]
 452 001c 5A80     		strh	r2, [r3, #2]
  96:../Sources/ADC.c **** 	blk->MG = ADC_MG_REG(adcmap);
 453              		.loc 1 96 0
 454 001e 7B68     		ldr	r3, [r7, #4]
 455 0020 1B6B     		ldr	r3, [r3, #48]
 456 0022 9AB2     		uxth	r2, r3
 457 0024 3B68     		ldr	r3, [r7]
 458 0026 9A80     		strh	r2, [r3, #4]
  97:../Sources/ADC.c **** 	blk->CLPD = ADC_CLPD_REG(adcmap);
 459              		.loc 1 97 0
 460 0028 7B68     		ldr	r3, [r7, #4]
 461 002a 5B6B     		ldr	r3, [r3, #52]
 462 002c DAB2     		uxtb	r2, r3
 463 002e 3B68     		ldr	r3, [r7]
 464 0030 9A71     		strb	r2, [r3, #6]
  98:../Sources/ADC.c **** 	blk->CLPS = ADC_CLPS_REG(adcmap);
 465              		.loc 1 98 0
 466 0032 7B68     		ldr	r3, [r7, #4]
 467 0034 9B6B     		ldr	r3, [r3, #56]
 468 0036 DAB2     		uxtb	r2, r3
 469 0038 3B68     		ldr	r3, [r7]
 470 003a DA71     		strb	r2, [r3, #7]
  99:../Sources/ADC.c **** 	blk->CLP4 = ADC_CLP4_REG(adcmap);
 471              		.loc 1 99 0
 472 003c 7B68     		ldr	r3, [r7, #4]
 473 003e DB6B     		ldr	r3, [r3, #60]
 474 0040 9AB2     		uxth	r2, r3
 475 0042 3B68     		ldr	r3, [r7]
 476 0044 1A81     		strh	r2, [r3, #8]
 100:../Sources/ADC.c **** 	blk->CLP3 = ADC_CLP3_REG(adcmap);
 477              		.loc 1 100 0
 478 0046 7B68     		ldr	r3, [r7, #4]
 479 0048 1B6C     		ldr	r3, [r3, #64]
 480 004a 9AB2     		uxth	r2, r3
 481 004c 3B68     		ldr	r3, [r7]
 482 004e 5A81     		strh	r2, [r3, #10]
 101:../Sources/ADC.c **** 	blk->CLP2 = ADC_CLP2_REG(adcmap);
 483              		.loc 1 101 0
 484 0050 7B68     		ldr	r3, [r7, #4]
 485 0052 5B6C     		ldr	r3, [r3, #68]
 486 0054 DAB2     		uxtb	r2, r3
 487 0056 3B68     		ldr	r3, [r7]
 488 0058 1A73     		strb	r2, [r3, #12]
 102:../Sources/ADC.c **** 	blk->CLP1 = ADC_CLP1_REG(adcmap);
 489              		.loc 1 102 0
 490 005a 7B68     		ldr	r3, [r7, #4]
 491 005c 9B6C     		ldr	r3, [r3, #72]
 492 005e DAB2     		uxtb	r2, r3
 493 0060 3B68     		ldr	r3, [r7]
 494 0062 5A73     		strb	r2, [r3, #13]
 103:../Sources/ADC.c **** 	blk->CLP0 = ADC_CLP0_REG(adcmap);
 495              		.loc 1 103 0
 496 0064 7B68     		ldr	r3, [r7, #4]
 497 0066 DB6C     		ldr	r3, [r3, #76]
 498 0068 DAB2     		uxtb	r2, r3
 499 006a 3B68     		ldr	r3, [r7]
 500 006c 9A73     		strb	r2, [r3, #14]
 104:../Sources/ADC.c **** 	blk->CLMD = ADC_CLMD_REG(adcmap);
 501              		.loc 1 104 0
 502 006e 7B68     		ldr	r3, [r7, #4]
 503 0070 5B6D     		ldr	r3, [r3, #84]
 504 0072 DAB2     		uxtb	r2, r3
 505 0074 3B68     		ldr	r3, [r7]
 506 0076 1A74     		strb	r2, [r3, #16]
 105:../Sources/ADC.c **** 	blk->CLMS = ADC_CLMS_REG(adcmap);
 507              		.loc 1 105 0
 508 0078 7B68     		ldr	r3, [r7, #4]
 509 007a 9B6D     		ldr	r3, [r3, #88]
 510 007c DAB2     		uxtb	r2, r3
 511 007e 3B68     		ldr	r3, [r7]
 512 0080 5A74     		strb	r2, [r3, #17]
 106:../Sources/ADC.c **** 	blk->CLM4 = ADC_CLM4_REG(adcmap);
 513              		.loc 1 106 0
 514 0082 7B68     		ldr	r3, [r7, #4]
 515 0084 DB6D     		ldr	r3, [r3, #92]
 516 0086 9AB2     		uxth	r2, r3
 517 0088 3B68     		ldr	r3, [r7]
 518 008a 5A82     		strh	r2, [r3, #18]
 107:../Sources/ADC.c **** 	blk->CLM3 = ADC_CLM3_REG(adcmap);
 519              		.loc 1 107 0
 520 008c 7B68     		ldr	r3, [r7, #4]
 521 008e 1B6E     		ldr	r3, [r3, #96]
 522 0090 9AB2     		uxth	r2, r3
 523 0092 3B68     		ldr	r3, [r7]
 524 0094 9A82     		strh	r2, [r3, #20]
 108:../Sources/ADC.c **** 	blk->CLM2 = ADC_CLM2_REG(adcmap);
 525              		.loc 1 108 0
 526 0096 7B68     		ldr	r3, [r7, #4]
 527 0098 5B6E     		ldr	r3, [r3, #100]
 528 009a DAB2     		uxtb	r2, r3
 529 009c 3B68     		ldr	r3, [r7]
 530 009e 9A75     		strb	r2, [r3, #22]
 109:../Sources/ADC.c **** 	blk->CLM1 = ADC_CLM1_REG(adcmap);
 531              		.loc 1 109 0
 532 00a0 7B68     		ldr	r3, [r7, #4]
 533 00a2 9B6E     		ldr	r3, [r3, #104]
 534 00a4 DAB2     		uxtb	r2, r3
 535 00a6 3B68     		ldr	r3, [r7]
 536 00a8 DA75     		strb	r2, [r3, #23]
 110:../Sources/ADC.c **** 	blk->CLM0 = ADC_CLM0_REG(adcmap);
 537              		.loc 1 110 0
 538 00aa 7B68     		ldr	r3, [r7, #4]
 539 00ac DB6E     		ldr	r3, [r3, #108]
 540 00ae DAB2     		uxtb	r2, r3
 541 00b0 3B68     		ldr	r3, [r7]
 542 00b2 1A76     		strb	r2, [r3, #24]
 111:../Sources/ADC.c **** 
 112:../Sources/ADC.c **** }
 543              		.loc 1 112 0
 544 00b4 BD46     		mov	sp, r7
 545 00b6 02B0     		add	sp, sp, #8
 546              		@ sp needed for prologue
 547 00b8 80BD     		pop	{r7, pc}
 548              		.cfi_endproc
 549              	.LFE2:
 551 00ba C046     		.section	.text.InitADC0,"ax",%progbits
 552              		.align	2
 553              		.global	InitADC0
 554              		.code	16
 555              		.thumb_func
 557              	InitADC0:
 558              	.LFB3:
 113:../Sources/ADC.c **** 
 114:../Sources/ADC.c **** void InitADC0()
 115:../Sources/ADC.c **** {
 559              		.loc 1 115 0
 560              		.cfi_startproc
 561 0000 80B5     		push	{r7, lr}
 562              	.LCFI9:
 563              		.cfi_def_cfa_offset 8
 564              		.cfi_offset 7, -8
 565              		.cfi_offset 14, -4
 566 0002 84B0     		sub	sp, sp, #16
 567              	.LCFI10:
 568              		.cfi_def_cfa_offset 24
 569 0004 00AF     		add	r7, sp, #0
 570              	.LCFI11:
 571              		.cfi_def_cfa_register 7
 116:../Sources/ADC.c **** 	tADC_Config Master_Adc0_Config;
 117:../Sources/ADC.c **** 
 118:../Sources/ADC.c **** 	SIM_SCGC6 |= (SIM_SCGC6_ADC0_MASK);
 572              		.loc 1 118 0
 573 0006 1F4A     		ldr	r2, .L10
 574 0008 1E49     		ldr	r1, .L10
 575 000a 1F4B     		ldr	r3, .L10+4
 576 000c CB58     		ldr	r3, [r1, r3]
 577 000e 8021     		mov	r1, #128
 578 0010 0905     		lsl	r1, r1, #20
 579 0012 1943     		orr	r1, r3
 580 0014 1C4B     		ldr	r3, .L10+4
 581 0016 D150     		str	r1, [r2, r3]
 119:../Sources/ADC.c **** 
 120:../Sources/ADC.c **** 	//Lets calibrate the ADC. 1st setup how the channel will be used.
 121:../Sources/ADC.c **** 
 122:../Sources/ADC.c **** 	disable_irq(INT_ADC0 - 16);
 582              		.loc 1 122 0
 583 0018 0F20     		mov	r0, #15
 584 001a FFF7FEFF 		bl	disable_irq
 123:../Sources/ADC.c **** 
 124:../Sources/ADC.c **** 	Master_Adc0_Config.CONFIG1 = ADLPC_NORMAL 			//No low power mode
 585              		.loc 1 124 0
 586 001e 3B1C     		mov	r3, r7
 587 0020 5422     		mov	r2, #84
 588 0022 1A70     		strb	r2, [r3]
 125:../Sources/ADC.c **** 	| ADC_CFG1_ADIV(ADIV_4) //divide input by 4
 126:../Sources/ADC.c **** 			| ADLSMP_LONG 			//long sample time
 127:../Sources/ADC.c **** 			| ADC_CFG1_MODE(MODE_12) 			//single ended 8-bit conversion
 128:../Sources/ADC.c **** 			| ADC_CFG1_ADICLK(ADICLK_BUS);
 129:../Sources/ADC.c **** 
 130:../Sources/ADC.c **** 	Master_Adc0_Config.CONFIG2 = MUXSEL_ADCA // select the A side of the ADC channel.
 589              		.loc 1 130 0
 590 0024 3B1C     		mov	r3, r7
 591 0026 0722     		mov	r2, #7
 592 0028 5A70     		strb	r2, [r3, #1]
 131:../Sources/ADC.c **** 	| ADACKEN_DISABLED | ADHSC_HISPEED | ADC_CFG2_ADLSTS(ADLSTS_2); //Extra long sample Time (20 extra
 132:../Sources/ADC.c **** 
 133:../Sources/ADC.c **** 	Master_Adc0_Config.COMPARE1 = 00000; // Comparators don't matter for calibration
 593              		.loc 1 133 0
 594 002a 3B1C     		mov	r3, r7
 595 002c 0022     		mov	r2, #0
 596 002e 5A80     		strh	r2, [r3, #2]
 134:../Sources/ADC.c **** 	Master_Adc0_Config.COMPARE1 = 0xFFFF;
 597              		.loc 1 134 0
 598 0030 3B1C     		mov	r3, r7
 599 0032 0122     		mov	r2, #1
 600 0034 5242     		neg	r2, r2
 601 0036 5A80     		strh	r2, [r3, #2]
 135:../Sources/ADC.c **** 
 136:../Sources/ADC.c **** 	Master_Adc0_Config.STATUS2 = ADTRG_HW //hardware triggers for calibration
 602              		.loc 1 136 0
 603 0038 3B1C     		mov	r3, r7
 604 003a 5822     		mov	r2, #88
 605 003c 9A71     		strb	r2, [r3, #6]
 137:../Sources/ADC.c **** 	| ACFE_DISABLED //disable comparator
 138:../Sources/ADC.c **** 			| ACFGT_GREATER | ACREN_ENABLED | DMAEN_DISABLED //Disable DMA
 139:../Sources/ADC.c **** 			| ADC_SC2_REFSEL(REFSEL_EXT); //External Reference
 140:../Sources/ADC.c **** 
 141:../Sources/ADC.c **** 	Master_Adc0_Config.STATUS3 = CAL_OFF | ADCO_SINGLE | AVGE_ENABLED
 606              		.loc 1 141 0
 607 003e 3B1C     		mov	r3, r7
 608 0040 0422     		mov	r2, #4
 609 0042 DA71     		strb	r2, [r3, #7]
 142:../Sources/ADC.c **** 			| ADC_SC3_AVGS(AVGS_4);
 143:../Sources/ADC.c **** 
 144:../Sources/ADC.c **** 	Master_Adc0_Config.PGA = 0; // Disable the PGA
 610              		.loc 1 144 0
 611 0044 3B1C     		mov	r3, r7
 612 0046 0022     		mov	r2, #0
 613 0048 DA60     		str	r2, [r3, #12]
 145:../Sources/ADC.c **** 
 146:../Sources/ADC.c **** 	// Configure ADC as it will be used, but because ADC_SC1_ADCH is 31,
 147:../Sources/ADC.c **** 	// the ADC will be inactive.  Channel 31 is just disable function.
 148:../Sources/ADC.c **** 	// There really is no channel 31.
 149:../Sources/ADC.c **** 
 150:../Sources/ADC.c **** 	Master_Adc0_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(31);
 614              		.loc 1 150 0
 615 004a 3B1C     		mov	r3, r7
 616 004c 5F22     		mov	r2, #95
 617 004e 1A72     		strb	r2, [r3, #8]
 151:../Sources/ADC.c **** 
 152:../Sources/ADC.c **** 	ADC_Config_Alt(ADC0_BASE_PTR, &Master_Adc0_Config);  // config ADC
 618              		.loc 1 152 0
 619 0050 0E4A     		ldr	r2, .L10+8
 620 0052 3B1C     		mov	r3, r7
 621 0054 101C     		mov	r0, r2
 622 0056 191C     		mov	r1, r3
 623 0058 FFF7FEFF 		bl	ADC_Config_Alt
 153:../Sources/ADC.c **** 
 154:../Sources/ADC.c **** 	// Calibrate the ADC in the configuration in which it will be used:
 155:../Sources/ADC.c **** 	ADC_Cal(ADC0_BASE_PTR );                    // do the calibration
 624              		.loc 1 155 0
 625 005c 0B4B     		ldr	r3, .L10+8
 626 005e 181C     		mov	r0, r3
 627 0060 FFF7FEFF 		bl	ADC_Cal
 156:../Sources/ADC.c **** 
 157:../Sources/ADC.c **** 	Master_Adc0_Config.STATUS2 = ACFE_DISABLED //disable comparator
 628              		.loc 1 157 0
 629 0064 3B1C     		mov	r3, r7
 630 0066 1822     		mov	r2, #24
 631 0068 9A71     		strb	r2, [r3, #6]
 158:../Sources/ADC.c **** 	| ACFGT_GREATER | ACREN_ENABLED | DMAEN_DISABLED //Disable DMA
 159:../Sources/ADC.c **** 			| ADC_SC2_REFSEL(REFSEL_EXT); //External Reference
 160:../Sources/ADC.c **** 
 161:../Sources/ADC.c **** 	Master_Adc0_Config.STATUS3 = CAL_OFF | ADCO_SINGLE;
 632              		.loc 1 161 0
 633 006a 3B1C     		mov	r3, r7
 634 006c 0022     		mov	r2, #0
 635 006e DA71     		strb	r2, [r3, #7]
 162:../Sources/ADC.c **** 
 163:../Sources/ADC.c **** 	ADC_Config_Alt(ADC0_BASE_PTR, &Master_Adc0_Config);
 636              		.loc 1 163 0
 637 0070 064A     		ldr	r2, .L10+8
 638 0072 3B1C     		mov	r3, r7
 639 0074 101C     		mov	r0, r2
 640 0076 191C     		mov	r1, r3
 641 0078 FFF7FEFF 		bl	ADC_Config_Alt
 164:../Sources/ADC.c **** }
 642              		.loc 1 164 0
 643 007c BD46     		mov	sp, r7
 644 007e 04B0     		add	sp, sp, #16
 645              		@ sp needed for prologue
 646 0080 80BD     		pop	{r7, pc}
 647              	.L11:
 648 0082 C046     		.align	2
 649              	.L10:
 650 0084 00700440 		.word	1074032640
 651 0088 3C100000 		.word	4156
 652 008c 00B00340 		.word	1073983488
 653              		.cfi_endproc
 654              	.LFE3:
 656              		.section	.text.InitADCs,"ax",%progbits
 657              		.align	2
 658              		.global	InitADCs
 659              		.code	16
 660              		.thumb_func
 662              	InitADCs:
 663              	.LFB4:
 165:../Sources/ADC.c **** 
 166:../Sources/ADC.c **** void InitADCs()
 167:../Sources/ADC.c **** {
 664              		.loc 1 167 0
 665              		.cfi_startproc
 666 0000 80B5     		push	{r7, lr}
 667              	.LCFI12:
 668              		.cfi_def_cfa_offset 8
 669              		.cfi_offset 7, -8
 670              		.cfi_offset 14, -4
 671 0002 00AF     		add	r7, sp, #0
 672              	.LCFI13:
 673              		.cfi_def_cfa_register 7
 168:../Sources/ADC.c **** 
 169:../Sources/ADC.c **** 	InitADC0();
 674              		.loc 1 169 0
 675 0004 FFF7FEFF 		bl	InitADC0
 170:../Sources/ADC.c **** 
 171:../Sources/ADC.c **** 	//All Adc processing of the linescan will be done in the ADC0 IRQ!
 172:../Sources/ADC.c **** 	//A state machine will scan through the channels. More can be added if needed.
 173:../Sources/ADC.c **** 	//This is done to automate the linescan capture on Channel 0 to ensure that timing is very even
 174:../Sources/ADC.c **** 	CurrentADC_State = ADC_STATE_INIT;
 676              		.loc 1 174 0
 677 0008 144B     		ldr	r3, .L13
 678 000a 0022     		mov	r2, #0
 679 000c 1A70     		strb	r2, [r3]
 175:../Sources/ADC.c **** 
 176:../Sources/ADC.c **** 	//The pump will be primed with the PIT interrupt.  upon timeout/interrupt it will set the SI signa
 177:../Sources/ADC.c **** 	//for the camera and then start reading.
 178:../Sources/ADC.c **** 
 179:../Sources/ADC.c **** 	//Enable clock to the PIT
 180:../Sources/ADC.c **** 	SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
 680              		.loc 1 180 0
 681 000e 144A     		ldr	r2, .L13+4
 682 0010 1349     		ldr	r1, .L13+4
 683 0012 144B     		ldr	r3, .L13+8
 684 0014 CB58     		ldr	r3, [r1, r3]
 685 0016 8021     		mov	r1, #128
 686 0018 0904     		lsl	r1, r1, #16
 687 001a 1943     		orr	r1, r3
 688 001c 114B     		ldr	r3, .L13+8
 689 001e D150     		str	r1, [r2, r3]
 181:../Sources/ADC.c **** 
 182:../Sources/ADC.c **** 	//We will use PIT0
 183:../Sources/ADC.c **** 	SetLineScanExposureTime(DEFAULT_LINESCAN_EXPOSURE_TIME_uS);
 690              		.loc 1 183 0
 691 0020 114B     		ldr	r3, .L13+12
 692 0022 181C     		mov	r0, r3
 693 0024 FFF7FEFF 		bl	SetLineScanExposureTime
 184:../Sources/ADC.c **** 	//enable PIT0 and its interrupt
 185:../Sources/ADC.c **** 	PIT_TCTRL0 = PIT_TCTRL_TEN_MASK | PIT_TCTRL_TIE_MASK;
 694              		.loc 1 185 0
 695 0028 104A     		ldr	r2, .L13+16
 696 002a 8423     		mov	r3, #132
 697 002c 5B00     		lsl	r3, r3, #1
 698 002e 0321     		mov	r1, #3
 699 0030 D150     		str	r1, [r2, r3]
 186:../Sources/ADC.c **** 
 187:../Sources/ADC.c **** 	PIT_MCR |= PIT_MCR_FRZ_MASK; // stop the pit when in debug mode
 700              		.loc 1 187 0
 701 0032 0E4B     		ldr	r3, .L13+16
 702 0034 0D4A     		ldr	r2, .L13+16
 703 0036 1268     		ldr	r2, [r2]
 704 0038 0121     		mov	r1, #1
 705 003a 0A43     		orr	r2, r1
 706 003c 1A60     		str	r2, [r3]
 188:../Sources/ADC.c **** 	//Enable the PIT module
 189:../Sources/ADC.c **** 	PIT_MCR &= ~PIT_MCR_MDIS_MASK;
 707              		.loc 1 189 0
 708 003e 0B4B     		ldr	r3, .L13+16
 709 0040 0A4A     		ldr	r2, .L13+16
 710 0042 1268     		ldr	r2, [r2]
 711 0044 0221     		mov	r1, #2
 712 0046 8A43     		bic	r2, r1
 713 0048 1A60     		str	r2, [r3]
 190:../Sources/ADC.c **** 
 191:../Sources/ADC.c **** 	enable_irq(INT_PIT - 16);
 714              		.loc 1 191 0
 715 004a 1620     		mov	r0, #22
 716 004c FFF7FEFF 		bl	enable_irq
 192:../Sources/ADC.c **** 	enable_irq(INT_ADC0 - 16);
 717              		.loc 1 192 0
 718 0050 0F20     		mov	r0, #15
 719 0052 FFF7FEFF 		bl	enable_irq
 193:../Sources/ADC.c **** }
 720              		.loc 1 193 0
 721 0056 BD46     		mov	sp, r7
 722              		@ sp needed for prologue
 723 0058 80BD     		pop	{r7, pc}
 724              	.L14:
 725 005a C046     		.align	2
 726              	.L13:
 727 005c 00000000 		.word	CurrentADC_State
 728 0060 00700440 		.word	1074032640
 729 0064 3C100000 		.word	4156
 730 0068 10270000 		.word	10000
 731 006c 00700340 		.word	1073967104
 732              		.cfi_endproc
 733              	.LFE4:
 735              		.section	.text.PIT_IRQHandler,"ax",%progbits
 736              		.align	2
 737              		.global	PIT_IRQHandler
 738              		.code	16
 739              		.thumb_func
 741              	PIT_IRQHandler:
 742              	.LFB5:
 194:../Sources/ADC.c **** 
 195:../Sources/ADC.c **** void PIT_IRQHandler()
 196:../Sources/ADC.c **** {
 743              		.loc 1 196 0
 744              		.cfi_startproc
 745 0000 80B5     		push	{r7, lr}
 746              	.LCFI14:
 747              		.cfi_def_cfa_offset 8
 748              		.cfi_offset 7, -8
 749              		.cfi_offset 14, -4
 750 0002 00AF     		add	r7, sp, #0
 751              	.LCFI15:
 752              		.cfi_def_cfa_register 7
 197:../Sources/ADC.c **** 	PIT_TFLG0 = PIT_TFLG_TIF_MASK; //Turn off the Pit 0 Irq flag 
 753              		.loc 1 197 0
 754 0004 094A     		ldr	r2, .L16
 755 0006 8623     		mov	r3, #134
 756 0008 5B00     		lsl	r3, r3, #1
 757 000a 0121     		mov	r1, #1
 758 000c D150     		str	r1, [r2, r3]
 198:../Sources/ADC.c **** 	CurrentADC_State = ADC_STATE_CAPTURE_BATTERY_LEVEL;
 759              		.loc 1 198 0
 760 000e 084B     		ldr	r3, .L16+4
 761 0010 0322     		mov	r2, #3
 762 0012 1A70     		strb	r2, [r3]
 199:../Sources/ADC.c **** 	ADC0_CFG2  |= ADC_CFG2_MUXSEL_MASK; //Select the B side of the mux
 763              		.loc 1 199 0
 764 0014 074B     		ldr	r3, .L16+8
 765 0016 074A     		ldr	r2, .L16+8
 766 0018 D268     		ldr	r2, [r2, #12]
 767 001a 1021     		mov	r1, #16
 768 001c 0A43     		orr	r2, r1
 769 001e DA60     		str	r2, [r3, #12]
 200:../Sources/ADC.c **** 	ADC0_SC1A  =  BAT_SENSE_CHANNEL| ADC_SC1_AIEN_MASK;
 770              		.loc 1 200 0
 771 0020 044B     		ldr	r3, .L16+8
 772 0022 4422     		mov	r2, #68
 773 0024 1A60     		str	r2, [r3]
 201:../Sources/ADC.c **** 
 202:../Sources/ADC.c **** 
 203:../Sources/ADC.c **** }
 774              		.loc 1 203 0
 775 0026 BD46     		mov	sp, r7
 776              		@ sp needed for prologue
 777 0028 80BD     		pop	{r7, pc}
 778              	.L17:
 779 002a C046     		.align	2
 780              	.L16:
 781 002c 00700340 		.word	1073967104
 782 0030 00000000 		.word	CurrentADC_State
 783 0034 00B00340 		.word	1073983488
 784              		.cfi_endproc
 785              	.LFE5:
 787              		.section	.text.ADC0_IRQHandler,"ax",%progbits
 788              		.align	2
 789              		.global	ADC0_IRQHandler
 790              		.code	16
 791              		.thumb_func
 793              	ADC0_IRQHandler:
 794              	.LFB6:
 204:../Sources/ADC.c **** 
 205:../Sources/ADC.c **** void ADC0_IRQHandler()
 206:../Sources/ADC.c **** {
 795              		.loc 1 206 0
 796              		.cfi_startproc
 797 0000 80B5     		push	{r7, lr}
 798              	.LCFI16:
 799              		.cfi_def_cfa_offset 8
 800              		.cfi_offset 7, -8
 801              		.cfi_offset 14, -4
 802 0002 82B0     		sub	sp, sp, #8
 803              	.LCFI17:
 804              		.cfi_def_cfa_offset 16
 805 0004 00AF     		add	r7, sp, #0
 806              	.LCFI18:
 807              		.cfi_def_cfa_register 7
 207:../Sources/ADC.c **** 	uint8_t Junk;
 208:../Sources/ADC.c **** 	switch (CurrentADC_State)
 808              		.loc 1 208 0
 809 0006 4F4B     		ldr	r3, .L34
 810 0008 1B78     		ldrb	r3, [r3]
 811 000a 032B     		cmp	r3, #3
 812 000c 06D0     		beq	.L20
 813 000e 042B     		cmp	r3, #4
 814 0010 2FD0     		beq	.L21
 209:../Sources/ADC.c **** 	//choose state for current ADC operation
 210:../Sources/ADC.c **** 	{
 211:../Sources/ADC.c **** 	default:
 212:../Sources/ADC.c **** 		Junk = ADC0_RA ;
 815              		.loc 1 212 0
 816 0012 4D4B     		ldr	r3, .L34+4
 817 0014 1A69     		ldr	r2, [r3, #16]
 818 0016 FB1D     		add	r3, r7, #7
 819 0018 1A70     		strb	r2, [r3]
 213:../Sources/ADC.c **** 		break;
 820              		.loc 1 213 0
 821 001a 8FE0     		b	.L18
 822              	.L20:
 214:../Sources/ADC.c **** 		
 215:../Sources/ADC.c **** 		case ADC_STATE_CAPTURE_BATTERY_LEVEL:
 216:../Sources/ADC.c **** 			
 217:../Sources/ADC.c **** 			BatSenseADC_Value = ADC0_RA;
 823              		.loc 1 217 0
 824 001c 4A4B     		ldr	r3, .L34+4
 825 001e 1B69     		ldr	r3, [r3, #16]
 826 0020 9AB2     		uxth	r2, r3
 827 0022 4A4B     		ldr	r3, .L34+8
 828 0024 1A80     		strh	r2, [r3]
 218:../Sources/ADC.c **** 			
 219:../Sources/ADC.c **** 			TAOS_SI_HIGH; //set SI high
 829              		.loc 1 219 0
 830 0026 4A4B     		ldr	r3, .L34+12
 831 0028 8022     		mov	r2, #128
 832 002a 5A60     		str	r2, [r3, #4]
 220:../Sources/ADC.c **** 			CurrentADC_State = ADC_STATE_CAPTURE_LINE_SCAN; //line up state machine to linescan next
 833              		.loc 1 220 0
 834 002c 454B     		ldr	r3, .L34
 835 002e 0422     		mov	r2, #4
 836 0030 1A70     		strb	r2, [r3]
 221:../Sources/ADC.c **** 			CurrentLineScanPixel = 0; //start at the leftmost pixel
 837              		.loc 1 221 0
 838 0032 484B     		ldr	r3, .L34+16
 839 0034 0022     		mov	r2, #0
 840 0036 1A70     		strb	r2, [r3]
 222:../Sources/ADC.c **** 			TAOS_CLK_HIGH; //toggle the clock to read first val
 841              		.loc 1 222 0
 842 0038 474B     		ldr	r3, .L34+20
 843 003a 0222     		mov	r2, #2
 844 003c 5A60     		str	r2, [r3, #4]
 223:../Sources/ADC.c **** 
 224:../Sources/ADC.c **** 			for (Junk = 0; Junk < 50; Junk++)
 845              		.loc 1 224 0
 846 003e FB1D     		add	r3, r7, #7
 847 0040 0022     		mov	r2, #0
 848 0042 1A70     		strb	r2, [r3]
 849 0044 04E0     		b	.L23
 850              	.L24:
 851              		.loc 1 224 0 is_stmt 0
 852 0046 FB1D     		add	r3, r7, #7
 853 0048 FA1D     		add	r2, r7, #7
 854 004a 1278     		ldrb	r2, [r2]
 855 004c 0132     		add	r2, r2, #1
 856 004e 1A70     		strb	r2, [r3]
 857              	.L23:
 858              		.loc 1 224 0
 859 0050 FB1D     		add	r3, r7, #7
 860 0052 1B78     		ldrb	r3, [r3]
 861 0054 312B     		cmp	r3, #49
 862 0056 F6D9     		bls	.L24
 225:../Sources/ADC.c **** 				;
 226:../Sources/ADC.c **** 
 227:../Sources/ADC.c **** 			TAOS_SI_LOW;
 863              		.loc 1 227 0 is_stmt 1
 864 0058 3D4B     		ldr	r3, .L34+12
 865 005a 8022     		mov	r2, #128
 866 005c 9A60     		str	r2, [r3, #8]
 228:../Sources/ADC.c **** 
 229:../Sources/ADC.c **** 			ADC0_CFG2 |= ADC_CFG2_MUXSEL_MASK; //Select the B side of the mux
 867              		.loc 1 229 0
 868 005e 3A4B     		ldr	r3, .L34+4
 869 0060 394A     		ldr	r2, .L34+4
 870 0062 D268     		ldr	r2, [r2, #12]
 871 0064 1021     		mov	r1, #16
 872 0066 0A43     		orr	r2, r1
 873 0068 DA60     		str	r2, [r3, #12]
 230:../Sources/ADC.c **** 			ADC0_SC1A  =  LINESCAN0_CHANNEL| ADC_SC1_AIEN_MASK;
 874              		.loc 1 230 0
 875 006a 374B     		ldr	r3, .L34+4
 876 006c 4622     		mov	r2, #70
 877 006e 1A60     		str	r2, [r3]
 231:../Sources/ADC.c **** 			
 232:../Sources/ADC.c **** 		break;
 878              		.loc 1 232 0
 879 0070 64E0     		b	.L18
 880              	.L21:
 233:../Sources/ADC.c **** 			
 234:../Sources/ADC.c **** 			
 235:../Sources/ADC.c **** 		case ADC_STATE_CAPTURE_LINE_SCAN:
 236:../Sources/ADC.c **** 
 237:../Sources/ADC.c **** 		if(CurrentLineScanPixel<128)
 881              		.loc 1 237 0
 882 0072 384B     		ldr	r3, .L34+16
 883 0074 1B78     		ldrb	r3, [r3]
 884 0076 DBB2     		uxtb	r3, r3
 885 0078 DBB2     		uxtb	r3, r3
 886 007a 5BB2     		sxtb	r3, r3
 887 007c 002B     		cmp	r3, #0
 888 007e 2BDB     		blt	.L25
 238:../Sources/ADC.c **** 		{
 239:../Sources/ADC.c **** 			LineScanImageWorkingBuffer[CurrentLineScanPixel] = ADC0_RA; //get a pixel value
 889              		.loc 1 239 0
 890 0080 364B     		ldr	r3, .L34+24
 891 0082 1A68     		ldr	r2, [r3]
 892 0084 334B     		ldr	r3, .L34+16
 893 0086 1B78     		ldrb	r3, [r3]
 894 0088 DBB2     		uxtb	r3, r3
 895 008a 5B00     		lsl	r3, r3, #1
 896 008c D218     		add	r2, r2, r3
 897 008e 2E4B     		ldr	r3, .L34+4
 898 0090 1B69     		ldr	r3, [r3, #16]
 899 0092 9BB2     		uxth	r3, r3
 900 0094 1380     		strh	r3, [r2]
 240:../Sources/ADC.c **** 				ADC0_SC1A |= ADC_SC1_AIEN_MASK;//clear the interrupt flag
 901              		.loc 1 240 0
 902 0096 2C4B     		ldr	r3, .L34+4
 903 0098 2B4A     		ldr	r2, .L34+4
 904 009a 1268     		ldr	r2, [r2]
 905 009c 4021     		mov	r1, #64
 906 009e 0A43     		orr	r2, r1
 907 00a0 1A60     		str	r2, [r3]
 241:../Sources/ADC.c **** 				CurrentLineScanPixel++;//move to next pixel
 908              		.loc 1 241 0
 909 00a2 2C4B     		ldr	r3, .L34+16
 910 00a4 1B78     		ldrb	r3, [r3]
 911 00a6 DBB2     		uxtb	r3, r3
 912 00a8 0133     		add	r3, r3, #1
 913 00aa DAB2     		uxtb	r2, r3
 914 00ac 294B     		ldr	r3, .L34+16
 915 00ae 1A70     		strb	r2, [r3]
 242:../Sources/ADC.c **** 
 243:../Sources/ADC.c **** 				TAOS_CLK_LOW;//cycle the clock to read out the next one
 916              		.loc 1 243 0
 917 00b0 294B     		ldr	r3, .L34+20
 918 00b2 0222     		mov	r2, #2
 919 00b4 9A60     		str	r2, [r3, #8]
 244:../Sources/ADC.c **** 				for(Junk = 0;Junk<50;Junk++)
 920              		.loc 1 244 0
 921 00b6 FB1D     		add	r3, r7, #7
 922 00b8 0022     		mov	r2, #0
 923 00ba 1A70     		strb	r2, [r3]
 924 00bc 04E0     		b	.L26
 925              	.L27:
 926              		.loc 1 244 0 is_stmt 0
 927 00be FB1D     		add	r3, r7, #7
 928 00c0 FA1D     		add	r2, r7, #7
 929 00c2 1278     		ldrb	r2, [r2]
 930 00c4 0132     		add	r2, r2, #1
 931 00c6 1A70     		strb	r2, [r3]
 932              	.L26:
 933              		.loc 1 244 0
 934 00c8 FB1D     		add	r3, r7, #7
 935 00ca 1B78     		ldrb	r3, [r3]
 936 00cc 312B     		cmp	r3, #49
 937 00ce F6D9     		bls	.L27
 245:../Sources/ADC.c **** 				{}
 246:../Sources/ADC.c **** 				TAOS_CLK_HIGH;
 938              		.loc 1 246 0 is_stmt 1
 939 00d0 214B     		ldr	r3, .L34+20
 940 00d2 0222     		mov	r2, #2
 941 00d4 5A60     		str	r2, [r3, #4]
 247:../Sources/ADC.c **** 
 248:../Sources/ADC.c **** 			}
 249:../Sources/ADC.c **** 			else
 250:../Sources/ADC.c **** 			{
 251:../Sources/ADC.c **** 				// done with the capture sequence.  we can wait for the PIT0 IRQ to restart
 252:../Sources/ADC.c **** 
 253:../Sources/ADC.c **** 				TAOS_CLK_HIGH;//cycle the clock to end the sequence
 254:../Sources/ADC.c **** 
 255:../Sources/ADC.c **** 				for(Junk = 0;Junk<50;Junk++)
 256:../Sources/ADC.c **** 				{
 257:../Sources/ADC.c **** 				}
 258:../Sources/ADC.c **** 
 259:../Sources/ADC.c **** 				TAOS_CLK_LOW;
 260:../Sources/ADC.c **** 				CurrentADC_State = ADC_STATE_INIT; //reset the ADC state machine
 261:../Sources/ADC.c **** 
 262:../Sources/ADC.c **** 				//swap the buffer
 263:../Sources/ADC.c **** 
 264:../Sources/ADC.c **** 				if(LineScanWorkingBuffer == 0)//switch the working and reading buffers
 265:../Sources/ADC.c **** 				{
 266:../Sources/ADC.c **** 					LineScanWorkingBuffer = 1;
 267:../Sources/ADC.c **** 					LineScanImageWorkingBuffer = &LineScanImageBuffer[1][0];
 268:../Sources/ADC.c **** 					LineScanImage = &LineScanImageBuffer[0][0];
 269:../Sources/ADC.c **** 				}
 270:../Sources/ADC.c **** 				else
 271:../Sources/ADC.c **** 				{
 272:../Sources/ADC.c **** 					LineScanWorkingBuffer = 0;
 273:../Sources/ADC.c **** 					LineScanImageWorkingBuffer = &LineScanImageBuffer[0][0];
 274:../Sources/ADC.c **** 					LineScanImage = &LineScanImageBuffer[1][0];
 275:../Sources/ADC.c **** 				}
 276:../Sources/ADC.c **** 
 277:../Sources/ADC.c **** 				LineScanImageReady = TRUE; //set flag indicating data is ready
 278:../Sources/ADC.c **** 			}
 279:../Sources/ADC.c **** 
 280:../Sources/ADC.c **** 			break;
 942              		.loc 1 280 0
 943 00d6 30E0     		b	.L33
 944              	.L25:
 253:../Sources/ADC.c **** 				TAOS_CLK_HIGH;//cycle the clock to end the sequence
 945              		.loc 1 253 0
 946 00d8 1F4B     		ldr	r3, .L34+20
 947 00da 0222     		mov	r2, #2
 948 00dc 5A60     		str	r2, [r3, #4]
 255:../Sources/ADC.c **** 				for(Junk = 0;Junk<50;Junk++)
 949              		.loc 1 255 0
 950 00de FB1D     		add	r3, r7, #7
 951 00e0 0022     		mov	r2, #0
 952 00e2 1A70     		strb	r2, [r3]
 953 00e4 04E0     		b	.L29
 954              	.L30:
 255:../Sources/ADC.c **** 				for(Junk = 0;Junk<50;Junk++)
 955              		.loc 1 255 0 is_stmt 0
 956 00e6 FB1D     		add	r3, r7, #7
 957 00e8 FA1D     		add	r2, r7, #7
 958 00ea 1278     		ldrb	r2, [r2]
 959 00ec 0132     		add	r2, r2, #1
 960 00ee 1A70     		strb	r2, [r3]
 961              	.L29:
 255:../Sources/ADC.c **** 				for(Junk = 0;Junk<50;Junk++)
 962              		.loc 1 255 0
 963 00f0 FB1D     		add	r3, r7, #7
 964 00f2 1B78     		ldrb	r3, [r3]
 965 00f4 312B     		cmp	r3, #49
 966 00f6 F6D9     		bls	.L30
 259:../Sources/ADC.c **** 				TAOS_CLK_LOW;
 967              		.loc 1 259 0 is_stmt 1
 968 00f8 174B     		ldr	r3, .L34+20
 969 00fa 0222     		mov	r2, #2
 970 00fc 9A60     		str	r2, [r3, #8]
 260:../Sources/ADC.c **** 				CurrentADC_State = ADC_STATE_INIT; //reset the ADC state machine
 971              		.loc 1 260 0
 972 00fe 114B     		ldr	r3, .L34
 973 0100 0022     		mov	r2, #0
 974 0102 1A70     		strb	r2, [r3]
 264:../Sources/ADC.c **** 				if(LineScanWorkingBuffer == 0)//switch the working and reading buffers
 975              		.loc 1 264 0
 976 0104 164B     		ldr	r3, .L34+28
 977 0106 1B78     		ldrb	r3, [r3]
 978 0108 DBB2     		uxtb	r3, r3
 979 010a 002B     		cmp	r3, #0
 980 010c 09D1     		bne	.L31
 266:../Sources/ADC.c **** 					LineScanWorkingBuffer = 1;
 981              		.loc 1 266 0
 982 010e 144B     		ldr	r3, .L34+28
 983 0110 0122     		mov	r2, #1
 984 0112 1A70     		strb	r2, [r3]
 267:../Sources/ADC.c **** 					LineScanImageWorkingBuffer = &LineScanImageBuffer[1][0];
 985              		.loc 1 267 0
 986 0114 114B     		ldr	r3, .L34+24
 987 0116 134A     		ldr	r2, .L34+32
 988 0118 1A60     		str	r2, [r3]
 268:../Sources/ADC.c **** 					LineScanImage = &LineScanImageBuffer[0][0];
 989              		.loc 1 268 0
 990 011a 134B     		ldr	r3, .L34+36
 991 011c 134A     		ldr	r2, .L34+40
 992 011e 1A60     		str	r2, [r3]
 993 0120 08E0     		b	.L32
 994              	.L31:
 272:../Sources/ADC.c **** 					LineScanWorkingBuffer = 0;
 995              		.loc 1 272 0
 996 0122 0F4B     		ldr	r3, .L34+28
 997 0124 0022     		mov	r2, #0
 998 0126 1A70     		strb	r2, [r3]
 273:../Sources/ADC.c **** 					LineScanImageWorkingBuffer = &LineScanImageBuffer[0][0];
 999              		.loc 1 273 0
 1000 0128 0C4B     		ldr	r3, .L34+24
 1001 012a 104A     		ldr	r2, .L34+40
 1002 012c 1A60     		str	r2, [r3]
 274:../Sources/ADC.c **** 					LineScanImage = &LineScanImageBuffer[1][0];
 1003              		.loc 1 274 0
 1004 012e 0E4B     		ldr	r3, .L34+36
 1005 0130 0C4A     		ldr	r2, .L34+32
 1006 0132 1A60     		str	r2, [r3]
 1007              	.L32:
 277:../Sources/ADC.c **** 				LineScanImageReady = TRUE; //set flag indicating data is ready
 1008              		.loc 1 277 0
 1009 0134 0E4B     		ldr	r3, .L34+44
 1010 0136 0122     		mov	r2, #1
 1011 0138 1A70     		strb	r2, [r3]
 1012              	.L33:
 1013              		.loc 1 280 0
 1014 013a C046     		mov	r8, r8
 1015              	.L18:
 281:../Sources/ADC.c **** 
 282:../Sources/ADC.c **** 		}
 283:../Sources/ADC.c **** 
 284:../Sources/ADC.c **** 	}
 1016              		.loc 1 284 0
 1017 013c BD46     		mov	sp, r7
 1018 013e 02B0     		add	sp, sp, #8
 1019              		@ sp needed for prologue
 1020 0140 80BD     		pop	{r7, pc}
 1021              	.L35:
 1022 0142 C046     		.align	2
 1023              	.L34:
 1024 0144 00000000 		.word	CurrentADC_State
 1025 0148 00B00340 		.word	1073983488
 1026 014c 00000000 		.word	BatSenseADC_Value
 1027 0150 C0F00F40 		.word	1074786496
 1028 0154 00000000 		.word	CurrentLineScanPixel
 1029 0158 00F10F40 		.word	1074786560
 1030 015c 00000000 		.word	LineScanImageWorkingBuffer
 1031 0160 00000000 		.word	LineScanWorkingBuffer
 1032 0164 00010000 		.word	LineScanImageBuffer+256
 1033 0168 00000000 		.word	LineScanImage
 1034 016c 00000000 		.word	LineScanImageBuffer
 1035 0170 00000000 		.word	LineScanImageReady
 1036              		.cfi_endproc
 1037              	.LFE6:
 1039              		.global	__aeabi_ui2f
 1040              		.global	__aeabi_fdiv
 1041              		.global	__aeabi_fmul
 1042              		.section	.text.ReadBatteryVoltage,"ax",%progbits
 1043              		.align	2
 1044              		.global	ReadBatteryVoltage
 1045              		.code	16
 1046              		.thumb_func
 1048              	ReadBatteryVoltage:
 1049              	.LFB7:
 285:../Sources/ADC.c **** 
 286:../Sources/ADC.c **** float ReadBatteryVoltage()
 287:../Sources/ADC.c **** {
 1050              		.loc 1 287 0
 1051              		.cfi_startproc
 1052 0000 80B5     		push	{r7, lr}
 1053              	.LCFI19:
 1054              		.cfi_def_cfa_offset 8
 1055              		.cfi_offset 7, -8
 1056              		.cfi_offset 14, -4
 1057 0002 00AF     		add	r7, sp, #0
 1058              	.LCFI20:
 1059              		.cfi_def_cfa_register 7
 288:../Sources/ADC.c ****     return (((float)BatSenseADC_Value/(float)(ADC_MAX_CODE)) * 3.0);// * ((47000.0+10000.0)/10000.0
 1060              		.loc 1 288 0
 1061 0004 094B     		ldr	r3, .L38
 1062 0006 1B88     		ldrh	r3, [r3]
 1063 0008 9BB2     		uxth	r3, r3
 1064 000a 181C     		mov	r0, r3
 1065 000c FFF7FEFF 		bl	__aeabi_ui2f
 1066 0010 031C     		add	r3, r0, #0
 1067 0012 181C     		add	r0, r3, #0
 1068 0014 0649     		ldr	r1, .L38+4
 1069 0016 FFF7FEFF 		bl	__aeabi_fdiv
 1070 001a 031C     		add	r3, r0, #0
 1071 001c 181C     		add	r0, r3, #0
 1072 001e 0549     		ldr	r1, .L38+8
 1073 0020 FFF7FEFF 		bl	__aeabi_fmul
 1074 0024 031C     		add	r3, r0, #0
 289:../Sources/ADC.c **** }
 1075              		.loc 1 289 0
 1076 0026 181C     		add	r0, r3, #0
 1077 0028 BD46     		mov	sp, r7
 1078              		@ sp needed for prologue
 1079 002a 80BD     		pop	{r7, pc}
 1080              	.L39:
 1081              		.align	2
 1082              	.L38:
 1083 002c 00000000 		.word	BatSenseADC_Value
 1084 0030 00F07F45 		.word	1166012416
 1085 0034 00004040 		.word	1077936128
 1086              		.cfi_endproc
 1087              	.LFE7:
 1089              		.text
 1090              	.Letext0:
 1091              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1092              		.file 3 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/MKL25Z4.h"
 1093              		.file 4 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/ADC.h"
 1094              		.file 5 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/Control.h"
 1095              		.file 6 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/LineScanCamera.h"
 1096              		.file 7 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/PID.h"
 1097              		.file 8 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/Accel.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ADC.c
                            *COM*:00000004 straight_speed
                            *COM*:00000004 medium_speed
                            *COM*:00000004 turn_speed
                            *COM*:00000004 brake_speed
                            *COM*:00000004 speedC
                            *COM*:000000c8 LineScanData
                            *COM*:00001000 histogram
                            *COM*:00000008 kp
                            *COM*:00000008 ki
                            *COM*:00000008 kd
                            *COM*:00000008 lastError
                            *COM*:00000008 llastError
                            *COM*:00000004 lastOutput
                            *COM*:00000006 AccData
                            *COM*:00000002 Xout
                            *COM*:00000002 Yout
                            *COM*:00000002 Zout
                            *COM*:00000001 Xoffset
                            *COM*:00000001 Yoffset
                            *COM*:00000001 Zoffset
                            *COM*:00000004 ramp
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:41     .bss.CurrentADC_State:00000000 CurrentADC_State
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:42     .bss.CurrentADC_State:00000000 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:47     .bss.CurrentLineScanPixel:00000000 CurrentLineScanPixel
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:48     .bss.CurrentLineScanPixel:00000000 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:53     .bss.CurrentLineScanChannel:00000000 CurrentLineScanChannel
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:54     .bss.CurrentLineScanChannel:00000000 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:60     .bss.BatSenseADC_Value:00000000 BatSenseADC_Value
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:57     .bss.BatSenseADC_Value:00000000 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:63     .text.ADC_Cal:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:68     .text.ADC_Cal:00000000 ADC_Cal
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:335    .text.ADC_Cal:000001b0 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:340    .text.ADC_Config_Alt:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:345    .text.ADC_Config_Alt:00000000 ADC_Config_Alt
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:419    .text.ADC_Read_Cal:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:424    .text.ADC_Read_Cal:00000000 ADC_Read_Cal
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:552    .text.InitADC0:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:557    .text.InitADC0:00000000 InitADC0
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:650    .text.InitADC0:00000084 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:657    .text.InitADCs:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:662    .text.InitADCs:00000000 InitADCs
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:727    .text.InitADCs:0000005c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:736    .text.PIT_IRQHandler:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:741    .text.PIT_IRQHandler:00000000 PIT_IRQHandler
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:781    .text.PIT_IRQHandler:0000002c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:788    .text.ADC0_IRQHandler:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:793    .text.ADC0_IRQHandler:00000000 ADC0_IRQHandler
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:1024   .text.ADC0_IRQHandler:00000144 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:1043   .text.ReadBatteryVoltage:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:1048   .text.ReadBatteryVoltage:00000000 ReadBatteryVoltage
C:\Users\BRENTD~1\AppData\Local\Temp\ccPO3ZPO.s:1083   .text.ReadBatteryVoltage:0000002c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
disable_irq
SetLineScanExposureTime
enable_irq
LineScanImageWorkingBuffer
LineScanWorkingBuffer
LineScanImageBuffer
LineScanImage
LineScanImageReady
__aeabi_ui2f
__aeabi_fdiv
__aeabi_fmul
