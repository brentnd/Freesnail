   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"CrystalClock.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.comm	straight_speed,4,4
  18              		.comm	medium_speed,4,4
  19              		.comm	turn_speed,4,4
  20              		.comm	brake_speed,4,4
  21              		.comm	speedC,4,4
  22              		.comm	LineScanData,200,4
  23              		.comm	histogram,4096,4
  24              		.comm	kp,8,8
  25              		.comm	ki,8,8
  26              		.comm	kd,8,8
  27              		.comm	lastError,8,8
  28              		.comm	llastError,8,8
  29              		.comm	lastOutput,4,4
  30              		.comm	AccData,6,4
  31              		.comm	Xout,2,2
  32              		.comm	Yout,2,2
  33              		.comm	Zout,2,2
  34              		.comm	Xoffset,1,1
  35              		.comm	Yoffset,1,1
  36              		.comm	Zoffset,1,1
  37              		.comm	ramp,4,4
  38              		.comm	drs_val,1,1
  39              		.comm	dmx32_val,1,1
  40              		.section	.text.InitClock,"ax",%progbits
  41              		.align	2
  42              		.global	InitClock
  43              		.code	16
  44              		.thumb_func
  46              	InitClock:
  47              	.LFB0:
  48              		.file 1 "../Sources/system/CrystalClock.c"
   1:../Sources/system/CrystalClock.c **** #include "Config.h"
   2:../Sources/system/CrystalClock.c **** 
   3:../Sources/system/CrystalClock.c **** #if (defined(CW))
   4:../Sources/system/CrystalClock.c **** 	#include "cw.h"
   5:../Sources/system/CrystalClock.c **** #endif
   6:../Sources/system/CrystalClock.c **** 
   7:../Sources/system/CrystalClock.c **** // Constants for use in pll_init
   8:../Sources/system/CrystalClock.c **** #define NO_OSCINIT 0
   9:../Sources/system/CrystalClock.c **** #define OSCINIT 1
  10:../Sources/system/CrystalClock.c **** 
  11:../Sources/system/CrystalClock.c **** #define OSC_0 0
  12:../Sources/system/CrystalClock.c **** #define OSC_1 1
  13:../Sources/system/CrystalClock.c **** 
  14:../Sources/system/CrystalClock.c **** #define LOW_POWER 0
  15:../Sources/system/CrystalClock.c **** #define HIGH_GAIN 1
  16:../Sources/system/CrystalClock.c **** 
  17:../Sources/system/CrystalClock.c **** #define CANNED_OSC  0
  18:../Sources/system/CrystalClock.c **** #define CRYSTAL 1
  19:../Sources/system/CrystalClock.c **** 
  20:../Sources/system/CrystalClock.c **** #define PLL_0 0
  21:../Sources/system/CrystalClock.c **** #define PLL_1 1
  22:../Sources/system/CrystalClock.c **** 
  23:../Sources/system/CrystalClock.c **** #define PLL_ONLY 0
  24:../Sources/system/CrystalClock.c **** #define MCGOUT 1
  25:../Sources/system/CrystalClock.c **** 
  26:../Sources/system/CrystalClock.c **** // MCG Mode defines
  27:../Sources/system/CrystalClock.c **** 
  28:../Sources/system/CrystalClock.c **** #define BLPI 1
  29:../Sources/system/CrystalClock.c **** #define FBI  2
  30:../Sources/system/CrystalClock.c **** #define FEI  3
  31:../Sources/system/CrystalClock.c **** #define FEE  4
  32:../Sources/system/CrystalClock.c **** #define FBE  5
  33:../Sources/system/CrystalClock.c **** #define BLPE 6
  34:../Sources/system/CrystalClock.c **** #define PBE  7
  35:../Sources/system/CrystalClock.c **** #define PEE  8
  36:../Sources/system/CrystalClock.c **** 
  37:../Sources/system/CrystalClock.c **** // IRC defines
  38:../Sources/system/CrystalClock.c **** #define SLOW_IRC 0
  39:../Sources/system/CrystalClock.c **** #define FAST_IRC 1
  40:../Sources/system/CrystalClock.c **** 
  41:../Sources/system/CrystalClock.c **** 
  42:../Sources/system/CrystalClock.c **** unsigned char fll_rtc_init(unsigned char, unsigned char);
  43:../Sources/system/CrystalClock.c **** 
  44:../Sources/system/CrystalClock.c **** 
  45:../Sources/system/CrystalClock.c **** // prototypes
  46:../Sources/system/CrystalClock.c **** void rtc_as_refclk(void);
  47:../Sources/system/CrystalClock.c **** int fee_fei(int slow_irc_freq);
  48:../Sources/system/CrystalClock.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  49:../Sources/system/CrystalClock.c **** int fbe_fei(int slow_irc_freq);
  50:../Sources/system/CrystalClock.c **** int fei_fbi(int irc_freq, unsigned char irc_select);
  51:../Sources/system/CrystalClock.c **** int fbi_fei(int slow_irc_freq);
  52:../Sources/system/CrystalClock.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  53:../Sources/system/CrystalClock.c **** int pbe_pee(int crystal_val);
  54:../Sources/system/CrystalClock.c **** int pee_pbe(int crystal_val);
  55:../Sources/system/CrystalClock.c **** int pbe_fbe(int crystal_val);
  56:../Sources/system/CrystalClock.c **** int fbe_fbi(int irc_freq, unsigned char irc_select);
  57:../Sources/system/CrystalClock.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  58:../Sources/system/CrystalClock.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  59:../Sources/system/CrystalClock.c **** int fbe_fee(int crystal_val);
  60:../Sources/system/CrystalClock.c **** int fee_fbe(int crystal_val);
  61:../Sources/system/CrystalClock.c **** int pbe_blpe(int crystal_val);
  62:../Sources/system/CrystalClock.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  63:../Sources/system/CrystalClock.c **** int blpe_fbe(int crystal_val);
  64:../Sources/system/CrystalClock.c **** int fbi_blpi(int irc_freq, unsigned char irc_select);
  65:../Sources/system/CrystalClock.c **** int blpi_fbi(int irc_freq, unsigned char irc_select);
  66:../Sources/system/CrystalClock.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  67:../Sources/system/CrystalClock.c **** int fee_fbi(int irc_freq, unsigned char irc_select);
  68:../Sources/system/CrystalClock.c **** int fbe_blpe(int crystal_val);
  69:../Sources/system/CrystalClock.c **** 
  70:../Sources/system/CrystalClock.c **** int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val
  71:../Sources/system/CrystalClock.c **** 
  72:../Sources/system/CrystalClock.c **** int fll_freq(int fll_ref);
  73:../Sources/system/CrystalClock.c **** unsigned char what_mcg_mode(void);
  74:../Sources/system/CrystalClock.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq);
  75:../Sources/system/CrystalClock.c **** void clk_monitor_0(unsigned char en_dis);
  76:../Sources/system/CrystalClock.c **** 
  77:../Sources/system/CrystalClock.c **** 
  78:../Sources/system/CrystalClock.c **** 
  79:../Sources/system/CrystalClock.c **** 
  80:../Sources/system/CrystalClock.c **** // global variables
  81:../Sources/system/CrystalClock.c **** extern int core_clk_khz;
  82:../Sources/system/CrystalClock.c **** char drs_val, dmx32_val;
  83:../Sources/system/CrystalClock.c **** 
  84:../Sources/system/CrystalClock.c **** 
  85:../Sources/system/CrystalClock.c **** 
  86:../Sources/system/CrystalClock.c **** 
  87:../Sources/system/CrystalClock.c **** /*****************************************************************************
  88:../Sources/system/CrystalClock.c ****  * @name     pll_init
  89:../Sources/system/CrystalClock.c ****  *
  90:../Sources/system/CrystalClock.c ****  * @brief:   Initialization of the MCU.
  91:../Sources/system/CrystalClock.c ****  *
  92:../Sources/system/CrystalClock.c ****  * @param  : None
  93:../Sources/system/CrystalClock.c ****  *
  94:../Sources/system/CrystalClock.c ****  * @return : None
  95:../Sources/system/CrystalClock.c ****  *****************************************************************************
  96:../Sources/system/CrystalClock.c ****  * It will configure the MCU to disable STOP and COP Modules.
  97:../Sources/system/CrystalClock.c ****  * It also set the MCG configuration and bus clock frequency.
  98:../Sources/system/CrystalClock.c ****  ****************************************************************************/
  99:../Sources/system/CrystalClock.c **** void InitClock()
 100:../Sources/system/CrystalClock.c **** {
  49              		.loc 1 100 0
  50              		.cfi_startproc
  51 0000 80B5     		push	{r7, lr}
  52              	.LCFI0:
  53              		.cfi_def_cfa_offset 8
  54              		.cfi_offset 7, -8
  55              		.cfi_offset 14, -4
  56 0002 82B0     		sub	sp, sp, #8
  57              	.LCFI1:
  58              		.cfi_def_cfa_offset 16
  59 0004 02AF     		add	r7, sp, #8
  60              	.LCFI2:
  61              		.cfi_def_cfa 7, 8
 101:../Sources/system/CrystalClock.c **** 	pll_init(8000000, LOW_POWER, CRYSTAL, 4, 24, MCGOUT);
  62              		.loc 1 101 0
  63 0006 064B     		ldr	r3, .L2
  64 0008 1822     		mov	r2, #24
  65 000a 0092     		str	r2, [sp]
  66 000c 0122     		mov	r2, #1
  67 000e 0192     		str	r2, [sp, #4]
  68 0010 181C     		mov	r0, r3
  69 0012 0021     		mov	r1, #0
  70 0014 0122     		mov	r2, #1
  71 0016 0423     		mov	r3, #4
  72 0018 FFF7FEFF 		bl	pll_init
 102:../Sources/system/CrystalClock.c ****     	
 103:../Sources/system/CrystalClock.c ****     /************* USB Part **********************/
 104:../Sources/system/CrystalClock.c ****    	/*********************************************/   
 105:../Sources/system/CrystalClock.c ****    //	SIM_CLKDIV2 &= (uint32_t)(~(SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK));
 106:../Sources/system/CrystalClock.c **** 
 107:../Sources/system/CrystalClock.c ****     /* Configure USBFRAC = 0, USBDIV = 0 => frq(USBout) = 1 / 1 * frq(PLLin) */
 108:../Sources/system/CrystalClock.c ****    	//SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
 109:../Sources/system/CrystalClock.c ****    			    
 110:../Sources/system/CrystalClock.c ****    	/* Configure USB to be clocked from PLL */
 111:../Sources/system/CrystalClock.c ****    	//SIM_SOPT2  |= (SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL_MASK);
 112:../Sources/system/CrystalClock.c **** 
 113:../Sources/system/CrystalClock.c ****    	/* Enable USB-OTG IP clocking */
 114:../Sources/system/CrystalClock.c ****    	//SIM_SCGC4 |= (SIM_SCGC4_USBOTG_MASK); 
 115:../Sources/system/CrystalClock.c ****     			    
 116:../Sources/system/CrystalClock.c ****     			/* Configure enable USB regulator for device */
 117:../Sources/system/CrystalClock.c ****    //SIM_SOPT1 |= SIM_SOPT1_USBREGEN_MASK;
 118:../Sources/system/CrystalClock.c ****    			    
 119:../Sources/system/CrystalClock.c ****    //NVICICER2 |= (1<<9);	/* Clear any pending interrupts on USB */
 120:../Sources/system/CrystalClock.c **** //   NVICISER2 |= (1<<9);	/* Enable interrupts from USB module */	 
 121:../Sources/system/CrystalClock.c **** 
 122:../Sources/system/CrystalClock.c ****     	
 123:../Sources/system/CrystalClock.c ****     /* Now running PEE Mode */
 124:../Sources/system/CrystalClock.c **** 
 125:../Sources/system/CrystalClock.c **** 
 126:../Sources/system/CrystalClock.c **** }
  73              		.loc 1 126 0
  74 001c BD46     		mov	sp, r7
  75              		@ sp needed for prologue
  76 001e 80BD     		pop	{r7, pc}
  77              	.L3:
  78              		.align	2
  79              	.L2:
  80 0020 00127A00 		.word	8000000
  81              		.cfi_endproc
  82              	.LFE0:
  84              		.global	__aeabi_idiv
  85              		.section	.text.pll_init,"ax",%progbits
  86              		.align	2
  87              		.global	pll_init
  88              		.code	16
  89              		.thumb_func
  91              	pll_init:
  92              	.LFB1:
 127:../Sources/system/CrystalClock.c **** 
 128:../Sources/system/CrystalClock.c **** 
 129:../Sources/system/CrystalClock.c **** /*
 130:../Sources/system/CrystalClock.c ****  * File:    mcg.c
 131:../Sources/system/CrystalClock.c ****  *
 132:../Sources/system/CrystalClock.c ****  * MCG drivers for Freescale Kinetis L - series devices
 133:../Sources/system/CrystalClock.c ****  * Notes:
 134:../Sources/system/CrystalClock.c ****  * Assumes the MCG mode is in the default FEI mode out of reset
 135:../Sources/system/CrystalClock.c ****  */
 136:../Sources/system/CrystalClock.c **** 
 137:../Sources/system/CrystalClock.c **** #include "derivative.h"
 138:../Sources/system/CrystalClock.c **** #include "System.h"
 139:../Sources/system/CrystalClock.c **** 
 140:../Sources/system/CrystalClock.c **** 
 141:../Sources/system/CrystalClock.c **** 
 142:../Sources/system/CrystalClock.c **** 
 143:../Sources/system/CrystalClock.c **** /*********************************************************************************************/
 144:../Sources/system/CrystalClock.c **** /* Functon name : pll_init
 145:../Sources/system/CrystalClock.c ****  *
 146:../Sources/system/CrystalClock.c ****  * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
 147:../Sources/system/CrystalClock.c ****  *
 148:../Sources/system/CrystalClock.c ****  * This function initializess PLL0. Either OSC0 is selected for the
 149:../Sources/system/CrystalClock.c ****  * reference clock source. The oscillators can be configured to use a crystal or take in an
 150:../Sources/system/CrystalClock.c ****  * external square wave clock.
 151:../Sources/system/CrystalClock.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
 152:../Sources/system/CrystalClock.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
 153:../Sources/system/CrystalClock.c ****  * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
 154:../Sources/system/CrystalClock.c ****  * All parameters must be provided, for example crystal_val must be provided even if the
 155:../Sources/system/CrystalClock.c ****  * oscillator associated with that parameter is already initialized.
 156:../Sources/system/CrystalClock.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
 157:../Sources/system/CrystalClock.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
 158:../Sources/system/CrystalClock.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
 159:../Sources/system/CrystalClock.c ****  * readme file in the mcg driver directory for a list of all these codes.
 160:../Sources/system/CrystalClock.c ****  *
 161:../Sources/system/CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
 162:../Sources/system/CrystalClock.c ****  *                           wave clock source
 163:../Sources/system/CrystalClock.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
 164:../Sources/system/CrystalClock.c ****  *                           for the crystal oscillator. This has no meaning if an
 165:../Sources/system/CrystalClock.c ****  *                           external clock is used.
 166:../Sources/system/CrystalClock.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
 167:../Sources/system/CrystalClock.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 168:../Sources/system/CrystalClock.c ****  *                           PLL reference clock frequency
 169:../Sources/system/CrystalClock.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 170:../Sources/system/CrystalClock.c ****  *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
 171:../Sources/system/CrystalClock.c ****  *                              to provide the MCGOUT clock for the system.
 172:../Sources/system/CrystalClock.c ****  *
 173:../Sources/system/CrystalClock.c ****  * Return value : PLL frequency (Hz) or error code
 174:../Sources/system/CrystalClock.c ****  */
 175:../Sources/system/CrystalClock.c **** 
 176:../Sources/system/CrystalClock.c **** int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val
 177:../Sources/system/CrystalClock.c **** {
  93              		.loc 1 177 0
  94              		.cfi_startproc
  95 0000 80B5     		push	{r7, lr}
  96              	.LCFI3:
  97              		.cfi_def_cfa_offset 8
  98              		.cfi_offset 7, -8
  99              		.cfi_offset 14, -4
 100 0002 86B0     		sub	sp, sp, #24
 101              	.LCFI4:
 102              		.cfi_def_cfa_offset 32
 103 0004 00AF     		add	r7, sp, #0
 104              	.LCFI5:
 105              		.cfi_def_cfa_register 7
 106 0006 7860     		str	r0, [r7, #4]
 107 0008 081C     		mov	r0, r1
 108 000a 111C     		mov	r1, r2
 109 000c 1A1C     		mov	r2, r3
 110 000e FB1C     		add	r3, r7, #3
 111 0010 1870     		strb	r0, [r3]
 112 0012 BB1C     		add	r3, r7, #2
 113 0014 1970     		strb	r1, [r3]
 114 0016 7B1C     		add	r3, r7, #1
 115 0018 1A70     		strb	r2, [r3]
 178:../Sources/system/CrystalClock.c ****   unsigned char frdiv_val;
 179:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 180:../Sources/system/CrystalClock.c ****   unsigned char prdiv, vdiv;
 181:../Sources/system/CrystalClock.c ****   short i;
 182:../Sources/system/CrystalClock.c ****   int ref_freq;
 183:../Sources/system/CrystalClock.c ****   int pll_freq;
 184:../Sources/system/CrystalClock.c **** 
 185:../Sources/system/CrystalClock.c ****   // check if in FEI mode
 186:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 116              		.loc 1 186 0
 117 001a C24B     		ldr	r3, .L64
 118 001c 9B79     		ldrb	r3, [r3, #6]
 119 001e DBB2     		uxtb	r3, r3
 120 0020 1A1C     		mov	r2, r3
 121 0022 0C23     		mov	r3, #12
 122 0024 1340     		and	r3, r2
 123 0026 9B08     		lsr	r3, r3, #2
 124 0028 0DD1     		bne	.L5
 187:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 125              		.loc 1 187 0
 126 002a BE4B     		ldr	r3, .L64
 127 002c 9B79     		ldrb	r3, [r3, #6]
 128 002e DBB2     		uxtb	r3, r3
 129 0030 1A1C     		mov	r2, r3
 130 0032 1023     		mov	r3, #16
 131 0034 1340     		and	r3, r2
 186:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 132              		.loc 1 186 0
 133 0036 06D0     		beq	.L5
 188:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 134              		.loc 1 188 0
 135 0038 BA4B     		ldr	r3, .L64
 136 003a 9B79     		ldrb	r3, [r3, #6]
 137 003c DBB2     		uxtb	r3, r3
 138 003e 1A1C     		mov	r2, r3
 139 0040 2023     		mov	r3, #32
 140 0042 1340     		and	r3, r2
 186:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 141              		.loc 1 186 0
 142 0044 01D0     		beq	.L6
 143              	.L5:
 189:../Sources/system/CrystalClock.c ****   {
 190:../Sources/system/CrystalClock.c ****     return 0x1;                                                     // return error code
 144              		.loc 1 190 0
 145 0046 0123     		mov	r3, #1
 146 0048 73E2     		b	.L7
 147              	.L6:
 191:../Sources/system/CrystalClock.c ****   }
 192:../Sources/system/CrystalClock.c **** 
 193:../Sources/system/CrystalClock.c ****   // check external frequency is less than the maximum frequency
 194:../Sources/system/CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 148              		.loc 1 194 0
 149 004a 7A68     		ldr	r2, [r7, #4]
 150 004c B64B     		ldr	r3, .L64+4
 151 004e 9A42     		cmp	r2, r3
 152 0050 01DD     		ble	.L8
 153              		.loc 1 194 0 is_stmt 0
 154 0052 2123     		mov	r3, #33
 155 0054 6DE2     		b	.L7
 156              	.L8:
 195:../Sources/system/CrystalClock.c **** 
 196:../Sources/system/CrystalClock.c ****   // check crystal frequency is within spec. if crystal osc is being used as PLL ref
 197:../Sources/system/CrystalClock.c ****   if (erefs_val)
 157              		.loc 1 197 0 is_stmt 1
 158 0056 BB1C     		add	r3, r7, #2
 159 0058 1B78     		ldrb	r3, [r3]
 160 005a 002B     		cmp	r3, #0
 161 005c 09D0     		beq	.L9
 198:../Sources/system/CrystalClock.c ****   {
 199:../Sources/system/CrystalClock.c ****     if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of t
 162              		.loc 1 199 0
 163 005e 7A68     		ldr	r2, [r7, #4]
 164 0060 B24B     		ldr	r3, .L64+8
 165 0062 9A42     		cmp	r2, r3
 166 0064 03DD     		ble	.L10
 167              		.loc 1 199 0 is_stmt 0
 168 0066 7A68     		ldr	r2, [r7, #4]
 169 0068 B14B     		ldr	r3, .L64+12
 170 006a 9A42     		cmp	r2, r3
 171 006c 01DD     		ble	.L9
 172              	.L10:
 173              		.loc 1 199 0
 174 006e 2223     		mov	r3, #34
 175 0070 5FE2     		b	.L7
 176              	.L9:
 200:../Sources/system/CrystalClock.c ****   }
 201:../Sources/system/CrystalClock.c **** 
 202:../Sources/system/CrystalClock.c ****   // make sure HGO will never be greater than 1. Could return an error instead if desired.
 203:../Sources/system/CrystalClock.c ****   if (hgo_val > 0)
 177              		.loc 1 203 0 is_stmt 1
 178 0072 FB1C     		add	r3, r7, #3
 179 0074 1B78     		ldrb	r3, [r3]
 180 0076 002B     		cmp	r3, #0
 181 0078 02D0     		beq	.L11
 204:../Sources/system/CrystalClock.c ****   {
 205:../Sources/system/CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 182              		.loc 1 205 0
 183 007a FB1C     		add	r3, r7, #3
 184 007c 0122     		mov	r2, #1
 185 007e 1A70     		strb	r2, [r3]
 186              	.L11:
 206:../Sources/system/CrystalClock.c ****   }
 207:../Sources/system/CrystalClock.c **** 
 208:../Sources/system/CrystalClock.c ****   // Check PLL divider settings are within spec.
 209:../Sources/system/CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 187              		.loc 1 209 0
 188 0080 7B1C     		add	r3, r7, #1
 189 0082 1B78     		ldrb	r3, [r3]
 190 0084 5BB2     		sxtb	r3, r3
 191 0086 002B     		cmp	r3, #0
 192 0088 04DD     		ble	.L12
 193              		.loc 1 209 0 is_stmt 0
 194 008a 7B1C     		add	r3, r7, #1
 195 008c 1B78     		ldrb	r3, [r3]
 196 008e 5BB2     		sxtb	r3, r3
 197 0090 192B     		cmp	r3, #25
 198 0092 01DD     		ble	.L13
 199              	.L12:
 200              		.loc 1 209 0
 201 0094 4123     		mov	r3, #65
 202 0096 4CE2     		b	.L7
 203              	.L13:
 210:../Sources/system/CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 204              		.loc 1 210 0 is_stmt 1
 205 0098 3B1C     		mov	r3, r7
 206 009a 2033     		add	r3, r3, #32
 207 009c 1B78     		ldrb	r3, [r3]
 208 009e 5BB2     		sxtb	r3, r3
 209 00a0 172B     		cmp	r3, #23
 210 00a2 05DD     		ble	.L14
 211              		.loc 1 210 0 is_stmt 0
 212 00a4 3B1C     		mov	r3, r7
 213 00a6 2033     		add	r3, r3, #32
 214 00a8 1B78     		ldrb	r3, [r3]
 215 00aa 5BB2     		sxtb	r3, r3
 216 00ac 322B     		cmp	r3, #50
 217 00ae 01DD     		ble	.L15
 218              	.L14:
 219              		.loc 1 210 0
 220 00b0 4223     		mov	r3, #66
 221 00b2 3EE2     		b	.L7
 222              	.L15:
 211:../Sources/system/CrystalClock.c **** 
 212:../Sources/system/CrystalClock.c ****   // Check PLL reference clock frequency is within spec.
 213:../Sources/system/CrystalClock.c ****   ref_freq = crystal_val / prdiv_val;
 223              		.loc 1 213 0 is_stmt 1
 224 00b4 7B1C     		add	r3, r7, #1
 225 00b6 1B78     		ldrb	r3, [r3]
 226 00b8 5BB2     		sxtb	r3, r3
 227 00ba 7868     		ldr	r0, [r7, #4]
 228 00bc 191C     		mov	r1, r3
 229 00be FFF7FEFF 		bl	__aeabi_idiv
 230 00c2 031C     		mov	r3, r0
 231 00c4 3B61     		str	r3, [r7, #16]
 214:../Sources/system/CrystalClock.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 232              		.loc 1 214 0
 233 00c6 3A69     		ldr	r2, [r7, #16]
 234 00c8 9A4B     		ldr	r3, .L64+16
 235 00ca 9A42     		cmp	r2, r3
 236 00cc 03DD     		ble	.L16
 237              		.loc 1 214 0 is_stmt 0
 238 00ce 3A69     		ldr	r2, [r7, #16]
 239 00d0 994B     		ldr	r3, .L64+20
 240 00d2 9A42     		cmp	r2, r3
 241 00d4 01DD     		ble	.L17
 242              	.L16:
 243              		.loc 1 214 0
 244 00d6 4323     		mov	r3, #67
 245 00d8 2BE2     		b	.L7
 246              	.L17:
 215:../Sources/system/CrystalClock.c **** 
 216:../Sources/system/CrystalClock.c ****   // Check PLL output frequency is within spec.
 217:../Sources/system/CrystalClock.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 247              		.loc 1 217 0 is_stmt 1
 248 00da 7B1C     		add	r3, r7, #1
 249 00dc 1B78     		ldrb	r3, [r3]
 250 00de 5BB2     		sxtb	r3, r3
 251 00e0 7868     		ldr	r0, [r7, #4]
 252 00e2 191C     		mov	r1, r3
 253 00e4 FFF7FEFF 		bl	__aeabi_idiv
 254 00e8 031C     		mov	r3, r0
 255 00ea 3A1C     		mov	r2, r7
 256 00ec 2032     		add	r2, r2, #32
 257 00ee 1278     		ldrb	r2, [r2]
 258 00f0 52B2     		sxtb	r2, r2
 259 00f2 5343     		mul	r3, r2
 260 00f4 FB60     		str	r3, [r7, #12]
 218:../Sources/system/CrystalClock.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 261              		.loc 1 218 0
 262 00f6 FA68     		ldr	r2, [r7, #12]
 263 00f8 904B     		ldr	r3, .L64+24
 264 00fa 9A42     		cmp	r2, r3
 265 00fc 03DD     		ble	.L18
 266              		.loc 1 218 0 is_stmt 0
 267 00fe FA68     		ldr	r2, [r7, #12]
 268 0100 8F4B     		ldr	r3, .L64+28
 269 0102 9A42     		cmp	r2, r3
 270 0104 01DD     		ble	.L19
 271              	.L18:
 272              		.loc 1 218 0
 273 0106 4523     		mov	r3, #69
 274 0108 13E2     		b	.L7
 275              	.L19:
 219:../Sources/system/CrystalClock.c **** 
 220:../Sources/system/CrystalClock.c ****   // configure the MCG_C2 register
 221:../Sources/system/CrystalClock.c ****   // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the
 222:../Sources/system/CrystalClock.c ****   // it still needs to be set correctly even if the oscillator is not being used
 223:../Sources/system/CrystalClock.c ****       
 224:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C2;
 276              		.loc 1 224 0 is_stmt 1
 277 010a 864A     		ldr	r2, .L64
 278 010c 3B1C     		mov	r3, r7
 279 010e 1633     		add	r3, r3, #22
 280 0110 5278     		ldrb	r2, [r2, #1]
 281 0112 1A70     		strb	r2, [r3]
 225:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 282              		.loc 1 225 0
 283 0114 3B1C     		mov	r3, r7
 284 0116 1633     		add	r3, r3, #22
 285 0118 3A1C     		mov	r2, r7
 286 011a 1632     		add	r2, r2, #22
 287 011c 1278     		ldrb	r2, [r2]
 288 011e 3C21     		mov	r1, #60
 289 0120 8A43     		bic	r2, r1
 290 0122 1A70     		strb	r2, [r3]
 226:../Sources/system/CrystalClock.c ****     
 227:../Sources/system/CrystalClock.c ****   if (crystal_val <= 8000000)
 291              		.loc 1 227 0
 292 0124 7A68     		ldr	r2, [r7, #4]
 293 0126 874B     		ldr	r3, .L64+32
 294 0128 9A42     		cmp	r2, r3
 295 012a 14DC     		bgt	.L20
 228:../Sources/system/CrystalClock.c ****   {
 229:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 296              		.loc 1 229 0
 297 012c FB1C     		add	r3, r7, #3
 298 012e 1B78     		ldrb	r3, [r3]
 299 0130 DB00     		lsl	r3, r3, #3
 300 0132 DAB2     		uxtb	r2, r3
 301 0134 BB1C     		add	r3, r7, #2
 302 0136 1B78     		ldrb	r3, [r3]
 303 0138 9B00     		lsl	r3, r3, #2
 304 013a DBB2     		uxtb	r3, r3
 305 013c 1343     		orr	r3, r2
 306 013e DAB2     		uxtb	r2, r3
 307 0140 3B1C     		mov	r3, r7
 308 0142 1633     		add	r3, r3, #22
 309 0144 1B78     		ldrb	r3, [r3]
 310 0146 1343     		orr	r3, r2
 311 0148 DAB2     		uxtb	r2, r3
 312 014a 3B1C     		mov	r3, r7
 313 014c 1633     		add	r3, r3, #22
 314 014e 1021     		mov	r1, #16
 315 0150 0A43     		orr	r2, r1
 316 0152 1A70     		strb	r2, [r3]
 317 0154 13E0     		b	.L21
 318              	.L20:
 230:../Sources/system/CrystalClock.c ****   }
 231:../Sources/system/CrystalClock.c ****   else
 232:../Sources/system/CrystalClock.c ****   {
 233:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 319              		.loc 1 233 0
 320 0156 FB1C     		add	r3, r7, #3
 321 0158 1B78     		ldrb	r3, [r3]
 322 015a DB00     		lsl	r3, r3, #3
 323 015c DAB2     		uxtb	r2, r3
 324 015e BB1C     		add	r3, r7, #2
 325 0160 1B78     		ldrb	r3, [r3]
 326 0162 9B00     		lsl	r3, r3, #2
 327 0164 DBB2     		uxtb	r3, r3
 328 0166 1343     		orr	r3, r2
 329 0168 DAB2     		uxtb	r2, r3
 330 016a 3B1C     		mov	r3, r7
 331 016c 1633     		add	r3, r3, #22
 332 016e 1B78     		ldrb	r3, [r3]
 333 0170 1343     		orr	r3, r2
 334 0172 DAB2     		uxtb	r2, r3
 335 0174 3B1C     		mov	r3, r7
 336 0176 1633     		add	r3, r3, #22
 337 0178 2021     		mov	r1, #32
 338 017a 0A43     		orr	r2, r1
 339 017c 1A70     		strb	r2, [r3]
 340              	.L21:
 234:../Sources/system/CrystalClock.c ****   }
 235:../Sources/system/CrystalClock.c ****   MCG_C2 = temp_reg;
 341              		.loc 1 235 0
 342 017e 694B     		ldr	r3, .L64
 343 0180 3A1C     		mov	r2, r7
 344 0182 1632     		add	r2, r2, #22
 345 0184 1278     		ldrb	r2, [r2]
 346 0186 5A70     		strb	r2, [r3, #1]
 236:../Sources/system/CrystalClock.c ****   
 237:../Sources/system/CrystalClock.c ****   // determine FRDIV based on reference clock frequency
 238:../Sources/system/CrystalClock.c ****   // since the external frequency has already been checked only the maximum frequency for each FRDI
 239:../Sources/system/CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 347              		.loc 1 239 0
 348 0188 7A68     		ldr	r2, [r7, #4]
 349 018a 6F4B     		ldr	r3, .L64+36
 350 018c 9A42     		cmp	r2, r3
 351 018e 04DC     		bgt	.L22
 352              		.loc 1 239 0 is_stmt 0
 353 0190 3B1C     		mov	r3, r7
 354 0192 1733     		add	r3, r3, #23
 355 0194 0022     		mov	r2, #0
 356 0196 1A70     		strb	r2, [r3]
 357 0198 27E0     		b	.L23
 358              	.L22:
 240:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 359              		.loc 1 240 0 is_stmt 1
 360 019a 7A68     		ldr	r2, [r7, #4]
 361 019c 6B4B     		ldr	r3, .L64+40
 362 019e 9A42     		cmp	r2, r3
 363 01a0 04DC     		bgt	.L24
 364              		.loc 1 240 0 is_stmt 0
 365 01a2 3B1C     		mov	r3, r7
 366 01a4 1733     		add	r3, r3, #23
 367 01a6 0122     		mov	r2, #1
 368 01a8 1A70     		strb	r2, [r3]
 369 01aa 1EE0     		b	.L23
 370              	.L24:
 241:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 371              		.loc 1 241 0 is_stmt 1
 372 01ac 7A68     		ldr	r2, [r7, #4]
 373 01ae 684B     		ldr	r3, .L64+44
 374 01b0 9A42     		cmp	r2, r3
 375 01b2 04DC     		bgt	.L25
 376              		.loc 1 241 0 is_stmt 0
 377 01b4 3B1C     		mov	r3, r7
 378 01b6 1733     		add	r3, r3, #23
 379 01b8 0222     		mov	r2, #2
 380 01ba 1A70     		strb	r2, [r3]
 381 01bc 15E0     		b	.L23
 382              	.L25:
 242:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 383              		.loc 1 242 0 is_stmt 1
 384 01be 7A68     		ldr	r2, [r7, #4]
 385 01c0 644B     		ldr	r3, .L64+48
 386 01c2 9A42     		cmp	r2, r3
 387 01c4 04DC     		bgt	.L26
 388              		.loc 1 242 0 is_stmt 0
 389 01c6 3B1C     		mov	r3, r7
 390 01c8 1733     		add	r3, r3, #23
 391 01ca 0322     		mov	r2, #3
 392 01cc 1A70     		strb	r2, [r3]
 393 01ce 0CE0     		b	.L23
 394              	.L26:
 243:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 395              		.loc 1 243 0 is_stmt 1
 396 01d0 7A68     		ldr	r2, [r7, #4]
 397 01d2 614B     		ldr	r3, .L64+52
 398 01d4 9A42     		cmp	r2, r3
 399 01d6 04DC     		bgt	.L27
 400              		.loc 1 243 0 is_stmt 0
 401 01d8 3B1C     		mov	r3, r7
 402 01da 1733     		add	r3, r3, #23
 403 01dc 0422     		mov	r2, #4
 404 01de 1A70     		strb	r2, [r3]
 405 01e0 03E0     		b	.L23
 406              	.L27:
 244:../Sources/system/CrystalClock.c ****   else {frdiv_val = 5;}
 407              		.loc 1 244 0 is_stmt 1
 408 01e2 3B1C     		mov	r3, r7
 409 01e4 1733     		add	r3, r3, #23
 410 01e6 0522     		mov	r2, #5
 411 01e8 1A70     		strb	r2, [r3]
 412              	.L23:
 245:../Sources/system/CrystalClock.c **** 
 246:../Sources/system/CrystalClock.c ****   // Select external oscillator and Reference Divider and clear IREFS to start ext osc
 247:../Sources/system/CrystalClock.c ****   // If IRCLK is required it must be enabled outside of this driver, existing state will be maintai
 248:../Sources/system/CrystalClock.c ****   // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 249:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 413              		.loc 1 249 0
 414 01ea 4E4A     		ldr	r2, .L64
 415 01ec 3B1C     		mov	r3, r7
 416 01ee 1633     		add	r3, r3, #22
 417 01f0 1278     		ldrb	r2, [r2]
 418 01f2 1A70     		strb	r2, [r3]
 250:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 419              		.loc 1 250 0
 420 01f4 3B1C     		mov	r3, r7
 421 01f6 1633     		add	r3, r3, #22
 422 01f8 3A1C     		mov	r2, r7
 423 01fa 1632     		add	r2, r2, #22
 424 01fc 1178     		ldrb	r1, [r2]
 425 01fe 0322     		mov	r2, #3
 426 0200 0A40     		and	r2, r1
 427 0202 1A70     		strb	r2, [r3]
 251:../Sources/system/CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 428              		.loc 1 251 0
 429 0204 3B1C     		mov	r3, r7
 430 0206 1733     		add	r3, r3, #23
 431 0208 1B78     		ldrb	r3, [r3]
 432 020a DB00     		lsl	r3, r3, #3
 433 020c DAB2     		uxtb	r2, r3
 434 020e 3823     		mov	r3, #56
 435 0210 1340     		and	r3, r2
 436 0212 DAB2     		uxtb	r2, r3
 437 0214 3B1C     		mov	r3, r7
 438 0216 1633     		add	r3, r3, #22
 439 0218 1B78     		ldrb	r3, [r3]
 440 021a 1343     		orr	r3, r2
 441 021c DAB2     		uxtb	r2, r3
 442 021e 3B1C     		mov	r3, r7
 443 0220 1633     		add	r3, r3, #22
 444 0222 8021     		mov	r1, #128
 445 0224 4942     		neg	r1, r1
 446 0226 0A43     		orr	r2, r1
 447 0228 1A70     		strb	r2, [r3]
 252:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg;
 448              		.loc 1 252 0
 449 022a 3E4B     		ldr	r3, .L64
 450 022c 3A1C     		mov	r2, r7
 451 022e 1632     		add	r2, r2, #22
 452 0230 1278     		ldrb	r2, [r2]
 453 0232 1A70     		strb	r2, [r3]
 253:../Sources/system/CrystalClock.c **** 
 254:../Sources/system/CrystalClock.c ****   // if the external oscillator is used need to wait for OSCINIT to set
 255:../Sources/system/CrystalClock.c ****   if (erefs_val)
 454              		.loc 1 255 0
 455 0234 BB1C     		add	r3, r7, #2
 456 0236 1B78     		ldrb	r3, [r3]
 457 0238 002B     		cmp	r3, #0
 458 023a 24D0     		beq	.L28
 256:../Sources/system/CrystalClock.c ****   {
 257:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 20000 ; i++)
 459              		.loc 1 257 0
 460 023c 3B1C     		mov	r3, r7
 461 023e 1433     		add	r3, r3, #20
 462 0240 0022     		mov	r2, #0
 463 0242 1A80     		strh	r2, [r3]
 464 0244 0DE0     		b	.L29
 465              	.L32:
 258:../Sources/system/CrystalClock.c ****     {
 259:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 466              		.loc 1 259 0
 467 0246 374B     		ldr	r3, .L64
 468 0248 9B79     		ldrb	r3, [r3, #6]
 469 024a DBB2     		uxtb	r3, r3
 470 024c 1A1C     		mov	r2, r3
 471 024e 0223     		mov	r3, #2
 472 0250 1340     		and	r3, r2
 473 0252 0ED1     		bne	.L58
 474              	.L30:
 257:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 20000 ; i++)
 475              		.loc 1 257 0
 476 0254 3B1C     		mov	r3, r7
 477 0256 1433     		add	r3, r3, #20
 478 0258 3A1C     		mov	r2, r7
 479 025a 1432     		add	r2, r2, #20
 480 025c 1288     		ldrh	r2, [r2]
 481 025e 0132     		add	r2, r2, #1
 482 0260 1A80     		strh	r2, [r3]
 483              	.L29:
 257:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 20000 ; i++)
 484              		.loc 1 257 0 is_stmt 0
 485 0262 3B1C     		mov	r3, r7
 486 0264 1433     		add	r3, r3, #20
 487 0266 0021     		mov	r1, #0
 488 0268 5A5E     		ldrsh	r2, [r3, r1]
 489 026a 3C4B     		ldr	r3, .L64+56
 490 026c 9A42     		cmp	r2, r3
 491 026e EADD     		ble	.L32
 492 0270 00E0     		b	.L31
 493              	.L58:
 494              		.loc 1 259 0 is_stmt 1
 495 0272 C046     		mov	r8, r8
 496              	.L31:
 260:../Sources/system/CrystalClock.c ****     }
 261:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error
 497              		.loc 1 261 0
 498 0274 2B4B     		ldr	r3, .L64
 499 0276 9B79     		ldrb	r3, [r3, #6]
 500 0278 DBB2     		uxtb	r3, r3
 501 027a 1A1C     		mov	r2, r3
 502 027c 0223     		mov	r3, #2
 503 027e 1340     		and	r3, r2
 504 0280 01D1     		bne	.L28
 505              		.loc 1 261 0 is_stmt 0
 506 0282 2323     		mov	r3, #35
 507 0284 55E1     		b	.L7
 508              	.L28:
 262:../Sources/system/CrystalClock.c ****   }
 263:../Sources/system/CrystalClock.c **** 
 264:../Sources/system/CrystalClock.c ****   // wait for Reference clock Status bit to clear
 265:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 509              		.loc 1 265 0 is_stmt 1
 510 0286 3B1C     		mov	r3, r7
 511 0288 1433     		add	r3, r3, #20
 512 028a 0022     		mov	r2, #0
 513 028c 1A80     		strh	r2, [r3]
 514 028e 0DE0     		b	.L33
 515              	.L36:
 266:../Sources/system/CrystalClock.c ****   {
 267:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 516              		.loc 1 267 0
 517 0290 244B     		ldr	r3, .L64
 518 0292 9B79     		ldrb	r3, [r3, #6]
 519 0294 DBB2     		uxtb	r3, r3
 520 0296 1A1C     		mov	r2, r3
 521 0298 1023     		mov	r3, #16
 522 029a 1340     		and	r3, r2
 523 029c 0ED0     		beq	.L59
 524              	.L34:
 265:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 525              		.loc 1 265 0
 526 029e 3B1C     		mov	r3, r7
 527 02a0 1433     		add	r3, r3, #20
 528 02a2 3A1C     		mov	r2, r7
 529 02a4 1432     		add	r2, r2, #20
 530 02a6 1288     		ldrh	r2, [r2]
 531 02a8 0132     		add	r2, r2, #1
 532 02aa 1A80     		strh	r2, [r3]
 533              	.L33:
 265:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 534              		.loc 1 265 0 is_stmt 0
 535 02ac 3B1C     		mov	r3, r7
 536 02ae 1433     		add	r3, r3, #20
 537 02b0 0021     		mov	r1, #0
 538 02b2 5A5E     		ldrsh	r2, [r3, r1]
 539 02b4 2A4B     		ldr	r3, .L64+60
 540 02b6 9A42     		cmp	r2, r3
 541 02b8 EADD     		ble	.L36
 542 02ba 00E0     		b	.L35
 543              	.L59:
 544              		.loc 1 267 0 is_stmt 1
 545 02bc C046     		mov	r8, r8
 546              	.L35:
 268:../Sources/system/CrystalClock.c ****   }
 269:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 547              		.loc 1 269 0
 548 02be 194B     		ldr	r3, .L64
 549 02c0 9B79     		ldrb	r3, [r3, #6]
 550 02c2 DBB2     		uxtb	r3, r3
 551 02c4 1A1C     		mov	r2, r3
 552 02c6 1023     		mov	r3, #16
 553 02c8 1340     		and	r3, r2
 554 02ca 01D0     		beq	.L37
 555              		.loc 1 269 0 is_stmt 0
 556 02cc 1123     		mov	r3, #17
 557 02ce 30E1     		b	.L7
 558              	.L37:
 270:../Sources/system/CrystalClock.c **** 
 271:../Sources/system/CrystalClock.c ****   // Wait for clock status bits to show clock source is ext ref clk
 272:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 559              		.loc 1 272 0 is_stmt 1
 560 02d0 3B1C     		mov	r3, r7
 561 02d2 1433     		add	r3, r3, #20
 562 02d4 0022     		mov	r2, #0
 563 02d6 1A80     		strh	r2, [r3]
 564 02d8 0FE0     		b	.L38
 565              	.L41:
 273:../Sources/system/CrystalClock.c ****   {
 274:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 566              		.loc 1 274 0
 567 02da 124B     		ldr	r3, .L64
 568 02dc 9B79     		ldrb	r3, [r3, #6]
 569 02de DBB2     		uxtb	r3, r3
 570 02e0 1A1C     		mov	r2, r3
 571 02e2 0C23     		mov	r3, #12
 572 02e4 1340     		and	r3, r2
 573 02e6 9B08     		lsr	r3, r3, #2
 574 02e8 022B     		cmp	r3, #2
 575 02ea 0ED0     		beq	.L60
 576              	.L39:
 272:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 577              		.loc 1 272 0
 578 02ec 3B1C     		mov	r3, r7
 579 02ee 1433     		add	r3, r3, #20
 580 02f0 3A1C     		mov	r2, r7
 581 02f2 1432     		add	r2, r2, #20
 582 02f4 1288     		ldrh	r2, [r2]
 583 02f6 0132     		add	r2, r2, #1
 584 02f8 1A80     		strh	r2, [r3]
 585              	.L38:
 272:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 586              		.loc 1 272 0 is_stmt 0
 587 02fa 3B1C     		mov	r3, r7
 588 02fc 1433     		add	r3, r3, #20
 589 02fe 0021     		mov	r1, #0
 590 0300 5A5E     		ldrsh	r2, [r3, r1]
 591 0302 174B     		ldr	r3, .L64+60
 592 0304 9A42     		cmp	r2, r3
 593 0306 E8DD     		ble	.L41
 594 0308 00E0     		b	.L40
 595              	.L60:
 596              		.loc 1 274 0 is_stmt 1
 597 030a C046     		mov	r8, r8
 598              	.L40:
 275:../Sources/system/CrystalClock.c ****   }
 276:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 599              		.loc 1 276 0
 600 030c 054B     		ldr	r3, .L64
 601 030e 9B79     		ldrb	r3, [r3, #6]
 602 0310 DBB2     		uxtb	r3, r3
 603 0312 1A1C     		mov	r2, r3
 604 0314 0C23     		mov	r3, #12
 605 0316 1340     		and	r3, r2
 606 0318 9B08     		lsr	r3, r3, #2
 607 031a 022B     		cmp	r3, #2
 608 031c 22D0     		beq	.L42
 609              		.loc 1 276 0 is_stmt 0
 610 031e 1A23     		mov	r3, #26
 611 0320 07E1     		b	.L7
 612              	.L65:
 613 0322 C046     		.align	2
 614              	.L64:
 615 0324 00400640 		.word	1074151424
 616 0328 80F0FA02 		.word	50000000
 617 032c BFC62D00 		.word	2999999
 618 0330 0048E801 		.word	32000000
 619 0334 7F841E00 		.word	1999999
 620 0338 00093D00 		.word	4000000
 621 033c FF6BDC02 		.word	47999999
 622 0340 00E1F505 		.word	100000000
 623 0344 00127A00 		.word	8000000
 624 0348 D0121300 		.word	1250000
 625 034c A0252600 		.word	2500000
 626 0350 404B4C00 		.word	5000000
 627 0354 80969800 		.word	10000000
 628 0358 002D3101 		.word	20000000
 629 035c 1F4E0000 		.word	19999
 630 0360 CF070000 		.word	1999
 631              	.L42:
 277:../Sources/system/CrystalClock.c **** 
 278:../Sources/system/CrystalClock.c ****   // Now in FBE
 279:../Sources/system/CrystalClock.c ****   // It is recommended that the clock monitor is enabled when using an external clock as the clock 
 280:../Sources/system/CrystalClock.c ****   // It is enabled here but can be removed if this is not required.
 281:../Sources/system/CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 632              		.loc 1 281 0 is_stmt 1
 633 0364 754B     		ldr	r3, .L66
 634 0366 754A     		ldr	r2, .L66
 635 0368 5279     		ldrb	r2, [r2, #5]
 636 036a D2B2     		uxtb	r2, r2
 637 036c 2021     		mov	r1, #32
 638 036e 0A43     		orr	r2, r1
 639 0370 D2B2     		uxtb	r2, r2
 640 0372 5A71     		strb	r2, [r3, #5]
 282:../Sources/system/CrystalClock.c ****   
 283:../Sources/system/CrystalClock.c ****   // Configure PLL
 284:../Sources/system/CrystalClock.c ****   // Configure MCG_C5
 285:../Sources/system/CrystalClock.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 286:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C5;
 641              		.loc 1 286 0
 642 0374 714A     		ldr	r2, .L66
 643 0376 3B1C     		mov	r3, r7
 644 0378 1633     		add	r3, r3, #22
 645 037a 1279     		ldrb	r2, [r2, #4]
 646 037c 1A70     		strb	r2, [r3]
 287:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 647              		.loc 1 287 0
 648 037e 3B1C     		mov	r3, r7
 649 0380 1633     		add	r3, r3, #22
 650 0382 3A1C     		mov	r2, r7
 651 0384 1632     		add	r2, r2, #22
 652 0386 1278     		ldrb	r2, [r2]
 653 0388 1F21     		mov	r1, #31
 654 038a 8A43     		bic	r2, r1
 655 038c 1A70     		strb	r2, [r3]
 288:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 656              		.loc 1 288 0
 657 038e 7B1C     		add	r3, r7, #1
 658 0390 1B78     		ldrb	r3, [r3]
 659 0392 013B     		sub	r3, r3, #1
 660 0394 DAB2     		uxtb	r2, r3
 661 0396 1F23     		mov	r3, #31
 662 0398 1340     		and	r3, r2
 663 039a D9B2     		uxtb	r1, r3
 664 039c 3B1C     		mov	r3, r7
 665 039e 1633     		add	r3, r3, #22
 666 03a0 3A1C     		mov	r2, r7
 667 03a2 1632     		add	r2, r2, #22
 668 03a4 1278     		ldrb	r2, [r2]
 669 03a6 0A43     		orr	r2, r1
 670 03a8 1A70     		strb	r2, [r3]
 289:../Sources/system/CrystalClock.c ****   MCG_C5 = temp_reg;
 671              		.loc 1 289 0
 672 03aa 644B     		ldr	r3, .L66
 673 03ac 3A1C     		mov	r2, r7
 674 03ae 1632     		add	r2, r2, #22
 675 03b0 1278     		ldrb	r2, [r2]
 676 03b2 1A71     		strb	r2, [r3, #4]
 290:../Sources/system/CrystalClock.c **** 
 291:../Sources/system/CrystalClock.c ****   // Configure MCG_C6
 292:../Sources/system/CrystalClock.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 293:../Sources/system/CrystalClock.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 294:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 677              		.loc 1 294 0
 678 03b4 614A     		ldr	r2, .L66
 679 03b6 3B1C     		mov	r3, r7
 680 03b8 1633     		add	r3, r3, #22
 681 03ba 5279     		ldrb	r2, [r2, #5]
 682 03bc 1A70     		strb	r2, [r3]
 295:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 683              		.loc 1 295 0
 684 03be 3B1C     		mov	r3, r7
 685 03c0 1633     		add	r3, r3, #22
 686 03c2 3A1C     		mov	r2, r7
 687 03c4 1632     		add	r2, r2, #22
 688 03c6 1278     		ldrb	r2, [r2]
 689 03c8 1F21     		mov	r1, #31
 690 03ca 8A43     		bic	r2, r1
 691 03cc 1A70     		strb	r2, [r3]
 296:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 692              		.loc 1 296 0
 693 03ce 3B1C     		mov	r3, r7
 694 03d0 2033     		add	r3, r3, #32
 695 03d2 1B78     		ldrb	r3, [r3]
 696 03d4 183B     		sub	r3, r3, #24
 697 03d6 DAB2     		uxtb	r2, r3
 698 03d8 1F23     		mov	r3, #31
 699 03da 1340     		and	r3, r2
 700 03dc DAB2     		uxtb	r2, r3
 701 03de 3B1C     		mov	r3, r7
 702 03e0 1633     		add	r3, r3, #22
 703 03e2 1B78     		ldrb	r3, [r3]
 704 03e4 1343     		orr	r3, r2
 705 03e6 DAB2     		uxtb	r2, r3
 706 03e8 3B1C     		mov	r3, r7
 707 03ea 1633     		add	r3, r3, #22
 708 03ec 4021     		mov	r1, #64
 709 03ee 0A43     		orr	r2, r1
 710 03f0 1A70     		strb	r2, [r3]
 297:../Sources/system/CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 711              		.loc 1 297 0
 712 03f2 524B     		ldr	r3, .L66
 713 03f4 3A1C     		mov	r2, r7
 714 03f6 1632     		add	r2, r2, #22
 715 03f8 1278     		ldrb	r2, [r2]
 716 03fa 5A71     		strb	r2, [r3, #5]
 298:../Sources/system/CrystalClock.c **** 
 299:../Sources/system/CrystalClock.c ****   // wait for PLLST status bit to set
 300:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 717              		.loc 1 300 0
 718 03fc 3B1C     		mov	r3, r7
 719 03fe 1433     		add	r3, r3, #20
 720 0400 0022     		mov	r2, #0
 721 0402 1A80     		strh	r2, [r3]
 722 0404 0DE0     		b	.L43
 723              	.L46:
 301:../Sources/system/CrystalClock.c ****   {
 302:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 724              		.loc 1 302 0
 725 0406 4D4B     		ldr	r3, .L66
 726 0408 9B79     		ldrb	r3, [r3, #6]
 727 040a DBB2     		uxtb	r3, r3
 728 040c 1A1C     		mov	r2, r3
 729 040e 2023     		mov	r3, #32
 730 0410 1340     		and	r3, r2
 731 0412 0ED1     		bne	.L61
 732              	.L44:
 300:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 733              		.loc 1 300 0
 734 0414 3B1C     		mov	r3, r7
 735 0416 1433     		add	r3, r3, #20
 736 0418 3A1C     		mov	r2, r7
 737 041a 1432     		add	r2, r2, #20
 738 041c 1288     		ldrh	r2, [r2]
 739 041e 0132     		add	r2, r2, #1
 740 0420 1A80     		strh	r2, [r3]
 741              	.L43:
 300:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 742              		.loc 1 300 0 is_stmt 0
 743 0422 3B1C     		mov	r3, r7
 744 0424 1433     		add	r3, r3, #20
 745 0426 0021     		mov	r1, #0
 746 0428 5A5E     		ldrsh	r2, [r3, r1]
 747 042a 454B     		ldr	r3, .L66+4
 748 042c 9A42     		cmp	r2, r3
 749 042e EADD     		ble	.L46
 750 0430 00E0     		b	.L45
 751              	.L61:
 752              		.loc 1 302 0 is_stmt 1
 753 0432 C046     		mov	r8, r8
 754              	.L45:
 303:../Sources/system/CrystalClock.c ****   }
 304:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 755              		.loc 1 304 0
 756 0434 414B     		ldr	r3, .L66
 757 0436 9B79     		ldrb	r3, [r3, #6]
 758 0438 DBB2     		uxtb	r3, r3
 759 043a 1A1C     		mov	r2, r3
 760 043c 2023     		mov	r3, #32
 761 043e 1340     		and	r3, r2
 762 0440 01D1     		bne	.L47
 763              		.loc 1 304 0 is_stmt 0
 764 0442 1623     		mov	r3, #22
 765 0444 75E0     		b	.L7
 766              	.L47:
 305:../Sources/system/CrystalClock.c **** 
 306:../Sources/system/CrystalClock.c ****   // Wait for LOCK bit to set
 307:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 4000 ; i++)
 767              		.loc 1 307 0 is_stmt 1
 768 0446 3B1C     		mov	r3, r7
 769 0448 1433     		add	r3, r3, #20
 770 044a 0022     		mov	r2, #0
 771 044c 1A80     		strh	r2, [r3]
 772 044e 0DE0     		b	.L48
 773              	.L51:
 308:../Sources/system/CrystalClock.c ****   {
 309:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 774              		.loc 1 309 0
 775 0450 3A4B     		ldr	r3, .L66
 776 0452 9B79     		ldrb	r3, [r3, #6]
 777 0454 DBB2     		uxtb	r3, r3
 778 0456 1A1C     		mov	r2, r3
 779 0458 4023     		mov	r3, #64
 780 045a 1340     		and	r3, r2
 781 045c 0ED1     		bne	.L62
 782              	.L49:
 307:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 4000 ; i++)
 783              		.loc 1 307 0
 784 045e 3B1C     		mov	r3, r7
 785 0460 1433     		add	r3, r3, #20
 786 0462 3A1C     		mov	r2, r7
 787 0464 1432     		add	r2, r2, #20
 788 0466 1288     		ldrh	r2, [r2]
 789 0468 0132     		add	r2, r2, #1
 790 046a 1A80     		strh	r2, [r3]
 791              	.L48:
 307:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 4000 ; i++)
 792              		.loc 1 307 0 is_stmt 0
 793 046c 3B1C     		mov	r3, r7
 794 046e 1433     		add	r3, r3, #20
 795 0470 0021     		mov	r1, #0
 796 0472 5A5E     		ldrsh	r2, [r3, r1]
 797 0474 334B     		ldr	r3, .L66+8
 798 0476 9A42     		cmp	r2, r3
 799 0478 EADD     		ble	.L51
 800 047a 00E0     		b	.L50
 801              	.L62:
 802              		.loc 1 309 0 is_stmt 1
 803 047c C046     		mov	r8, r8
 804              	.L50:
 310:../Sources/system/CrystalClock.c ****   }
 311:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 805              		.loc 1 311 0
 806 047e 2F4B     		ldr	r3, .L66
 807 0480 9B79     		ldrb	r3, [r3, #6]
 808 0482 DBB2     		uxtb	r3, r3
 809 0484 1A1C     		mov	r2, r3
 810 0486 4023     		mov	r3, #64
 811 0488 1340     		and	r3, r2
 812 048a 01D1     		bne	.L52
 813              		.loc 1 311 0 is_stmt 0
 814 048c 4423     		mov	r3, #68
 815 048e 50E0     		b	.L7
 816              	.L52:
 312:../Sources/system/CrystalClock.c **** 
 313:../Sources/system/CrystalClock.c ****   // Use actual PLL settings to calculate PLL frequency
 314:../Sources/system/CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 817              		.loc 1 314 0 is_stmt 1
 818 0490 2A4B     		ldr	r3, .L66
 819 0492 1B79     		ldrb	r3, [r3, #4]
 820 0494 DAB2     		uxtb	r2, r3
 821 0496 1F23     		mov	r3, #31
 822 0498 1340     		and	r3, r2
 823 049a DAB2     		uxtb	r2, r3
 824 049c 3B1C     		mov	r3, r7
 825 049e 0B33     		add	r3, r3, #11
 826 04a0 0132     		add	r2, r2, #1
 827 04a2 1A70     		strb	r2, [r3]
 315:../Sources/system/CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 828              		.loc 1 315 0
 829 04a4 254B     		ldr	r3, .L66
 830 04a6 5B79     		ldrb	r3, [r3, #5]
 831 04a8 DAB2     		uxtb	r2, r3
 832 04aa 1F23     		mov	r3, #31
 833 04ac 1340     		and	r3, r2
 834 04ae DAB2     		uxtb	r2, r3
 835 04b0 3B1C     		mov	r3, r7
 836 04b2 0A33     		add	r3, r3, #10
 837 04b4 1832     		add	r2, r2, #24
 838 04b6 1A70     		strb	r2, [r3]
 316:../Sources/system/CrystalClock.c **** 
 317:../Sources/system/CrystalClock.c ****   // now in PBE
 318:../Sources/system/CrystalClock.c **** 
 319:../Sources/system/CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 839              		.loc 1 319 0
 840 04b8 204B     		ldr	r3, .L66
 841 04ba 204A     		ldr	r2, .L66
 842 04bc 1278     		ldrb	r2, [r2]
 843 04be D1B2     		uxtb	r1, r2
 844 04c0 3F22     		mov	r2, #63
 845 04c2 0A40     		and	r2, r1
 846 04c4 D2B2     		uxtb	r2, r2
 847 04c6 1A70     		strb	r2, [r3]
 320:../Sources/system/CrystalClock.c **** 
 321:../Sources/system/CrystalClock.c ****   // Wait for clock status bits to update
 322:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 848              		.loc 1 322 0
 849 04c8 3B1C     		mov	r3, r7
 850 04ca 1433     		add	r3, r3, #20
 851 04cc 0022     		mov	r2, #0
 852 04ce 1A80     		strh	r2, [r3]
 853 04d0 0FE0     		b	.L53
 854              	.L56:
 323:../Sources/system/CrystalClock.c ****   {
 324:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 855              		.loc 1 324 0
 856 04d2 1A4B     		ldr	r3, .L66
 857 04d4 9B79     		ldrb	r3, [r3, #6]
 858 04d6 DBB2     		uxtb	r3, r3
 859 04d8 1A1C     		mov	r2, r3
 860 04da 0C23     		mov	r3, #12
 861 04dc 1340     		and	r3, r2
 862 04de 9B08     		lsr	r3, r3, #2
 863 04e0 032B     		cmp	r3, #3
 864 04e2 0ED0     		beq	.L63
 865              	.L54:
 322:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 866              		.loc 1 322 0
 867 04e4 3B1C     		mov	r3, r7
 868 04e6 1433     		add	r3, r3, #20
 869 04e8 3A1C     		mov	r2, r7
 870 04ea 1432     		add	r2, r2, #20
 871 04ec 1288     		ldrh	r2, [r2]
 872 04ee 0132     		add	r2, r2, #1
 873 04f0 1A80     		strh	r2, [r3]
 874              	.L53:
 322:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 875              		.loc 1 322 0 is_stmt 0
 876 04f2 3B1C     		mov	r3, r7
 877 04f4 1433     		add	r3, r3, #20
 878 04f6 0021     		mov	r1, #0
 879 04f8 5A5E     		ldrsh	r2, [r3, r1]
 880 04fa 114B     		ldr	r3, .L66+4
 881 04fc 9A42     		cmp	r2, r3
 882 04fe E8DD     		ble	.L56
 883 0500 00E0     		b	.L55
 884              	.L63:
 885              		.loc 1 324 0 is_stmt 1
 886 0502 C046     		mov	r8, r8
 887              	.L55:
 325:../Sources/system/CrystalClock.c ****   }
 326:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 888              		.loc 1 326 0
 889 0504 0D4B     		ldr	r3, .L66
 890 0506 9B79     		ldrb	r3, [r3, #6]
 891 0508 DBB2     		uxtb	r3, r3
 892 050a 1A1C     		mov	r2, r3
 893 050c 0C23     		mov	r3, #12
 894 050e 1340     		and	r3, r2
 895 0510 9B08     		lsr	r3, r3, #2
 896 0512 032B     		cmp	r3, #3
 897 0514 01D0     		beq	.L57
 898              		.loc 1 326 0 is_stmt 0
 899 0516 1B23     		mov	r3, #27
 900 0518 0BE0     		b	.L7
 901              	.L57:
 327:../Sources/system/CrystalClock.c **** 
 328:../Sources/system/CrystalClock.c ****   // Now in PEE
 329:../Sources/system/CrystalClock.c ****   
 330:../Sources/system/CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 902              		.loc 1 330 0 is_stmt 1
 903 051a 3B1C     		mov	r3, r7
 904 051c 0B33     		add	r3, r3, #11
 905 051e 1B78     		ldrb	r3, [r3]
 906 0520 7868     		ldr	r0, [r7, #4]
 907 0522 191C     		mov	r1, r3
 908 0524 FFF7FEFF 		bl	__aeabi_idiv
 909 0528 031C     		mov	r3, r0
 910 052a 3A1C     		mov	r2, r7
 911 052c 0A32     		add	r2, r2, #10
 912 052e 1278     		ldrb	r2, [r2]
 913 0530 5343     		mul	r3, r2
 914              	.L7:
 331:../Sources/system/CrystalClock.c **** } // pll_init
 915              		.loc 1 331 0
 916 0532 181C     		mov	r0, r3
 917 0534 BD46     		mov	sp, r7
 918 0536 06B0     		add	sp, sp, #24
 919              		@ sp needed for prologue
 920 0538 80BD     		pop	{r7, pc}
 921              	.L67:
 922 053a C046     		.align	2
 923              	.L66:
 924 053c 00400640 		.word	1074151424
 925 0540 CF070000 		.word	1999
 926 0544 9F0F0000 		.word	3999
 927              		.cfi_endproc
 928              	.LFE1:
 930              		.section	.text.pee_pbe,"ax",%progbits
 931              		.align	2
 932              		.global	pee_pbe
 933              		.code	16
 934              		.thumb_func
 936              	pee_pbe:
 937              	.LFB2:
 332:../Sources/system/CrystalClock.c **** 
 333:../Sources/system/CrystalClock.c **** 
 334:../Sources/system/CrystalClock.c **** 
 335:../Sources/system/CrystalClock.c **** 
 336:../Sources/system/CrystalClock.c **** /********************************************************************/
 337:../Sources/system/CrystalClock.c **** 
 338:../Sources/system/CrystalClock.c **** int pee_pbe(int crystal_val)
 339:../Sources/system/CrystalClock.c **** {
 938              		.loc 1 339 0
 939              		.cfi_startproc
 940 0000 80B5     		push	{r7, lr}
 941              	.LCFI6:
 942              		.cfi_def_cfa_offset 8
 943              		.cfi_offset 7, -8
 944              		.cfi_offset 14, -4
 945 0002 84B0     		sub	sp, sp, #16
 946              	.LCFI7:
 947              		.cfi_def_cfa_offset 24
 948 0004 00AF     		add	r7, sp, #0
 949              	.LCFI8:
 950              		.cfi_def_cfa_register 7
 951 0006 7860     		str	r0, [r7, #4]
 340:../Sources/system/CrystalClock.c ****   short i;
 341:../Sources/system/CrystalClock.c ****   
 342:../Sources/system/CrystalClock.c **** // Check MCG is in PEE mode
 343:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 952              		.loc 1 343 0
 953 0008 274B     		ldr	r3, .L78
 954 000a 9B79     		ldrb	r3, [r3, #6]
 955 000c DBB2     		uxtb	r3, r3
 956 000e 1A1C     		mov	r2, r3
 957 0010 0C23     		mov	r3, #12
 958 0012 1340     		and	r3, r2
 959 0014 9B08     		lsr	r3, r3, #2
 960 0016 032B     		cmp	r3, #3
 961 0018 0DD1     		bne	.L69
 344:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 962              		.loc 1 344 0
 963 001a 234B     		ldr	r3, .L78
 964 001c 9B79     		ldrb	r3, [r3, #6]
 965 001e DBB2     		uxtb	r3, r3
 966 0020 1A1C     		mov	r2, r3
 967 0022 1023     		mov	r3, #16
 968 0024 1340     		and	r3, r2
 343:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 969              		.loc 1 343 0
 970 0026 06D1     		bne	.L69
 345:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 971              		.loc 1 345 0
 972 0028 1F4B     		ldr	r3, .L78
 973 002a 9B79     		ldrb	r3, [r3, #6]
 974 002c DBB2     		uxtb	r3, r3
 975 002e 1A1C     		mov	r2, r3
 976 0030 2023     		mov	r3, #32
 977 0032 1340     		and	r3, r2
 343:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 978              		.loc 1 343 0
 979 0034 01D1     		bne	.L70
 980              	.L69:
 346:../Sources/system/CrystalClock.c ****   {
 347:../Sources/system/CrystalClock.c ****     return 0x8;                                                       // return error code
 981              		.loc 1 347 0
 982 0036 0823     		mov	r3, #8
 983 0038 32E0     		b	.L71
 984              	.L70:
 348:../Sources/system/CrystalClock.c ****   } 
 349:../Sources/system/CrystalClock.c ****   
 350:../Sources/system/CrystalClock.c **** // As we are running from the PLL by default the PLL and external clock settings are valid
 351:../Sources/system/CrystalClock.c **** // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext clock 
 352:../Sources/system/CrystalClock.c **** // As CLKS is already 0 the CLKS value can simply be OR'ed into the register 
 353:../Sources/system/CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 985              		.loc 1 353 0
 986 003a 1B4B     		ldr	r3, .L78
 987 003c 1A4A     		ldr	r2, .L78
 988 003e 1278     		ldrb	r2, [r2]
 989 0040 D2B2     		uxtb	r2, r2
 990 0042 8021     		mov	r1, #128
 991 0044 4942     		neg	r1, r1
 992 0046 0A43     		orr	r2, r1
 993 0048 D2B2     		uxtb	r2, r2
 994 004a 1A70     		strb	r2, [r3]
 354:../Sources/system/CrystalClock.c ****   
 355:../Sources/system/CrystalClock.c **** // Wait for clock status bits to update 
 356:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 995              		.loc 1 356 0
 996 004c 3B1C     		mov	r3, r7
 997 004e 0E33     		add	r3, r3, #14
 998 0050 0022     		mov	r2, #0
 999 0052 1A80     		strh	r2, [r3]
 1000 0054 0FE0     		b	.L72
 1001              	.L75:
 357:../Sources/system/CrystalClock.c ****   {
 358:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 1002              		.loc 1 358 0
 1003 0056 144B     		ldr	r3, .L78
 1004 0058 9B79     		ldrb	r3, [r3, #6]
 1005 005a DBB2     		uxtb	r3, r3
 1006 005c 1A1C     		mov	r2, r3
 1007 005e 0C23     		mov	r3, #12
 1008 0060 1340     		and	r3, r2
 1009 0062 9B08     		lsr	r3, r3, #2
 1010 0064 022B     		cmp	r3, #2
 1011 0066 0ED0     		beq	.L77
 1012              	.L73:
 356:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1013              		.loc 1 356 0
 1014 0068 3B1C     		mov	r3, r7
 1015 006a 0E33     		add	r3, r3, #14
 1016 006c 3A1C     		mov	r2, r7
 1017 006e 0E32     		add	r2, r2, #14
 1018 0070 1288     		ldrh	r2, [r2]
 1019 0072 0132     		add	r2, r2, #1
 1020 0074 1A80     		strh	r2, [r3]
 1021              	.L72:
 356:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1022              		.loc 1 356 0 is_stmt 0
 1023 0076 3B1C     		mov	r3, r7
 1024 0078 0E33     		add	r3, r3, #14
 1025 007a 0021     		mov	r1, #0
 1026 007c 5A5E     		ldrsh	r2, [r3, r1]
 1027 007e 0B4B     		ldr	r3, .L78+4
 1028 0080 9A42     		cmp	r2, r3
 1029 0082 E8DD     		ble	.L75
 1030 0084 00E0     		b	.L74
 1031              	.L77:
 1032              		.loc 1 358 0 is_stmt 1
 1033 0086 C046     		mov	r8, r8
 1034              	.L74:
 359:../Sources/system/CrystalClock.c ****   }
 360:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 1035              		.loc 1 360 0
 1036 0088 074B     		ldr	r3, .L78
 1037 008a 9B79     		ldrb	r3, [r3, #6]
 1038 008c DBB2     		uxtb	r3, r3
 1039 008e 1A1C     		mov	r2, r3
 1040 0090 0C23     		mov	r3, #12
 1041 0092 1340     		and	r3, r2
 1042 0094 9B08     		lsr	r3, r3, #2
 1043 0096 022B     		cmp	r3, #2
 1044 0098 01D0     		beq	.L76
 1045              		.loc 1 360 0 is_stmt 0
 1046 009a 1A23     		mov	r3, #26
 1047 009c 00E0     		b	.L71
 1048              	.L76:
 361:../Sources/system/CrystalClock.c **** 
 362:../Sources/system/CrystalClock.c **** // Now in PBE mode  
 363:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 1049              		.loc 1 363 0 is_stmt 1
 1050 009e 7B68     		ldr	r3, [r7, #4]
 1051              	.L71:
 364:../Sources/system/CrystalClock.c **** } // pee_pbe
 1052              		.loc 1 364 0
 1053 00a0 181C     		mov	r0, r3
 1054 00a2 BD46     		mov	sp, r7
 1055 00a4 04B0     		add	sp, sp, #16
 1056              		@ sp needed for prologue
 1057 00a6 80BD     		pop	{r7, pc}
 1058              	.L79:
 1059              		.align	2
 1060              	.L78:
 1061 00a8 00400640 		.word	1074151424
 1062 00ac CF070000 		.word	1999
 1063              		.cfi_endproc
 1064              	.LFE2:
 1066              		.section	.text.pbe_pee,"ax",%progbits
 1067              		.align	2
 1068              		.global	pbe_pee
 1069              		.code	16
 1070              		.thumb_func
 1072              	pbe_pee:
 1073              	.LFB3:
 365:../Sources/system/CrystalClock.c **** 
 366:../Sources/system/CrystalClock.c **** 
 367:../Sources/system/CrystalClock.c **** int pbe_pee(int crystal_val)
 368:../Sources/system/CrystalClock.c **** {
 1074              		.loc 1 368 0
 1075              		.cfi_startproc
 1076 0000 80B5     		push	{r7, lr}
 1077              	.LCFI9:
 1078              		.cfi_def_cfa_offset 8
 1079              		.cfi_offset 7, -8
 1080              		.cfi_offset 14, -4
 1081 0002 84B0     		sub	sp, sp, #16
 1082              	.LCFI10:
 1083              		.cfi_def_cfa_offset 24
 1084 0004 00AF     		add	r7, sp, #0
 1085              	.LCFI11:
 1086              		.cfi_def_cfa_register 7
 1087 0006 7860     		str	r0, [r7, #4]
 369:../Sources/system/CrystalClock.c ****   unsigned char prdiv, vdiv;
 370:../Sources/system/CrystalClock.c ****   short i;
 371:../Sources/system/CrystalClock.c **** 
 372:../Sources/system/CrystalClock.c ****   // Check MCG is in PBE mode
 373:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1088              		.loc 1 373 0
 1089 0008 4C4B     		ldr	r3, .L96
 1090 000a 9B79     		ldrb	r3, [r3, #6]
 1091 000c DBB2     		uxtb	r3, r3
 1092 000e 1A1C     		mov	r2, r3
 1093 0010 0C23     		mov	r3, #12
 1094 0012 1340     		and	r3, r2
 1095 0014 9B08     		lsr	r3, r3, #2
 1096 0016 022B     		cmp	r3, #2
 1097 0018 14D1     		bne	.L81
 374:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1098              		.loc 1 374 0
 1099 001a 484B     		ldr	r3, .L96
 1100 001c 9B79     		ldrb	r3, [r3, #6]
 1101 001e DBB2     		uxtb	r3, r3
 1102 0020 1A1C     		mov	r2, r3
 1103 0022 1023     		mov	r3, #16
 1104 0024 1340     		and	r3, r2
 373:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1105              		.loc 1 373 0
 1106 0026 0DD1     		bne	.L81
 375:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1107              		.loc 1 375 0
 1108 0028 444B     		ldr	r3, .L96
 1109 002a 9B79     		ldrb	r3, [r3, #6]
 1110 002c DBB2     		uxtb	r3, r3
 1111 002e 1A1C     		mov	r2, r3
 1112 0030 2023     		mov	r3, #32
 1113 0032 1340     		and	r3, r2
 374:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1114              		.loc 1 374 0
 1115 0034 06D0     		beq	.L81
 376:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1116              		.loc 1 376 0
 1117 0036 414B     		ldr	r3, .L96
 1118 0038 5B78     		ldrb	r3, [r3, #1]
 1119 003a DBB2     		uxtb	r3, r3
 1120 003c 1A1C     		mov	r2, r3
 1121 003e 0223     		mov	r3, #2
 1122 0040 1340     		and	r3, r2
 373:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1123              		.loc 1 373 0
 1124 0042 01D0     		beq	.L82
 1125              	.L81:
 377:../Sources/system/CrystalClock.c ****   {
 378:../Sources/system/CrystalClock.c ****     return 0x7;                                                       // return error code
 1126              		.loc 1 378 0
 1127 0044 0723     		mov	r3, #7
 1128 0046 75E0     		b	.L83
 1129              	.L82:
 379:../Sources/system/CrystalClock.c ****   }
 380:../Sources/system/CrystalClock.c **** 
 381:../Sources/system/CrystalClock.c ****   // As the PLL settings have already been checked when PBE mode was enterred they are not checked 
 382:../Sources/system/CrystalClock.c **** 
 383:../Sources/system/CrystalClock.c ****   // Check the PLL state before transitioning to PEE mode
 384:../Sources/system/CrystalClock.c ****   
 385:../Sources/system/CrystalClock.c ****   // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but g
 386:../Sources/system/CrystalClock.c ****   // to re-check before switch to use PLL)
 387:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1130              		.loc 1 387 0
 1131 0048 3B1C     		mov	r3, r7
 1132 004a 0E33     		add	r3, r3, #14
 1133 004c 0022     		mov	r2, #0
 1134 004e 1A80     		strh	r2, [r3]
 1135 0050 0DE0     		b	.L84
 1136              	.L87:
 388:../Sources/system/CrystalClock.c ****   {
 389:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1137              		.loc 1 389 0
 1138 0052 3A4B     		ldr	r3, .L96
 1139 0054 9B79     		ldrb	r3, [r3, #6]
 1140 0056 DBB2     		uxtb	r3, r3
 1141 0058 1A1C     		mov	r2, r3
 1142 005a 4023     		mov	r3, #64
 1143 005c 1340     		and	r3, r2
 1144 005e 0ED1     		bne	.L94
 1145              	.L85:
 387:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1146              		.loc 1 387 0
 1147 0060 3B1C     		mov	r3, r7
 1148 0062 0E33     		add	r3, r3, #14
 1149 0064 3A1C     		mov	r2, r7
 1150 0066 0E32     		add	r2, r2, #14
 1151 0068 1288     		ldrh	r2, [r2]
 1152 006a 0132     		add	r2, r2, #1
 1153 006c 1A80     		strh	r2, [r3]
 1154              	.L84:
 387:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1155              		.loc 1 387 0 is_stmt 0
 1156 006e 3B1C     		mov	r3, r7
 1157 0070 0E33     		add	r3, r3, #14
 1158 0072 0021     		mov	r1, #0
 1159 0074 5A5E     		ldrsh	r2, [r3, r1]
 1160 0076 324B     		ldr	r3, .L96+4
 1161 0078 9A42     		cmp	r2, r3
 1162 007a EADD     		ble	.L87
 1163 007c 00E0     		b	.L86
 1164              	.L94:
 1165              		.loc 1 389 0 is_stmt 1
 1166 007e C046     		mov	r8, r8
 1167              	.L86:
 390:../Sources/system/CrystalClock.c ****   }
 391:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1168              		.loc 1 391 0
 1169 0080 2E4B     		ldr	r3, .L96
 1170 0082 9B79     		ldrb	r3, [r3, #6]
 1171 0084 DBB2     		uxtb	r3, r3
 1172 0086 1A1C     		mov	r2, r3
 1173 0088 4023     		mov	r3, #64
 1174 008a 1340     		and	r3, r2
 1175 008c 01D1     		bne	.L88
 1176              		.loc 1 391 0 is_stmt 0
 1177 008e 4423     		mov	r3, #68
 1178 0090 50E0     		b	.L83
 1179              	.L88:
 392:../Sources/system/CrystalClock.c ****   // Use actual PLL settings to calculate PLL frequency
 393:../Sources/system/CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1180              		.loc 1 393 0 is_stmt 1
 1181 0092 2A4B     		ldr	r3, .L96
 1182 0094 1B79     		ldrb	r3, [r3, #4]
 1183 0096 DAB2     		uxtb	r2, r3
 1184 0098 1F23     		mov	r3, #31
 1185 009a 1340     		and	r3, r2
 1186 009c DAB2     		uxtb	r2, r3
 1187 009e 3B1C     		mov	r3, r7
 1188 00a0 0D33     		add	r3, r3, #13
 1189 00a2 0132     		add	r2, r2, #1
 1190 00a4 1A70     		strb	r2, [r3]
 394:../Sources/system/CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1191              		.loc 1 394 0
 1192 00a6 254B     		ldr	r3, .L96
 1193 00a8 5B79     		ldrb	r3, [r3, #5]
 1194 00aa DAB2     		uxtb	r2, r3
 1195 00ac 1F23     		mov	r3, #31
 1196 00ae 1340     		and	r3, r2
 1197 00b0 DAB2     		uxtb	r2, r3
 1198 00b2 3B1C     		mov	r3, r7
 1199 00b4 0C33     		add	r3, r3, #12
 1200 00b6 1832     		add	r2, r2, #24
 1201 00b8 1A70     		strb	r2, [r3]
 395:../Sources/system/CrystalClock.c ****   
 396:../Sources/system/CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 1202              		.loc 1 396 0
 1203 00ba 204B     		ldr	r3, .L96
 1204 00bc 1F4A     		ldr	r2, .L96
 1205 00be 1278     		ldrb	r2, [r2]
 1206 00c0 D1B2     		uxtb	r1, r2
 1207 00c2 3F22     		mov	r2, #63
 1208 00c4 0A40     		and	r2, r1
 1209 00c6 D2B2     		uxtb	r2, r2
 1210 00c8 1A70     		strb	r2, [r3]
 397:../Sources/system/CrystalClock.c **** 
 398:../Sources/system/CrystalClock.c ****   // Wait for clock status bits to update
 399:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1211              		.loc 1 399 0
 1212 00ca 3B1C     		mov	r3, r7
 1213 00cc 0E33     		add	r3, r3, #14
 1214 00ce 0022     		mov	r2, #0
 1215 00d0 1A80     		strh	r2, [r3]
 1216 00d2 0FE0     		b	.L89
 1217              	.L92:
 400:../Sources/system/CrystalClock.c ****   {
 401:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 1218              		.loc 1 401 0
 1219 00d4 194B     		ldr	r3, .L96
 1220 00d6 9B79     		ldrb	r3, [r3, #6]
 1221 00d8 DBB2     		uxtb	r3, r3
 1222 00da 1A1C     		mov	r2, r3
 1223 00dc 0C23     		mov	r3, #12
 1224 00de 1340     		and	r3, r2
 1225 00e0 9B08     		lsr	r3, r3, #2
 1226 00e2 032B     		cmp	r3, #3
 1227 00e4 0ED0     		beq	.L95
 1228              	.L90:
 399:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1229              		.loc 1 399 0
 1230 00e6 3B1C     		mov	r3, r7
 1231 00e8 0E33     		add	r3, r3, #14
 1232 00ea 3A1C     		mov	r2, r7
 1233 00ec 0E32     		add	r2, r2, #14
 1234 00ee 1288     		ldrh	r2, [r2]
 1235 00f0 0132     		add	r2, r2, #1
 1236 00f2 1A80     		strh	r2, [r3]
 1237              	.L89:
 399:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1238              		.loc 1 399 0 is_stmt 0
 1239 00f4 3B1C     		mov	r3, r7
 1240 00f6 0E33     		add	r3, r3, #14
 1241 00f8 0021     		mov	r1, #0
 1242 00fa 5A5E     		ldrsh	r2, [r3, r1]
 1243 00fc 104B     		ldr	r3, .L96+4
 1244 00fe 9A42     		cmp	r2, r3
 1245 0100 E8DD     		ble	.L92
 1246 0102 00E0     		b	.L91
 1247              	.L95:
 1248              		.loc 1 401 0 is_stmt 1
 1249 0104 C046     		mov	r8, r8
 1250              	.L91:
 402:../Sources/system/CrystalClock.c ****   }
 403:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 1251              		.loc 1 403 0
 1252 0106 0D4B     		ldr	r3, .L96
 1253 0108 9B79     		ldrb	r3, [r3, #6]
 1254 010a DBB2     		uxtb	r3, r3
 1255 010c 1A1C     		mov	r2, r3
 1256 010e 0C23     		mov	r3, #12
 1257 0110 1340     		and	r3, r2
 1258 0112 9B08     		lsr	r3, r3, #2
 1259 0114 032B     		cmp	r3, #3
 1260 0116 01D0     		beq	.L93
 1261              		.loc 1 403 0 is_stmt 0
 1262 0118 1B23     		mov	r3, #27
 1263 011a 0BE0     		b	.L83
 1264              	.L93:
 404:../Sources/system/CrystalClock.c **** 
 405:../Sources/system/CrystalClock.c ****   // Now in PEE
 406:../Sources/system/CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1265              		.loc 1 406 0 is_stmt 1
 1266 011c 3B1C     		mov	r3, r7
 1267 011e 0D33     		add	r3, r3, #13
 1268 0120 1B78     		ldrb	r3, [r3]
 1269 0122 7868     		ldr	r0, [r7, #4]
 1270 0124 191C     		mov	r1, r3
 1271 0126 FFF7FEFF 		bl	__aeabi_idiv
 1272 012a 031C     		mov	r3, r0
 1273 012c 3A1C     		mov	r2, r7
 1274 012e 0C32     		add	r2, r2, #12
 1275 0130 1278     		ldrb	r2, [r2]
 1276 0132 5343     		mul	r3, r2
 1277              	.L83:
 407:../Sources/system/CrystalClock.c ****   
 408:../Sources/system/CrystalClock.c **** }  // pbe_pee
 1278              		.loc 1 408 0
 1279 0134 181C     		mov	r0, r3
 1280 0136 BD46     		mov	sp, r7
 1281 0138 04B0     		add	sp, sp, #16
 1282              		@ sp needed for prologue
 1283 013a 80BD     		pop	{r7, pc}
 1284              	.L97:
 1285              		.align	2
 1286              	.L96:
 1287 013c 00400640 		.word	1074151424
 1288 0140 CF070000 		.word	1999
 1289              		.cfi_endproc
 1290              	.LFE3:
 1292              		.section	.text.pbe_fbe,"ax",%progbits
 1293              		.align	2
 1294              		.global	pbe_fbe
 1295              		.code	16
 1296              		.thumb_func
 1298              	pbe_fbe:
 1299              	.LFB4:
 409:../Sources/system/CrystalClock.c **** 
 410:../Sources/system/CrystalClock.c **** 
 411:../Sources/system/CrystalClock.c **** int pbe_fbe(int crystal_val)
 412:../Sources/system/CrystalClock.c **** {
 1300              		.loc 1 412 0
 1301              		.cfi_startproc
 1302 0000 80B5     		push	{r7, lr}
 1303              	.LCFI12:
 1304              		.cfi_def_cfa_offset 8
 1305              		.cfi_offset 7, -8
 1306              		.cfi_offset 14, -4
 1307 0002 84B0     		sub	sp, sp, #16
 1308              	.LCFI13:
 1309              		.cfi_def_cfa_offset 24
 1310 0004 00AF     		add	r7, sp, #0
 1311              	.LCFI14:
 1312              		.cfi_def_cfa_register 7
 1313 0006 7860     		str	r0, [r7, #4]
 413:../Sources/system/CrystalClock.c ****   short i;
 414:../Sources/system/CrystalClock.c ****   
 415:../Sources/system/CrystalClock.c **** // Check MCG is in PBE mode
 416:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1314              		.loc 1 416 0
 1315 0008 284B     		ldr	r3, .L108
 1316 000a 9B79     		ldrb	r3, [r3, #6]
 1317 000c DBB2     		uxtb	r3, r3
 1318 000e 1A1C     		mov	r2, r3
 1319 0010 0C23     		mov	r3, #12
 1320 0012 1340     		and	r3, r2
 1321 0014 9B08     		lsr	r3, r3, #2
 1322 0016 022B     		cmp	r3, #2
 1323 0018 14D1     		bne	.L99
 417:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1324              		.loc 1 417 0
 1325 001a 244B     		ldr	r3, .L108
 1326 001c 9B79     		ldrb	r3, [r3, #6]
 1327 001e DBB2     		uxtb	r3, r3
 1328 0020 1A1C     		mov	r2, r3
 1329 0022 1023     		mov	r3, #16
 1330 0024 1340     		and	r3, r2
 416:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1331              		.loc 1 416 0
 1332 0026 0DD1     		bne	.L99
 418:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1333              		.loc 1 418 0
 1334 0028 204B     		ldr	r3, .L108
 1335 002a 9B79     		ldrb	r3, [r3, #6]
 1336 002c DBB2     		uxtb	r3, r3
 1337 002e 1A1C     		mov	r2, r3
 1338 0030 2023     		mov	r3, #32
 1339 0032 1340     		and	r3, r2
 417:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1340              		.loc 1 417 0
 1341 0034 06D0     		beq	.L99
 419:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1342              		.loc 1 419 0
 1343 0036 1D4B     		ldr	r3, .L108
 1344 0038 5B78     		ldrb	r3, [r3, #1]
 1345 003a DBB2     		uxtb	r3, r3
 1346 003c 1A1C     		mov	r2, r3
 1347 003e 0223     		mov	r3, #2
 1348 0040 1340     		and	r3, r2
 416:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1349              		.loc 1 416 0
 1350 0042 01D0     		beq	.L100
 1351              	.L99:
 420:../Sources/system/CrystalClock.c ****   {
 421:../Sources/system/CrystalClock.c ****     return 0x7;                                                       // return error code
 1352              		.loc 1 421 0
 1353 0044 0723     		mov	r3, #7
 1354 0046 2DE0     		b	.L101
 1355              	.L100:
 422:../Sources/system/CrystalClock.c ****   }
 423:../Sources/system/CrystalClock.c **** 
 424:../Sources/system/CrystalClock.c **** // As we are running from the ext clock, by default the external clock settings are valid
 425:../Sources/system/CrystalClock.c **** // To move to FBE from PBE simply requires the switching of the PLLS mux to disable the PLL 
 426:../Sources/system/CrystalClock.c ****   
 427:../Sources/system/CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 1356              		.loc 1 427 0
 1357 0048 184B     		ldr	r3, .L108
 1358 004a 184A     		ldr	r2, .L108
 1359 004c 5279     		ldrb	r2, [r2, #5]
 1360 004e D2B2     		uxtb	r2, r2
 1361 0050 4021     		mov	r1, #64
 1362 0052 8A43     		bic	r2, r1
 1363 0054 D2B2     		uxtb	r2, r2
 1364 0056 5A71     		strb	r2, [r3, #5]
 428:../Sources/system/CrystalClock.c ****   
 429:../Sources/system/CrystalClock.c **** // wait for PLLST status bit to set
 430:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1365              		.loc 1 430 0
 1366 0058 3B1C     		mov	r3, r7
 1367 005a 0E33     		add	r3, r3, #14
 1368 005c 0022     		mov	r2, #0
 1369 005e 1A80     		strh	r2, [r3]
 1370 0060 0DE0     		b	.L102
 1371              	.L105:
 431:../Sources/system/CrystalClock.c ****   {
 432:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1372              		.loc 1 432 0
 1373 0062 124B     		ldr	r3, .L108
 1374 0064 9B79     		ldrb	r3, [r3, #6]
 1375 0066 DBB2     		uxtb	r3, r3
 1376 0068 1A1C     		mov	r2, r3
 1377 006a 2023     		mov	r3, #32
 1378 006c 1340     		and	r3, r2
 1379 006e 0ED0     		beq	.L107
 1380              	.L103:
 430:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1381              		.loc 1 430 0
 1382 0070 3B1C     		mov	r3, r7
 1383 0072 0E33     		add	r3, r3, #14
 1384 0074 3A1C     		mov	r2, r7
 1385 0076 0E32     		add	r2, r2, #14
 1386 0078 1288     		ldrh	r2, [r2]
 1387 007a 0132     		add	r2, r2, #1
 1388 007c 1A80     		strh	r2, [r3]
 1389              	.L102:
 430:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1390              		.loc 1 430 0 is_stmt 0
 1391 007e 3B1C     		mov	r3, r7
 1392 0080 0E33     		add	r3, r3, #14
 1393 0082 0021     		mov	r1, #0
 1394 0084 5A5E     		ldrsh	r2, [r3, r1]
 1395 0086 0A4B     		ldr	r3, .L108+4
 1396 0088 9A42     		cmp	r2, r3
 1397 008a EADD     		ble	.L105
 1398 008c 00E0     		b	.L104
 1399              	.L107:
 1400              		.loc 1 432 0 is_stmt 1
 1401 008e C046     		mov	r8, r8
 1402              	.L104:
 433:../Sources/system/CrystalClock.c ****   }
 434:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 1403              		.loc 1 434 0
 1404 0090 064B     		ldr	r3, .L108
 1405 0092 9B79     		ldrb	r3, [r3, #6]
 1406 0094 DBB2     		uxtb	r3, r3
 1407 0096 1A1C     		mov	r2, r3
 1408 0098 2023     		mov	r3, #32
 1409 009a 1340     		and	r3, r2
 1410 009c 01D0     		beq	.L106
 1411              		.loc 1 434 0 is_stmt 0
 1412 009e 1523     		mov	r3, #21
 1413 00a0 00E0     		b	.L101
 1414              	.L106:
 435:../Sources/system/CrystalClock.c **** 
 436:../Sources/system/CrystalClock.c **** // Now in FBE mode  
 437:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency 
 1415              		.loc 1 437 0 is_stmt 1
 1416 00a2 7B68     		ldr	r3, [r7, #4]
 1417              	.L101:
 438:../Sources/system/CrystalClock.c **** } // pbe_fbe
 1418              		.loc 1 438 0
 1419 00a4 181C     		mov	r0, r3
 1420 00a6 BD46     		mov	sp, r7
 1421 00a8 04B0     		add	sp, sp, #16
 1422              		@ sp needed for prologue
 1423 00aa 80BD     		pop	{r7, pc}
 1424              	.L109:
 1425              		.align	2
 1426              	.L108:
 1427 00ac 00400640 		.word	1074151424
 1428 00b0 CF070000 		.word	1999
 1429              		.cfi_endproc
 1430              	.LFE4:
 1432              		.section	.text.fbe_pbe,"ax",%progbits
 1433              		.align	2
 1434              		.global	fbe_pbe
 1435              		.code	16
 1436              		.thumb_func
 1438              	fbe_pbe:
 1439              	.LFB5:
 439:../Sources/system/CrystalClock.c **** 
 440:../Sources/system/CrystalClock.c **** 
 441:../Sources/system/CrystalClock.c **** /********************************************************************/
 442:../Sources/system/CrystalClock.c **** /* Functon name : fbe_pbe
 443:../Sources/system/CrystalClock.c ****  *
 444:../Sources/system/CrystalClock.c ****  * Mode transition: FBE to PBE mode
 445:../Sources/system/CrystalClock.c ****  *
 446:../Sources/system/CrystalClock.c ****  * This function transitions the MCG from FBE mode to PBE mode. 
 447:../Sources/system/CrystalClock.c ****  * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soo
 448:../Sources/system/CrystalClock.c ****  * The function requires the desired OSC and PLL be passed in to it for compatibility with the
 449:../Sources/system/CrystalClock.c ****  * future support of OSC/PLL selection
 450:../Sources/system/CrystalClock.c ****  *
 451:../Sources/system/CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz
 452:../Sources/system/CrystalClock.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 453:../Sources/system/CrystalClock.c ****  *                           PLL reference clock frequency
 454:../Sources/system/CrystalClock.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 455:../Sources/system/CrystalClock.c ****  *
 456:../Sources/system/CrystalClock.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 457:../Sources/system/CrystalClock.c ****  */
 458:../Sources/system/CrystalClock.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 459:../Sources/system/CrystalClock.c **** {
 1440              		.loc 1 459 0
 1441              		.cfi_startproc
 1442 0000 80B5     		push	{r7, lr}
 1443              	.LCFI15:
 1444              		.cfi_def_cfa_offset 8
 1445              		.cfi_offset 7, -8
 1446              		.cfi_offset 14, -4
 1447 0002 86B0     		sub	sp, sp, #24
 1448              	.LCFI16:
 1449              		.cfi_def_cfa_offset 32
 1450 0004 00AF     		add	r7, sp, #0
 1451              	.LCFI17:
 1452              		.cfi_def_cfa_register 7
 1453 0006 7860     		str	r0, [r7, #4]
 1454 0008 FB1C     		add	r3, r7, #3
 1455 000a 1970     		strb	r1, [r3]
 1456 000c BB1C     		add	r3, r7, #2
 1457 000e 1A70     		strb	r2, [r3]
 460:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 461:../Sources/system/CrystalClock.c ****   short i;
 462:../Sources/system/CrystalClock.c ****   int pll_freq;
 463:../Sources/system/CrystalClock.c ****   
 464:../Sources/system/CrystalClock.c **** // Check MCG is in FBE mode
 465:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1458              		.loc 1 465 0
 1459 0010 7D4B     		ldr	r3, .L134
 1460 0012 9B79     		ldrb	r3, [r3, #6]
 1461 0014 DBB2     		uxtb	r3, r3
 1462 0016 1A1C     		mov	r2, r3
 1463 0018 0C23     		mov	r3, #12
 1464 001a 1340     		and	r3, r2
 1465 001c 9B08     		lsr	r3, r3, #2
 1466 001e 022B     		cmp	r3, #2
 1467 0020 14D1     		bne	.L111
 466:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1468              		.loc 1 466 0
 1469 0022 794B     		ldr	r3, .L134
 1470 0024 9B79     		ldrb	r3, [r3, #6]
 1471 0026 DBB2     		uxtb	r3, r3
 1472 0028 1A1C     		mov	r2, r3
 1473 002a 1023     		mov	r3, #16
 1474 002c 1340     		and	r3, r2
 465:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1475              		.loc 1 465 0
 1476 002e 0DD1     		bne	.L111
 467:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 1477              		.loc 1 467 0
 1478 0030 754B     		ldr	r3, .L134
 1479 0032 9B79     		ldrb	r3, [r3, #6]
 1480 0034 DBB2     		uxtb	r3, r3
 1481 0036 1A1C     		mov	r2, r3
 1482 0038 2023     		mov	r3, #32
 1483 003a 1340     		and	r3, r2
 466:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1484              		.loc 1 466 0
 1485 003c 06D1     		bne	.L111
 468:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1486              		.loc 1 468 0
 1487 003e 724B     		ldr	r3, .L134
 1488 0040 5B78     		ldrb	r3, [r3, #1]
 1489 0042 DBB2     		uxtb	r3, r3
 1490 0044 1A1C     		mov	r2, r3
 1491 0046 0223     		mov	r3, #2
 1492 0048 1340     		and	r3, r2
 465:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1493              		.loc 1 465 0
 1494 004a 01D0     		beq	.L112
 1495              	.L111:
 469:../Sources/system/CrystalClock.c ****   {
 470:../Sources/system/CrystalClock.c ****     return 0x4;                                                       // return error code
 1496              		.loc 1 470 0
 1497 004c 0423     		mov	r3, #4
 1498 004e D6E0     		b	.L113
 1499              	.L112:
 471:../Sources/system/CrystalClock.c ****   }
 472:../Sources/system/CrystalClock.c ****   
 473:../Sources/system/CrystalClock.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 474:../Sources/system/CrystalClock.c **** 
 475:../Sources/system/CrystalClock.c **** // Check PLL divider settings are within spec.
 476:../Sources/system/CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1500              		.loc 1 476 0
 1501 0050 FB1C     		add	r3, r7, #3
 1502 0052 1B78     		ldrb	r3, [r3]
 1503 0054 5BB2     		sxtb	r3, r3
 1504 0056 002B     		cmp	r3, #0
 1505 0058 04DD     		ble	.L114
 1506              		.loc 1 476 0 is_stmt 0
 1507 005a FB1C     		add	r3, r7, #3
 1508 005c 1B78     		ldrb	r3, [r3]
 1509 005e 5BB2     		sxtb	r3, r3
 1510 0060 192B     		cmp	r3, #25
 1511 0062 01DD     		ble	.L115
 1512              	.L114:
 1513              		.loc 1 476 0
 1514 0064 4123     		mov	r3, #65
 1515 0066 CAE0     		b	.L113
 1516              	.L115:
 477:../Sources/system/CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1517              		.loc 1 477 0 is_stmt 1
 1518 0068 BB1C     		add	r3, r7, #2
 1519 006a 1B78     		ldrb	r3, [r3]
 1520 006c 5BB2     		sxtb	r3, r3
 1521 006e 172B     		cmp	r3, #23
 1522 0070 04DD     		ble	.L116
 1523              		.loc 1 477 0 is_stmt 0
 1524 0072 BB1C     		add	r3, r7, #2
 1525 0074 1B78     		ldrb	r3, [r3]
 1526 0076 5BB2     		sxtb	r3, r3
 1527 0078 322B     		cmp	r3, #50
 1528 007a 01DD     		ble	.L117
 1529              	.L116:
 1530              		.loc 1 477 0
 1531 007c 4223     		mov	r3, #66
 1532 007e BEE0     		b	.L113
 1533              	.L117:
 478:../Sources/system/CrystalClock.c ****   
 479:../Sources/system/CrystalClock.c **** // Check PLL reference clock frequency is within spec.
 480:../Sources/system/CrystalClock.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1534              		.loc 1 480 0 is_stmt 1
 1535 0080 FB1C     		add	r3, r7, #3
 1536 0082 1B78     		ldrb	r3, [r3]
 1537 0084 5BB2     		sxtb	r3, r3
 1538 0086 7868     		ldr	r0, [r7, #4]
 1539 0088 191C     		mov	r1, r3
 1540 008a FFF7FEFF 		bl	__aeabi_idiv
 1541 008e 031C     		mov	r3, r0
 1542 0090 1A1C     		mov	r2, r3
 1543 0092 5E4B     		ldr	r3, .L134+4
 1544 0094 9A42     		cmp	r2, r3
 1545 0096 0BDD     		ble	.L118
 1546              		.loc 1 480 0 is_stmt 0
 1547 0098 FB1C     		add	r3, r7, #3
 1548 009a 1B78     		ldrb	r3, [r3]
 1549 009c 5BB2     		sxtb	r3, r3
 1550 009e 7868     		ldr	r0, [r7, #4]
 1551 00a0 191C     		mov	r1, r3
 1552 00a2 FFF7FEFF 		bl	__aeabi_idiv
 1553 00a6 031C     		mov	r3, r0
 1554 00a8 1A1C     		mov	r2, r3
 1555 00aa 594B     		ldr	r3, .L134+8
 1556 00ac 9A42     		cmp	r2, r3
 1557 00ae 01DD     		ble	.L119
 1558              	.L118:
 1559              		.loc 1 480 0
 1560 00b0 4323     		mov	r3, #67
 1561 00b2 A4E0     		b	.L113
 1562              	.L119:
 481:../Sources/system/CrystalClock.c ****        
 482:../Sources/system/CrystalClock.c **** // Check PLL output frequency is within spec.
 483:../Sources/system/CrystalClock.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 1563              		.loc 1 483 0 is_stmt 1
 1564 00b4 FB1C     		add	r3, r7, #3
 1565 00b6 1B78     		ldrb	r3, [r3]
 1566 00b8 5BB2     		sxtb	r3, r3
 1567 00ba 7868     		ldr	r0, [r7, #4]
 1568 00bc 191C     		mov	r1, r3
 1569 00be FFF7FEFF 		bl	__aeabi_idiv
 1570 00c2 031C     		mov	r3, r0
 1571 00c4 BA1C     		add	r2, r7, #2
 1572 00c6 1278     		ldrb	r2, [r2]
 1573 00c8 52B2     		sxtb	r2, r2
 1574 00ca 5343     		mul	r3, r2
 1575 00cc 3B61     		str	r3, [r7, #16]
 484:../Sources/system/CrystalClock.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 1576              		.loc 1 484 0
 1577 00ce 3A69     		ldr	r2, [r7, #16]
 1578 00d0 504B     		ldr	r3, .L134+12
 1579 00d2 9A42     		cmp	r2, r3
 1580 00d4 03DD     		ble	.L120
 1581              		.loc 1 484 0 is_stmt 0
 1582 00d6 3A69     		ldr	r2, [r7, #16]
 1583 00d8 4F4B     		ldr	r3, .L134+16
 1584 00da 9A42     		cmp	r2, r3
 1585 00dc 01DD     		ble	.L121
 1586              	.L120:
 1587              		.loc 1 484 0
 1588 00de 4523     		mov	r3, #69
 1589 00e0 8DE0     		b	.L113
 1590              	.L121:
 485:../Sources/system/CrystalClock.c **** 
 486:../Sources/system/CrystalClock.c ****   // Configure MCG_C5
 487:../Sources/system/CrystalClock.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 488:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C5;
 1591              		.loc 1 488 0 is_stmt 1
 1592 00e2 494A     		ldr	r2, .L134
 1593 00e4 3B1C     		mov	r3, r7
 1594 00e6 0F33     		add	r3, r3, #15
 1595 00e8 1279     		ldrb	r2, [r2, #4]
 1596 00ea 1A70     		strb	r2, [r3]
 489:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1597              		.loc 1 489 0
 1598 00ec 3B1C     		mov	r3, r7
 1599 00ee 0F33     		add	r3, r3, #15
 1600 00f0 3A1C     		mov	r2, r7
 1601 00f2 0F32     		add	r2, r2, #15
 1602 00f4 1278     		ldrb	r2, [r2]
 1603 00f6 1F21     		mov	r1, #31
 1604 00f8 8A43     		bic	r2, r1
 1605 00fa 1A70     		strb	r2, [r3]
 490:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 1606              		.loc 1 490 0
 1607 00fc FB1C     		add	r3, r7, #3
 1608 00fe 1B78     		ldrb	r3, [r3]
 1609 0100 013B     		sub	r3, r3, #1
 1610 0102 DAB2     		uxtb	r2, r3
 1611 0104 1F23     		mov	r3, #31
 1612 0106 1340     		and	r3, r2
 1613 0108 D9B2     		uxtb	r1, r3
 1614 010a 3B1C     		mov	r3, r7
 1615 010c 0F33     		add	r3, r3, #15
 1616 010e 3A1C     		mov	r2, r7
 1617 0110 0F32     		add	r2, r2, #15
 1618 0112 1278     		ldrb	r2, [r2]
 1619 0114 0A43     		orr	r2, r1
 1620 0116 1A70     		strb	r2, [r3]
 491:../Sources/system/CrystalClock.c ****   MCG_C5 = temp_reg;
 1621              		.loc 1 491 0
 1622 0118 3B4B     		ldr	r3, .L134
 1623 011a 3A1C     		mov	r2, r7
 1624 011c 0F32     		add	r2, r2, #15
 1625 011e 1278     		ldrb	r2, [r2]
 1626 0120 1A71     		strb	r2, [r3, #4]
 492:../Sources/system/CrystalClock.c **** 
 493:../Sources/system/CrystalClock.c ****   // Configure MCG_C6
 494:../Sources/system/CrystalClock.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 495:../Sources/system/CrystalClock.c ****   // The clock monitor is not enabled here as it has likely been enabled previously and so the valu
 496:../Sources/system/CrystalClock.c ****   // is not altered here.
 497:../Sources/system/CrystalClock.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 498:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 1627              		.loc 1 498 0
 1628 0122 394A     		ldr	r2, .L134
 1629 0124 3B1C     		mov	r3, r7
 1630 0126 0F33     		add	r3, r3, #15
 1631 0128 5279     		ldrb	r2, [r2, #5]
 1632 012a 1A70     		strb	r2, [r3]
 499:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1633              		.loc 1 499 0
 1634 012c 3B1C     		mov	r3, r7
 1635 012e 0F33     		add	r3, r3, #15
 1636 0130 3A1C     		mov	r2, r7
 1637 0132 0F32     		add	r2, r2, #15
 1638 0134 1278     		ldrb	r2, [r2]
 1639 0136 1F21     		mov	r1, #31
 1640 0138 8A43     		bic	r2, r1
 1641 013a 1A70     		strb	r2, [r3]
 500:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1642              		.loc 1 500 0
 1643 013c BB1C     		add	r3, r7, #2
 1644 013e 1B78     		ldrb	r3, [r3]
 1645 0140 183B     		sub	r3, r3, #24
 1646 0142 DAB2     		uxtb	r2, r3
 1647 0144 1F23     		mov	r3, #31
 1648 0146 1340     		and	r3, r2
 1649 0148 DAB2     		uxtb	r2, r3
 1650 014a 3B1C     		mov	r3, r7
 1651 014c 0F33     		add	r3, r3, #15
 1652 014e 1B78     		ldrb	r3, [r3]
 1653 0150 1343     		orr	r3, r2
 1654 0152 DAB2     		uxtb	r2, r3
 1655 0154 3B1C     		mov	r3, r7
 1656 0156 0F33     		add	r3, r3, #15
 1657 0158 4021     		mov	r1, #64
 1658 015a 0A43     		orr	r2, r1
 1659 015c 1A70     		strb	r2, [r3]
 501:../Sources/system/CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 1660              		.loc 1 501 0
 1661 015e 2A4B     		ldr	r3, .L134
 1662 0160 3A1C     		mov	r2, r7
 1663 0162 0F32     		add	r2, r2, #15
 1664 0164 1278     		ldrb	r2, [r2]
 1665 0166 5A71     		strb	r2, [r3, #5]
 502:../Sources/system/CrystalClock.c ****   
 503:../Sources/system/CrystalClock.c ****   // wait for PLLST status bit to set
 504:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1666              		.loc 1 504 0
 1667 0168 3B1C     		mov	r3, r7
 1668 016a 1633     		add	r3, r3, #22
 1669 016c 0022     		mov	r2, #0
 1670 016e 1A80     		strh	r2, [r3]
 1671 0170 0DE0     		b	.L122
 1672              	.L125:
 505:../Sources/system/CrystalClock.c ****   {
 506:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1673              		.loc 1 506 0
 1674 0172 254B     		ldr	r3, .L134
 1675 0174 9B79     		ldrb	r3, [r3, #6]
 1676 0176 DBB2     		uxtb	r3, r3
 1677 0178 1A1C     		mov	r2, r3
 1678 017a 2023     		mov	r3, #32
 1679 017c 1340     		and	r3, r2
 1680 017e 0ED1     		bne	.L132
 1681              	.L123:
 504:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1682              		.loc 1 504 0
 1683 0180 3B1C     		mov	r3, r7
 1684 0182 1633     		add	r3, r3, #22
 1685 0184 3A1C     		mov	r2, r7
 1686 0186 1632     		add	r2, r2, #22
 1687 0188 1288     		ldrh	r2, [r2]
 1688 018a 0132     		add	r2, r2, #1
 1689 018c 1A80     		strh	r2, [r3]
 1690              	.L122:
 504:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1691              		.loc 1 504 0 is_stmt 0
 1692 018e 3B1C     		mov	r3, r7
 1693 0190 1633     		add	r3, r3, #22
 1694 0192 0021     		mov	r1, #0
 1695 0194 5A5E     		ldrsh	r2, [r3, r1]
 1696 0196 214B     		ldr	r3, .L134+20
 1697 0198 9A42     		cmp	r2, r3
 1698 019a EADD     		ble	.L125
 1699 019c 00E0     		b	.L124
 1700              	.L132:
 1701              		.loc 1 506 0 is_stmt 1
 1702 019e C046     		mov	r8, r8
 1703              	.L124:
 507:../Sources/system/CrystalClock.c ****   }
 508:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 1704              		.loc 1 508 0
 1705 01a0 194B     		ldr	r3, .L134
 1706 01a2 9B79     		ldrb	r3, [r3, #6]
 1707 01a4 DBB2     		uxtb	r3, r3
 1708 01a6 1A1C     		mov	r2, r3
 1709 01a8 2023     		mov	r3, #32
 1710 01aa 1340     		and	r3, r2
 1711 01ac 01D1     		bne	.L126
 1712              		.loc 1 508 0 is_stmt 0
 1713 01ae 1623     		mov	r3, #22
 1714 01b0 25E0     		b	.L113
 1715              	.L126:
 509:../Sources/system/CrystalClock.c **** 
 510:../Sources/system/CrystalClock.c ****   // Wait for LOCK bit to set
 511:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1716              		.loc 1 511 0 is_stmt 1
 1717 01b2 3B1C     		mov	r3, r7
 1718 01b4 1633     		add	r3, r3, #22
 1719 01b6 0022     		mov	r2, #0
 1720 01b8 1A80     		strh	r2, [r3]
 1721 01ba 0DE0     		b	.L127
 1722              	.L130:
 512:../Sources/system/CrystalClock.c ****   {
 513:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1723              		.loc 1 513 0
 1724 01bc 124B     		ldr	r3, .L134
 1725 01be 9B79     		ldrb	r3, [r3, #6]
 1726 01c0 DBB2     		uxtb	r3, r3
 1727 01c2 1A1C     		mov	r2, r3
 1728 01c4 4023     		mov	r3, #64
 1729 01c6 1340     		and	r3, r2
 1730 01c8 0ED1     		bne	.L133
 1731              	.L128:
 511:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1732              		.loc 1 511 0
 1733 01ca 3B1C     		mov	r3, r7
 1734 01cc 1633     		add	r3, r3, #22
 1735 01ce 3A1C     		mov	r2, r7
 1736 01d0 1632     		add	r2, r2, #22
 1737 01d2 1288     		ldrh	r2, [r2]
 1738 01d4 0132     		add	r2, r2, #1
 1739 01d6 1A80     		strh	r2, [r3]
 1740              	.L127:
 511:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1741              		.loc 1 511 0 is_stmt 0
 1742 01d8 3B1C     		mov	r3, r7
 1743 01da 1633     		add	r3, r3, #22
 1744 01dc 0021     		mov	r1, #0
 1745 01de 5A5E     		ldrsh	r2, [r3, r1]
 1746 01e0 0E4B     		ldr	r3, .L134+20
 1747 01e2 9A42     		cmp	r2, r3
 1748 01e4 EADD     		ble	.L130
 1749 01e6 00E0     		b	.L129
 1750              	.L133:
 1751              		.loc 1 513 0 is_stmt 1
 1752 01e8 C046     		mov	r8, r8
 1753              	.L129:
 514:../Sources/system/CrystalClock.c ****   }
 515:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1754              		.loc 1 515 0
 1755 01ea 074B     		ldr	r3, .L134
 1756 01ec 9B79     		ldrb	r3, [r3, #6]
 1757 01ee DBB2     		uxtb	r3, r3
 1758 01f0 1A1C     		mov	r2, r3
 1759 01f2 4023     		mov	r3, #64
 1760 01f4 1340     		and	r3, r2
 1761 01f6 01D1     		bne	.L131
 1762              		.loc 1 515 0 is_stmt 0
 1763 01f8 4423     		mov	r3, #68
 1764 01fa 00E0     		b	.L113
 1765              	.L131:
 516:../Sources/system/CrystalClock.c ****     
 517:../Sources/system/CrystalClock.c **** // now in PBE 
 518:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 1766              		.loc 1 518 0 is_stmt 1
 1767 01fc 7B68     		ldr	r3, [r7, #4]
 1768              	.L113:
 519:../Sources/system/CrystalClock.c **** } // fbe_pbe
 1769              		.loc 1 519 0
 1770 01fe 181C     		mov	r0, r3
 1771 0200 BD46     		mov	sp, r7
 1772 0202 06B0     		add	sp, sp, #24
 1773              		@ sp needed for prologue
 1774 0204 80BD     		pop	{r7, pc}
 1775              	.L135:
 1776 0206 C046     		.align	2
 1777              	.L134:
 1778 0208 00400640 		.word	1074151424
 1779 020c 7F841E00 		.word	1999999
 1780 0210 00093D00 		.word	4000000
 1781 0214 FF6BDC02 		.word	47999999
 1782 0218 00E1F505 		.word	100000000
 1783 021c CF070000 		.word	1999
 1784              		.cfi_endproc
 1785              	.LFE5:
 1787              		.section	.text.pbe_blpe,"ax",%progbits
 1788              		.align	2
 1789              		.global	pbe_blpe
 1790              		.code	16
 1791              		.thumb_func
 1793              	pbe_blpe:
 1794              	.LFB6:
 520:../Sources/system/CrystalClock.c **** 
 521:../Sources/system/CrystalClock.c **** 
 522:../Sources/system/CrystalClock.c **** int pbe_blpe(int crystal_val)
 523:../Sources/system/CrystalClock.c **** {
 1795              		.loc 1 523 0
 1796              		.cfi_startproc
 1797 0000 80B5     		push	{r7, lr}
 1798              	.LCFI18:
 1799              		.cfi_def_cfa_offset 8
 1800              		.cfi_offset 7, -8
 1801              		.cfi_offset 14, -4
 1802 0002 82B0     		sub	sp, sp, #8
 1803              	.LCFI19:
 1804              		.cfi_def_cfa_offset 16
 1805 0004 00AF     		add	r7, sp, #0
 1806              	.LCFI20:
 1807              		.cfi_def_cfa_register 7
 1808 0006 7860     		str	r0, [r7, #4]
 524:../Sources/system/CrystalClock.c **** // Check MCG is in PBE mode
 525:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1809              		.loc 1 525 0
 1810 0008 164B     		ldr	r3, .L140
 1811 000a 9B79     		ldrb	r3, [r3, #6]
 1812 000c DBB2     		uxtb	r3, r3
 1813 000e 1A1C     		mov	r2, r3
 1814 0010 0C23     		mov	r3, #12
 1815 0012 1340     		and	r3, r2
 1816 0014 9B08     		lsr	r3, r3, #2
 1817 0016 022B     		cmp	r3, #2
 1818 0018 14D1     		bne	.L137
 526:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1819              		.loc 1 526 0
 1820 001a 124B     		ldr	r3, .L140
 1821 001c 9B79     		ldrb	r3, [r3, #6]
 1822 001e DBB2     		uxtb	r3, r3
 1823 0020 1A1C     		mov	r2, r3
 1824 0022 1023     		mov	r3, #16
 1825 0024 1340     		and	r3, r2
 525:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1826              		.loc 1 525 0
 1827 0026 0DD1     		bne	.L137
 527:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1828              		.loc 1 527 0
 1829 0028 0E4B     		ldr	r3, .L140
 1830 002a 9B79     		ldrb	r3, [r3, #6]
 1831 002c DBB2     		uxtb	r3, r3
 1832 002e 1A1C     		mov	r2, r3
 1833 0030 2023     		mov	r3, #32
 1834 0032 1340     		and	r3, r2
 526:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1835              		.loc 1 526 0
 1836 0034 06D0     		beq	.L137
 528:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1837              		.loc 1 528 0
 1838 0036 0B4B     		ldr	r3, .L140
 1839 0038 5B78     		ldrb	r3, [r3, #1]
 1840 003a DBB2     		uxtb	r3, r3
 1841 003c 1A1C     		mov	r2, r3
 1842 003e 0223     		mov	r3, #2
 1843 0040 1340     		and	r3, r2
 525:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1844              		.loc 1 525 0
 1845 0042 01D0     		beq	.L138
 1846              	.L137:
 529:../Sources/system/CrystalClock.c ****   {
 530:../Sources/system/CrystalClock.c ****     return 0x7;                                                       // return error code
 1847              		.loc 1 530 0
 1848 0044 0723     		mov	r3, #7
 1849 0046 08E0     		b	.L139
 1850              	.L138:
 531:../Sources/system/CrystalClock.c ****   }
 532:../Sources/system/CrystalClock.c ****   
 533:../Sources/system/CrystalClock.c **** // To enter BLPE mode the LP bit must be set, disabling the PLL  
 534:../Sources/system/CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 1851              		.loc 1 534 0
 1852 0048 064B     		ldr	r3, .L140
 1853 004a 064A     		ldr	r2, .L140
 1854 004c 5278     		ldrb	r2, [r2, #1]
 1855 004e D2B2     		uxtb	r2, r2
 1856 0050 0221     		mov	r1, #2
 1857 0052 0A43     		orr	r2, r1
 1858 0054 D2B2     		uxtb	r2, r2
 1859 0056 5A70     		strb	r2, [r3, #1]
 535:../Sources/system/CrystalClock.c ****   
 536:../Sources/system/CrystalClock.c **** // Now in BLPE mode
 537:../Sources/system/CrystalClock.c ****   return crystal_val;  
 1860              		.loc 1 537 0
 1861 0058 7B68     		ldr	r3, [r7, #4]
 1862              	.L139:
 538:../Sources/system/CrystalClock.c **** } // pbe_blpe
 1863              		.loc 1 538 0
 1864 005a 181C     		mov	r0, r3
 1865 005c BD46     		mov	sp, r7
 1866 005e 02B0     		add	sp, sp, #8
 1867              		@ sp needed for prologue
 1868 0060 80BD     		pop	{r7, pc}
 1869              	.L141:
 1870 0062 C046     		.align	2
 1871              	.L140:
 1872 0064 00400640 		.word	1074151424
 1873              		.cfi_endproc
 1874              	.LFE6:
 1876              		.section	.text.blpe_pbe,"ax",%progbits
 1877              		.align	2
 1878              		.global	blpe_pbe
 1879              		.code	16
 1880              		.thumb_func
 1882              	blpe_pbe:
 1883              	.LFB7:
 539:../Sources/system/CrystalClock.c **** 
 540:../Sources/system/CrystalClock.c **** 
 541:../Sources/system/CrystalClock.c **** // ************************************************************************************************
 542:../Sources/system/CrystalClock.c **** // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been
 543:../Sources/system/CrystalClock.c **** // previously configured correctly. That is why this general purpose driver has the PLL settings as
 544:../Sources/system/CrystalClock.c **** // passed parameters.
 545:../Sources/system/CrystalClock.c **** // ************************************************************************************************
 546:../Sources/system/CrystalClock.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 547:../Sources/system/CrystalClock.c **** {
 1884              		.loc 1 547 0
 1885              		.cfi_startproc
 1886 0000 80B5     		push	{r7, lr}
 1887              	.LCFI21:
 1888              		.cfi_def_cfa_offset 8
 1889              		.cfi_offset 7, -8
 1890              		.cfi_offset 14, -4
 1891 0002 84B0     		sub	sp, sp, #16
 1892              	.LCFI22:
 1893              		.cfi_def_cfa_offset 24
 1894 0004 00AF     		add	r7, sp, #0
 1895              	.LCFI23:
 1896              		.cfi_def_cfa_register 7
 1897 0006 7860     		str	r0, [r7, #4]
 1898 0008 FB1C     		add	r3, r7, #3
 1899 000a 1970     		strb	r1, [r3]
 1900 000c BB1C     		add	r3, r7, #2
 1901 000e 1A70     		strb	r2, [r3]
 548:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 549:../Sources/system/CrystalClock.c ****   short i;
 550:../Sources/system/CrystalClock.c ****   
 551:../Sources/system/CrystalClock.c **** // Check MCG is in BLPE mode
 552:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1902              		.loc 1 552 0
 1903 0010 724B     		ldr	r3, .L164
 1904 0012 9B79     		ldrb	r3, [r3, #6]
 1905 0014 DBB2     		uxtb	r3, r3
 1906 0016 1A1C     		mov	r2, r3
 1907 0018 0C23     		mov	r3, #12
 1908 001a 1340     		and	r3, r2
 1909 001c 9B08     		lsr	r3, r3, #2
 1910 001e 022B     		cmp	r3, #2
 1911 0020 0DD1     		bne	.L143
 553:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1912              		.loc 1 553 0
 1913 0022 6E4B     		ldr	r3, .L164
 1914 0024 9B79     		ldrb	r3, [r3, #6]
 1915 0026 DBB2     		uxtb	r3, r3
 1916 0028 1A1C     		mov	r2, r3
 1917 002a 1023     		mov	r3, #16
 1918 002c 1340     		and	r3, r2
 552:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1919              		.loc 1 552 0
 1920 002e 06D1     		bne	.L143
 554:../Sources/system/CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 1921              		.loc 1 554 0
 1922 0030 6A4B     		ldr	r3, .L164
 1923 0032 5B78     		ldrb	r3, [r3, #1]
 1924 0034 DBB2     		uxtb	r3, r3
 1925 0036 1A1C     		mov	r2, r3
 1926 0038 0223     		mov	r3, #2
 1927 003a 1340     		and	r3, r2
 552:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1928              		.loc 1 552 0
 1929 003c 01D1     		bne	.L144
 1930              	.L143:
 555:../Sources/system/CrystalClock.c ****   {
 556:../Sources/system/CrystalClock.c ****     return 0x6;                                                       // return error code
 1931              		.loc 1 556 0
 1932 003e 0623     		mov	r3, #6
 1933 0040 C7E0     		b	.L145
 1934              	.L144:
 557:../Sources/system/CrystalClock.c ****   }
 558:../Sources/system/CrystalClock.c ****   
 559:../Sources/system/CrystalClock.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 560:../Sources/system/CrystalClock.c **** 
 561:../Sources/system/CrystalClock.c **** // Check PLL divider settings are within spec.
 562:../Sources/system/CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1935              		.loc 1 562 0
 1936 0042 FB1C     		add	r3, r7, #3
 1937 0044 1B78     		ldrb	r3, [r3]
 1938 0046 5BB2     		sxtb	r3, r3
 1939 0048 002B     		cmp	r3, #0
 1940 004a 04DD     		ble	.L146
 1941              		.loc 1 562 0 is_stmt 0
 1942 004c FB1C     		add	r3, r7, #3
 1943 004e 1B78     		ldrb	r3, [r3]
 1944 0050 5BB2     		sxtb	r3, r3
 1945 0052 192B     		cmp	r3, #25
 1946 0054 01DD     		ble	.L147
 1947              	.L146:
 1948              		.loc 1 562 0
 1949 0056 4123     		mov	r3, #65
 1950 0058 BBE0     		b	.L145
 1951              	.L147:
 563:../Sources/system/CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1952              		.loc 1 563 0 is_stmt 1
 1953 005a BB1C     		add	r3, r7, #2
 1954 005c 1B78     		ldrb	r3, [r3]
 1955 005e 5BB2     		sxtb	r3, r3
 1956 0060 172B     		cmp	r3, #23
 1957 0062 04DD     		ble	.L148
 1958              		.loc 1 563 0 is_stmt 0
 1959 0064 BB1C     		add	r3, r7, #2
 1960 0066 1B78     		ldrb	r3, [r3]
 1961 0068 5BB2     		sxtb	r3, r3
 1962 006a 322B     		cmp	r3, #50
 1963 006c 01DD     		ble	.L149
 1964              	.L148:
 1965              		.loc 1 563 0
 1966 006e 4223     		mov	r3, #66
 1967 0070 AFE0     		b	.L145
 1968              	.L149:
 564:../Sources/system/CrystalClock.c ****   
 565:../Sources/system/CrystalClock.c **** // Check PLL reference clock frequency is within spec.
 566:../Sources/system/CrystalClock.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1969              		.loc 1 566 0 is_stmt 1
 1970 0072 FB1C     		add	r3, r7, #3
 1971 0074 1B78     		ldrb	r3, [r3]
 1972 0076 5BB2     		sxtb	r3, r3
 1973 0078 7868     		ldr	r0, [r7, #4]
 1974 007a 191C     		mov	r1, r3
 1975 007c FFF7FEFF 		bl	__aeabi_idiv
 1976 0080 031C     		mov	r3, r0
 1977 0082 1A1C     		mov	r2, r3
 1978 0084 564B     		ldr	r3, .L164+4
 1979 0086 9A42     		cmp	r2, r3
 1980 0088 0BDD     		ble	.L150
 1981              		.loc 1 566 0 is_stmt 0
 1982 008a FB1C     		add	r3, r7, #3
 1983 008c 1B78     		ldrb	r3, [r3]
 1984 008e 5BB2     		sxtb	r3, r3
 1985 0090 7868     		ldr	r0, [r7, #4]
 1986 0092 191C     		mov	r1, r3
 1987 0094 FFF7FEFF 		bl	__aeabi_idiv
 1988 0098 031C     		mov	r3, r0
 1989 009a 1A1C     		mov	r2, r3
 1990 009c 514B     		ldr	r3, .L164+8
 1991 009e 9A42     		cmp	r2, r3
 1992 00a0 01DD     		ble	.L151
 1993              	.L150:
 1994              		.loc 1 566 0
 1995 00a2 4323     		mov	r3, #67
 1996 00a4 95E0     		b	.L145
 1997              	.L151:
 567:../Sources/system/CrystalClock.c ****        
 568:../Sources/system/CrystalClock.c **** // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
 569:../Sources/system/CrystalClock.c **** 
 570:../Sources/system/CrystalClock.c **** // Configure MCG_C5
 571:../Sources/system/CrystalClock.c **** // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code
 572:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C5;
 1998              		.loc 1 572 0 is_stmt 1
 1999 00a6 4D4A     		ldr	r2, .L164
 2000 00a8 3B1C     		mov	r3, r7
 2001 00aa 0D33     		add	r3, r3, #13
 2002 00ac 1279     		ldrb	r2, [r2, #4]
 2003 00ae 1A70     		strb	r2, [r3]
 573:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 2004              		.loc 1 573 0
 2005 00b0 3B1C     		mov	r3, r7
 2006 00b2 0D33     		add	r3, r3, #13
 2007 00b4 3A1C     		mov	r2, r7
 2008 00b6 0D32     		add	r2, r2, #13
 2009 00b8 1278     		ldrb	r2, [r2]
 2010 00ba 1F21     		mov	r1, #31
 2011 00bc 8A43     		bic	r2, r1
 2012 00be 1A70     		strb	r2, [r3]
 574:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 2013              		.loc 1 574 0
 2014 00c0 FB1C     		add	r3, r7, #3
 2015 00c2 1B78     		ldrb	r3, [r3]
 2016 00c4 013B     		sub	r3, r3, #1
 2017 00c6 DAB2     		uxtb	r2, r3
 2018 00c8 1F23     		mov	r3, #31
 2019 00ca 1340     		and	r3, r2
 2020 00cc D9B2     		uxtb	r1, r3
 2021 00ce 3B1C     		mov	r3, r7
 2022 00d0 0D33     		add	r3, r3, #13
 2023 00d2 3A1C     		mov	r2, r7
 2024 00d4 0D32     		add	r2, r2, #13
 2025 00d6 1278     		ldrb	r2, [r2]
 2026 00d8 0A43     		orr	r2, r1
 2027 00da 1A70     		strb	r2, [r3]
 575:../Sources/system/CrystalClock.c ****   MCG_C5 = temp_reg;
 2028              		.loc 1 575 0
 2029 00dc 3F4B     		ldr	r3, .L164
 2030 00de 3A1C     		mov	r2, r7
 2031 00e0 0D32     		add	r2, r2, #13
 2032 00e2 1278     		ldrb	r2, [r2]
 2033 00e4 1A71     		strb	r2, [r3, #4]
 576:../Sources/system/CrystalClock.c **** 
 577:../Sources/system/CrystalClock.c **** // Configure MCG_C6
 578:../Sources/system/CrystalClock.c **** // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 579:../Sources/system/CrystalClock.c **** // The clock monitor is not enabled here as it has likely been enabled previously and so the value 
 580:../Sources/system/CrystalClock.c **** // is not altered here.
 581:../Sources/system/CrystalClock.c **** // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 582:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 2034              		.loc 1 582 0
 2035 00e6 3D4A     		ldr	r2, .L164
 2036 00e8 3B1C     		mov	r3, r7
 2037 00ea 0D33     		add	r3, r3, #13
 2038 00ec 5279     		ldrb	r2, [r2, #5]
 2039 00ee 1A70     		strb	r2, [r3]
 583:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 2040              		.loc 1 583 0
 2041 00f0 3B1C     		mov	r3, r7
 2042 00f2 0D33     		add	r3, r3, #13
 2043 00f4 3A1C     		mov	r2, r7
 2044 00f6 0D32     		add	r2, r2, #13
 2045 00f8 1278     		ldrb	r2, [r2]
 2046 00fa 1F21     		mov	r1, #31
 2047 00fc 8A43     		bic	r2, r1
 2048 00fe 1A70     		strb	r2, [r3]
 584:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 2049              		.loc 1 584 0
 2050 0100 BB1C     		add	r3, r7, #2
 2051 0102 1B78     		ldrb	r3, [r3]
 2052 0104 183B     		sub	r3, r3, #24
 2053 0106 DAB2     		uxtb	r2, r3
 2054 0108 1F23     		mov	r3, #31
 2055 010a 1340     		and	r3, r2
 2056 010c DAB2     		uxtb	r2, r3
 2057 010e 3B1C     		mov	r3, r7
 2058 0110 0D33     		add	r3, r3, #13
 2059 0112 1B78     		ldrb	r3, [r3]
 2060 0114 1343     		orr	r3, r2
 2061 0116 DAB2     		uxtb	r2, r3
 2062 0118 3B1C     		mov	r3, r7
 2063 011a 0D33     		add	r3, r3, #13
 2064 011c 4021     		mov	r1, #64
 2065 011e 0A43     		orr	r2, r1
 2066 0120 1A70     		strb	r2, [r3]
 585:../Sources/system/CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 2067              		.loc 1 585 0
 2068 0122 2E4B     		ldr	r3, .L164
 2069 0124 3A1C     		mov	r2, r7
 2070 0126 0D32     		add	r2, r2, #13
 2071 0128 1278     		ldrb	r2, [r2]
 2072 012a 5A71     		strb	r2, [r3, #5]
 586:../Sources/system/CrystalClock.c ****   
 587:../Sources/system/CrystalClock.c **** // Now that PLL is configured, LP is cleared to enable the PLL
 588:../Sources/system/CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 2073              		.loc 1 588 0
 2074 012c 2B4B     		ldr	r3, .L164
 2075 012e 2B4A     		ldr	r2, .L164
 2076 0130 5278     		ldrb	r2, [r2, #1]
 2077 0132 D2B2     		uxtb	r2, r2
 2078 0134 0221     		mov	r1, #2
 2079 0136 8A43     		bic	r2, r1
 2080 0138 D2B2     		uxtb	r2, r2
 2081 013a 5A70     		strb	r2, [r3, #1]
 589:../Sources/system/CrystalClock.c ****   
 590:../Sources/system/CrystalClock.c **** // wait for PLLST status bit to set
 591:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2082              		.loc 1 591 0
 2083 013c 3B1C     		mov	r3, r7
 2084 013e 0E33     		add	r3, r3, #14
 2085 0140 0022     		mov	r2, #0
 2086 0142 1A80     		strh	r2, [r3]
 2087 0144 0DE0     		b	.L152
 2088              	.L155:
 592:../Sources/system/CrystalClock.c ****   {
 593:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 2089              		.loc 1 593 0
 2090 0146 254B     		ldr	r3, .L164
 2091 0148 9B79     		ldrb	r3, [r3, #6]
 2092 014a DBB2     		uxtb	r3, r3
 2093 014c 1A1C     		mov	r2, r3
 2094 014e 2023     		mov	r3, #32
 2095 0150 1340     		and	r3, r2
 2096 0152 0ED1     		bne	.L162
 2097              	.L153:
 591:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2098              		.loc 1 591 0
 2099 0154 3B1C     		mov	r3, r7
 2100 0156 0E33     		add	r3, r3, #14
 2101 0158 3A1C     		mov	r2, r7
 2102 015a 0E32     		add	r2, r2, #14
 2103 015c 1288     		ldrh	r2, [r2]
 2104 015e 0132     		add	r2, r2, #1
 2105 0160 1A80     		strh	r2, [r3]
 2106              	.L152:
 591:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2107              		.loc 1 591 0 is_stmt 0
 2108 0162 3B1C     		mov	r3, r7
 2109 0164 0E33     		add	r3, r3, #14
 2110 0166 0021     		mov	r1, #0
 2111 0168 5A5E     		ldrsh	r2, [r3, r1]
 2112 016a 1F4B     		ldr	r3, .L164+12
 2113 016c 9A42     		cmp	r2, r3
 2114 016e EADD     		ble	.L155
 2115 0170 00E0     		b	.L154
 2116              	.L162:
 2117              		.loc 1 593 0 is_stmt 1
 2118 0172 C046     		mov	r8, r8
 2119              	.L154:
 594:../Sources/system/CrystalClock.c ****   }
 595:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 2120              		.loc 1 595 0
 2121 0174 194B     		ldr	r3, .L164
 2122 0176 9B79     		ldrb	r3, [r3, #6]
 2123 0178 DBB2     		uxtb	r3, r3
 2124 017a 1A1C     		mov	r2, r3
 2125 017c 2023     		mov	r3, #32
 2126 017e 1340     		and	r3, r2
 2127 0180 01D1     		bne	.L156
 2128              		.loc 1 595 0 is_stmt 0
 2129 0182 1623     		mov	r3, #22
 2130 0184 25E0     		b	.L145
 2131              	.L156:
 596:../Sources/system/CrystalClock.c **** 
 597:../Sources/system/CrystalClock.c **** // Wait for LOCK bit to set
 598:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2132              		.loc 1 598 0 is_stmt 1
 2133 0186 3B1C     		mov	r3, r7
 2134 0188 0E33     		add	r3, r3, #14
 2135 018a 0022     		mov	r2, #0
 2136 018c 1A80     		strh	r2, [r3]
 2137 018e 0DE0     		b	.L157
 2138              	.L160:
 599:../Sources/system/CrystalClock.c ****   {
 600:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 2139              		.loc 1 600 0
 2140 0190 124B     		ldr	r3, .L164
 2141 0192 9B79     		ldrb	r3, [r3, #6]
 2142 0194 DBB2     		uxtb	r3, r3
 2143 0196 1A1C     		mov	r2, r3
 2144 0198 4023     		mov	r3, #64
 2145 019a 1340     		and	r3, r2
 2146 019c 0ED1     		bne	.L163
 2147              	.L158:
 598:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2148              		.loc 1 598 0
 2149 019e 3B1C     		mov	r3, r7
 2150 01a0 0E33     		add	r3, r3, #14
 2151 01a2 3A1C     		mov	r2, r7
 2152 01a4 0E32     		add	r2, r2, #14
 2153 01a6 1288     		ldrh	r2, [r2]
 2154 01a8 0132     		add	r2, r2, #1
 2155 01aa 1A80     		strh	r2, [r3]
 2156              	.L157:
 598:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2157              		.loc 1 598 0 is_stmt 0
 2158 01ac 3B1C     		mov	r3, r7
 2159 01ae 0E33     		add	r3, r3, #14
 2160 01b0 0021     		mov	r1, #0
 2161 01b2 5A5E     		ldrsh	r2, [r3, r1]
 2162 01b4 0C4B     		ldr	r3, .L164+12
 2163 01b6 9A42     		cmp	r2, r3
 2164 01b8 EADD     		ble	.L160
 2165 01ba 00E0     		b	.L159
 2166              	.L163:
 2167              		.loc 1 600 0 is_stmt 1
 2168 01bc C046     		mov	r8, r8
 2169              	.L159:
 601:../Sources/system/CrystalClock.c ****   }
 602:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 2170              		.loc 1 602 0
 2171 01be 074B     		ldr	r3, .L164
 2172 01c0 9B79     		ldrb	r3, [r3, #6]
 2173 01c2 DBB2     		uxtb	r3, r3
 2174 01c4 1A1C     		mov	r2, r3
 2175 01c6 4023     		mov	r3, #64
 2176 01c8 1340     		and	r3, r2
 2177 01ca 01D1     		bne	.L161
 2178              		.loc 1 602 0 is_stmt 0
 2179 01cc 4423     		mov	r3, #68
 2180 01ce 00E0     		b	.L145
 2181              	.L161:
 603:../Sources/system/CrystalClock.c **** 
 604:../Sources/system/CrystalClock.c **** // now in PBE 
 605:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 2182              		.loc 1 605 0 is_stmt 1
 2183 01d0 7B68     		ldr	r3, [r7, #4]
 2184              	.L145:
 606:../Sources/system/CrystalClock.c **** } // blpe_pbe
 2185              		.loc 1 606 0
 2186 01d2 181C     		mov	r0, r3
 2187 01d4 BD46     		mov	sp, r7
 2188 01d6 04B0     		add	sp, sp, #16
 2189              		@ sp needed for prologue
 2190 01d8 80BD     		pop	{r7, pc}
 2191              	.L165:
 2192 01da C046     		.align	2
 2193              	.L164:
 2194 01dc 00400640 		.word	1074151424
 2195 01e0 7F841E00 		.word	1999999
 2196 01e4 00093D00 		.word	4000000
 2197 01e8 CF070000 		.word	1999
 2198              		.cfi_endproc
 2199              	.LFE7:
 2201              		.section	.text.blpe_fbe,"ax",%progbits
 2202              		.align	2
 2203              		.global	blpe_fbe
 2204              		.code	16
 2205              		.thumb_func
 2207              	blpe_fbe:
 2208              	.LFB8:
 607:../Sources/system/CrystalClock.c **** 
 608:../Sources/system/CrystalClock.c **** 
 609:../Sources/system/CrystalClock.c **** int blpe_fbe(int crystal_val)
 610:../Sources/system/CrystalClock.c **** {
 2209              		.loc 1 610 0
 2210              		.cfi_startproc
 2211 0000 80B5     		push	{r7, lr}
 2212              	.LCFI24:
 2213              		.cfi_def_cfa_offset 8
 2214              		.cfi_offset 7, -8
 2215              		.cfi_offset 14, -4
 2216 0002 84B0     		sub	sp, sp, #16
 2217              	.LCFI25:
 2218              		.cfi_def_cfa_offset 24
 2219 0004 00AF     		add	r7, sp, #0
 2220              	.LCFI26:
 2221              		.cfi_def_cfa_register 7
 2222 0006 7860     		str	r0, [r7, #4]
 611:../Sources/system/CrystalClock.c ****   short i;
 612:../Sources/system/CrystalClock.c ****   
 613:../Sources/system/CrystalClock.c **** // Check MCG is in BLPE mode
 614:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2223              		.loc 1 614 0
 2224 0008 294B     		ldr	r3, .L176
 2225 000a 9B79     		ldrb	r3, [r3, #6]
 2226 000c DBB2     		uxtb	r3, r3
 2227 000e 1A1C     		mov	r2, r3
 2228 0010 0C23     		mov	r3, #12
 2229 0012 1340     		and	r3, r2
 2230 0014 9B08     		lsr	r3, r3, #2
 2231 0016 022B     		cmp	r3, #2
 2232 0018 0DD1     		bne	.L167
 615:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2233              		.loc 1 615 0
 2234 001a 254B     		ldr	r3, .L176
 2235 001c 9B79     		ldrb	r3, [r3, #6]
 2236 001e DBB2     		uxtb	r3, r3
 2237 0020 1A1C     		mov	r2, r3
 2238 0022 1023     		mov	r3, #16
 2239 0024 1340     		and	r3, r2
 614:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2240              		.loc 1 614 0
 2241 0026 06D1     		bne	.L167
 616:../Sources/system/CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 2242              		.loc 1 616 0
 2243 0028 214B     		ldr	r3, .L176
 2244 002a 5B78     		ldrb	r3, [r3, #1]
 2245 002c DBB2     		uxtb	r3, r3
 2246 002e 1A1C     		mov	r2, r3
 2247 0030 0223     		mov	r3, #2
 2248 0032 1340     		and	r3, r2
 614:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2249              		.loc 1 614 0
 2250 0034 01D1     		bne	.L168
 2251              	.L167:
 617:../Sources/system/CrystalClock.c ****   {
 618:../Sources/system/CrystalClock.c ****     return 0x6;                                                       // return error code
 2252              		.loc 1 618 0
 2253 0036 0623     		mov	r3, #6
 2254 0038 35E0     		b	.L169
 2255              	.L168:
 619:../Sources/system/CrystalClock.c ****   }
 620:../Sources/system/CrystalClock.c ****  
 621:../Sources/system/CrystalClock.c **** // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cle
 622:../Sources/system/CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
 2256              		.loc 1 622 0
 2257 003a 1D4B     		ldr	r3, .L176
 2258 003c 1C4A     		ldr	r2, .L176
 2259 003e 5279     		ldrb	r2, [r2, #5]
 2260 0040 D2B2     		uxtb	r2, r2
 2261 0042 4021     		mov	r1, #64
 2262 0044 8A43     		bic	r2, r1
 2263 0046 D2B2     		uxtb	r2, r2
 2264 0048 5A71     		strb	r2, [r3, #5]
 623:../Sources/system/CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
 2265              		.loc 1 623 0
 2266 004a 194B     		ldr	r3, .L176
 2267 004c 184A     		ldr	r2, .L176
 2268 004e 5278     		ldrb	r2, [r2, #1]
 2269 0050 D2B2     		uxtb	r2, r2
 2270 0052 0221     		mov	r1, #2
 2271 0054 8A43     		bic	r2, r1
 2272 0056 D2B2     		uxtb	r2, r2
 2273 0058 5A70     		strb	r2, [r3, #1]
 624:../Sources/system/CrystalClock.c **** 
 625:../Sources/system/CrystalClock.c **** // wait for PLLST status bit to clear
 626:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2274              		.loc 1 626 0
 2275 005a 3B1C     		mov	r3, r7
 2276 005c 0E33     		add	r3, r3, #14
 2277 005e 0022     		mov	r2, #0
 2278 0060 1A80     		strh	r2, [r3]
 2279 0062 0DE0     		b	.L170
 2280              	.L173:
 627:../Sources/system/CrystalClock.c ****   {
 628:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 2281              		.loc 1 628 0
 2282 0064 124B     		ldr	r3, .L176
 2283 0066 9B79     		ldrb	r3, [r3, #6]
 2284 0068 DBB2     		uxtb	r3, r3
 2285 006a 1A1C     		mov	r2, r3
 2286 006c 2023     		mov	r3, #32
 2287 006e 1340     		and	r3, r2
 2288 0070 0ED0     		beq	.L175
 2289              	.L171:
 626:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2290              		.loc 1 626 0
 2291 0072 3B1C     		mov	r3, r7
 2292 0074 0E33     		add	r3, r3, #14
 2293 0076 3A1C     		mov	r2, r7
 2294 0078 0E32     		add	r2, r2, #14
 2295 007a 1288     		ldrh	r2, [r2]
 2296 007c 0132     		add	r2, r2, #1
 2297 007e 1A80     		strh	r2, [r3]
 2298              	.L170:
 626:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2299              		.loc 1 626 0 is_stmt 0
 2300 0080 3B1C     		mov	r3, r7
 2301 0082 0E33     		add	r3, r3, #14
 2302 0084 0021     		mov	r1, #0
 2303 0086 5A5E     		ldrsh	r2, [r3, r1]
 2304 0088 0A4B     		ldr	r3, .L176+4
 2305 008a 9A42     		cmp	r2, r3
 2306 008c EADD     		ble	.L173
 2307 008e 00E0     		b	.L172
 2308              	.L175:
 2309              		.loc 1 628 0 is_stmt 1
 2310 0090 C046     		mov	r8, r8
 2311              	.L172:
 629:../Sources/system/CrystalClock.c ****   }
 630:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 2312              		.loc 1 630 0
 2313 0092 074B     		ldr	r3, .L176
 2314 0094 9B79     		ldrb	r3, [r3, #6]
 2315 0096 DBB2     		uxtb	r3, r3
 2316 0098 1A1C     		mov	r2, r3
 2317 009a 2023     		mov	r3, #32
 2318 009c 1340     		and	r3, r2
 2319 009e 01D0     		beq	.L174
 2320              		.loc 1 630 0 is_stmt 0
 2321 00a0 1523     		mov	r3, #21
 2322 00a2 00E0     		b	.L169
 2323              	.L174:
 631:../Sources/system/CrystalClock.c ****   
 632:../Sources/system/CrystalClock.c **** // now in FBE mode
 633:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 2324              		.loc 1 633 0 is_stmt 1
 2325 00a4 7B68     		ldr	r3, [r7, #4]
 2326              	.L169:
 634:../Sources/system/CrystalClock.c **** } // blpe_fbe
 2327              		.loc 1 634 0
 2328 00a6 181C     		mov	r0, r3
 2329 00a8 BD46     		mov	sp, r7
 2330 00aa 04B0     		add	sp, sp, #16
 2331              		@ sp needed for prologue
 2332 00ac 80BD     		pop	{r7, pc}
 2333              	.L177:
 2334 00ae C046     		.align	2
 2335              	.L176:
 2336 00b0 00400640 		.word	1074151424
 2337 00b4 CF070000 		.word	1999
 2338              		.cfi_endproc
 2339              	.LFE8:
 2341              		.section	.text.fbe_blpe,"ax",%progbits
 2342              		.align	2
 2343              		.global	fbe_blpe
 2344              		.code	16
 2345              		.thumb_func
 2347              	fbe_blpe:
 2348              	.LFB9:
 635:../Sources/system/CrystalClock.c **** 
 636:../Sources/system/CrystalClock.c **** 
 637:../Sources/system/CrystalClock.c **** int fbe_blpe(int crystal_val)
 638:../Sources/system/CrystalClock.c **** {
 2349              		.loc 1 638 0
 2350              		.cfi_startproc
 2351 0000 80B5     		push	{r7, lr}
 2352              	.LCFI27:
 2353              		.cfi_def_cfa_offset 8
 2354              		.cfi_offset 7, -8
 2355              		.cfi_offset 14, -4
 2356 0002 82B0     		sub	sp, sp, #8
 2357              	.LCFI28:
 2358              		.cfi_def_cfa_offset 16
 2359 0004 00AF     		add	r7, sp, #0
 2360              	.LCFI29:
 2361              		.cfi_def_cfa_register 7
 2362 0006 7860     		str	r0, [r7, #4]
 639:../Sources/system/CrystalClock.c **** // Check MCG is in FBE mode
 640:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2363              		.loc 1 640 0
 2364 0008 164B     		ldr	r3, .L182
 2365 000a 9B79     		ldrb	r3, [r3, #6]
 2366 000c DBB2     		uxtb	r3, r3
 2367 000e 1A1C     		mov	r2, r3
 2368 0010 0C23     		mov	r3, #12
 2369 0012 1340     		and	r3, r2
 2370 0014 9B08     		lsr	r3, r3, #2
 2371 0016 022B     		cmp	r3, #2
 2372 0018 14D1     		bne	.L179
 641:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2373              		.loc 1 641 0
 2374 001a 124B     		ldr	r3, .L182
 2375 001c 9B79     		ldrb	r3, [r3, #6]
 2376 001e DBB2     		uxtb	r3, r3
 2377 0020 1A1C     		mov	r2, r3
 2378 0022 1023     		mov	r3, #16
 2379 0024 1340     		and	r3, r2
 640:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2380              		.loc 1 640 0
 2381 0026 0DD1     		bne	.L179
 642:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2382              		.loc 1 642 0
 2383 0028 0E4B     		ldr	r3, .L182
 2384 002a 9B79     		ldrb	r3, [r3, #6]
 2385 002c DBB2     		uxtb	r3, r3
 2386 002e 1A1C     		mov	r2, r3
 2387 0030 2023     		mov	r3, #32
 2388 0032 1340     		and	r3, r2
 641:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2389              		.loc 1 641 0
 2390 0034 06D1     		bne	.L179
 643:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2391              		.loc 1 643 0
 2392 0036 0B4B     		ldr	r3, .L182
 2393 0038 5B78     		ldrb	r3, [r3, #1]
 2394 003a DBB2     		uxtb	r3, r3
 2395 003c 1A1C     		mov	r2, r3
 2396 003e 0223     		mov	r3, #2
 2397 0040 1340     		and	r3, r2
 640:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2398              		.loc 1 640 0
 2399 0042 01D0     		beq	.L180
 2400              	.L179:
 644:../Sources/system/CrystalClock.c ****   {
 645:../Sources/system/CrystalClock.c ****     return 0x4;                                                       // return error code
 2401              		.loc 1 645 0
 2402 0044 0423     		mov	r3, #4
 2403 0046 08E0     		b	.L181
 2404              	.L180:
 646:../Sources/system/CrystalClock.c ****   }
 647:../Sources/system/CrystalClock.c ****  
 648:../Sources/system/CrystalClock.c **** // To move from FBE to BLPE the LP bit must be set
 649:../Sources/system/CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
 2405              		.loc 1 649 0
 2406 0048 064B     		ldr	r3, .L182
 2407 004a 064A     		ldr	r2, .L182
 2408 004c 5278     		ldrb	r2, [r2, #1]
 2409 004e D2B2     		uxtb	r2, r2
 2410 0050 0221     		mov	r1, #2
 2411 0052 0A43     		orr	r2, r1
 2412 0054 D2B2     		uxtb	r2, r2
 2413 0056 5A70     		strb	r2, [r3, #1]
 650:../Sources/system/CrystalClock.c ****  
 651:../Sources/system/CrystalClock.c **** // now in FBE mode
 652:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 2414              		.loc 1 652 0
 2415 0058 7B68     		ldr	r3, [r7, #4]
 2416              	.L181:
 653:../Sources/system/CrystalClock.c **** } // fbe_blpe
 2417              		.loc 1 653 0
 2418 005a 181C     		mov	r0, r3
 2419 005c BD46     		mov	sp, r7
 2420 005e 02B0     		add	sp, sp, #8
 2421              		@ sp needed for prologue
 2422 0060 80BD     		pop	{r7, pc}
 2423              	.L183:
 2424 0062 C046     		.align	2
 2425              	.L182:
 2426 0064 00400640 		.word	1074151424
 2427              		.cfi_endproc
 2428              	.LFE9:
 2430              		.section	.text.fbe_fei,"ax",%progbits
 2431              		.align	2
 2432              		.global	fbe_fei
 2433              		.code	16
 2434              		.thumb_func
 2436              	fbe_fei:
 2437              	.LFB10:
 654:../Sources/system/CrystalClock.c **** 
 655:../Sources/system/CrystalClock.c **** 
 656:../Sources/system/CrystalClock.c **** int fbe_fei(int slow_irc_freq)
 657:../Sources/system/CrystalClock.c **** {
 2438              		.loc 1 657 0
 2439              		.cfi_startproc
 2440 0000 80B5     		push	{r7, lr}
 2441              	.LCFI30:
 2442              		.cfi_def_cfa_offset 8
 2443              		.cfi_offset 7, -8
 2444              		.cfi_offset 14, -4
 2445 0002 86B0     		sub	sp, sp, #24
 2446              	.LCFI31:
 2447              		.cfi_def_cfa_offset 32
 2448 0004 00AF     		add	r7, sp, #0
 2449              	.LCFI32:
 2450              		.cfi_def_cfa_register 7
 2451 0006 7860     		str	r0, [r7, #4]
 658:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 659:../Sources/system/CrystalClock.c ****   short i;
 660:../Sources/system/CrystalClock.c ****   int mcg_out;
 661:../Sources/system/CrystalClock.c ****   
 662:../Sources/system/CrystalClock.c **** // Check MCG is in FBE mode
 663:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2452              		.loc 1 663 0
 2453 0008 534B     		ldr	r3, .L203
 2454 000a 9B79     		ldrb	r3, [r3, #6]
 2455 000c DBB2     		uxtb	r3, r3
 2456 000e 1A1C     		mov	r2, r3
 2457 0010 0C23     		mov	r3, #12
 2458 0012 1340     		and	r3, r2
 2459 0014 9B08     		lsr	r3, r3, #2
 2460 0016 022B     		cmp	r3, #2
 2461 0018 14D1     		bne	.L185
 664:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2462              		.loc 1 664 0
 2463 001a 4F4B     		ldr	r3, .L203
 2464 001c 9B79     		ldrb	r3, [r3, #6]
 2465 001e DBB2     		uxtb	r3, r3
 2466 0020 1A1C     		mov	r2, r3
 2467 0022 1023     		mov	r3, #16
 2468 0024 1340     		and	r3, r2
 663:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2469              		.loc 1 663 0
 2470 0026 0DD1     		bne	.L185
 665:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2471              		.loc 1 665 0
 2472 0028 4B4B     		ldr	r3, .L203
 2473 002a 9B79     		ldrb	r3, [r3, #6]
 2474 002c DBB2     		uxtb	r3, r3
 2475 002e 1A1C     		mov	r2, r3
 2476 0030 2023     		mov	r3, #32
 2477 0032 1340     		and	r3, r2
 664:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2478              		.loc 1 664 0
 2479 0034 06D1     		bne	.L185
 666:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2480              		.loc 1 666 0
 2481 0036 484B     		ldr	r3, .L203
 2482 0038 5B78     		ldrb	r3, [r3, #1]
 2483 003a DBB2     		uxtb	r3, r3
 2484 003c 1A1C     		mov	r2, r3
 2485 003e 0223     		mov	r3, #2
 2486 0040 1340     		and	r3, r2
 663:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2487              		.loc 1 663 0
 2488 0042 01D0     		beq	.L186
 2489              	.L185:
 667:../Sources/system/CrystalClock.c ****   {
 668:../Sources/system/CrystalClock.c ****     return 0x4;                                                       // return error code
 2490              		.loc 1 668 0
 2491 0044 0423     		mov	r3, #4
 2492 0046 83E0     		b	.L187
 2493              	.L186:
 669:../Sources/system/CrystalClock.c ****   }
 670:../Sources/system/CrystalClock.c **** 
 671:../Sources/system/CrystalClock.c **** // Check IRC frequency is within spec.
 672:../Sources/system/CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 2494              		.loc 1 672 0
 2495 0048 7A68     		ldr	r2, [r7, #4]
 2496 004a 444B     		ldr	r3, .L203+4
 2497 004c 9A42     		cmp	r2, r3
 2498 004e 03DD     		ble	.L188
 2499              		.loc 1 672 0 is_stmt 0
 2500 0050 7A68     		ldr	r2, [r7, #4]
 2501 0052 434B     		ldr	r3, .L203+8
 2502 0054 9A42     		cmp	r2, r3
 2503 0056 01DD     		ble	.L189
 2504              	.L188:
 673:../Sources/system/CrystalClock.c ****   {
 674:../Sources/system/CrystalClock.c ****     return 0x31;
 2505              		.loc 1 674 0 is_stmt 1
 2506 0058 3123     		mov	r3, #49
 2507 005a 79E0     		b	.L187
 2508              	.L189:
 675:../Sources/system/CrystalClock.c ****   }
 676:../Sources/system/CrystalClock.c ****   
 677:../Sources/system/CrystalClock.c **** // Check resulting FLL frequency 
 678:../Sources/system/CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
 2509              		.loc 1 678 0
 2510 005c 7B68     		ldr	r3, [r7, #4]
 2511 005e 181C     		mov	r0, r3
 2512 0060 FFF7FEFF 		bl	fll_freq
 2513 0064 031C     		mov	r3, r0
 2514 0066 3B61     		str	r3, [r7, #16]
 679:../Sources/system/CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 2515              		.loc 1 679 0
 2516 0068 3B69     		ldr	r3, [r7, #16]
 2517 006a 3B2B     		cmp	r3, #59
 2518 006c 01DC     		bgt	.L190
 2519              		.loc 1 679 0 is_stmt 0
 2520 006e 3B69     		ldr	r3, [r7, #16]
 2521 0070 6EE0     		b	.L187
 2522              	.L190:
 680:../Sources/system/CrystalClock.c **** 
 681:../Sources/system/CrystalClock.c **** // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
 682:../Sources/system/CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 2523              		.loc 1 682 0 is_stmt 1
 2524 0072 394B     		ldr	r3, .L203
 2525 0074 384A     		ldr	r2, .L203
 2526 0076 5279     		ldrb	r2, [r2, #5]
 2527 0078 D2B2     		uxtb	r2, r2
 2528 007a 2021     		mov	r1, #32
 2529 007c 8A43     		bic	r2, r1
 2530 007e D2B2     		uxtb	r2, r2
 2531 0080 5A71     		strb	r2, [r3, #5]
 683:../Sources/system/CrystalClock.c ****   
 684:../Sources/system/CrystalClock.c **** // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
 685:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 2532              		.loc 1 685 0
 2533 0082 354A     		ldr	r2, .L203
 2534 0084 3B1C     		mov	r3, r7
 2535 0086 0F33     		add	r3, r3, #15
 2536 0088 1278     		ldrb	r2, [r2]
 2537 008a 1A70     		strb	r2, [r3]
 686:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 2538              		.loc 1 686 0
 2539 008c 3B1C     		mov	r3, r7
 2540 008e 0F33     		add	r3, r3, #15
 2541 0090 3A1C     		mov	r2, r7
 2542 0092 0F32     		add	r2, r2, #15
 2543 0094 1178     		ldrb	r1, [r2]
 2544 0096 3F22     		mov	r2, #63
 2545 0098 0A40     		and	r2, r1
 2546 009a 1A70     		strb	r2, [r3]
 687:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 2547              		.loc 1 687 0
 2548 009c 3B1C     		mov	r3, r7
 2549 009e 0F33     		add	r3, r3, #15
 2550 00a0 3A1C     		mov	r2, r7
 2551 00a2 0F32     		add	r2, r2, #15
 2552 00a4 1278     		ldrb	r2, [r2]
 2553 00a6 0421     		mov	r1, #4
 2554 00a8 0A43     		orr	r2, r1
 2555 00aa 1A70     		strb	r2, [r3]
 688:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 2556              		.loc 1 688 0
 2557 00ac 2A4B     		ldr	r3, .L203
 2558 00ae 3A1C     		mov	r2, r7
 2559 00b0 0F32     		add	r2, r2, #15
 2560 00b2 1278     		ldrb	r2, [r2]
 2561 00b4 1A70     		strb	r2, [r3]
 689:../Sources/system/CrystalClock.c ****   
 690:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to set
 691:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2562              		.loc 1 691 0
 2563 00b6 3B1C     		mov	r3, r7
 2564 00b8 1633     		add	r3, r3, #22
 2565 00ba 0022     		mov	r2, #0
 2566 00bc 1A80     		strh	r2, [r3]
 2567 00be 0DE0     		b	.L191
 2568              	.L194:
 692:../Sources/system/CrystalClock.c ****   {
 693:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 2569              		.loc 1 693 0
 2570 00c0 254B     		ldr	r3, .L203
 2571 00c2 9B79     		ldrb	r3, [r3, #6]
 2572 00c4 DBB2     		uxtb	r3, r3
 2573 00c6 1A1C     		mov	r2, r3
 2574 00c8 1023     		mov	r3, #16
 2575 00ca 1340     		and	r3, r2
 2576 00cc 0ED1     		bne	.L201
 2577              	.L192:
 691:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2578              		.loc 1 691 0
 2579 00ce 3B1C     		mov	r3, r7
 2580 00d0 1633     		add	r3, r3, #22
 2581 00d2 3A1C     		mov	r2, r7
 2582 00d4 1632     		add	r2, r2, #22
 2583 00d6 1288     		ldrh	r2, [r2]
 2584 00d8 0132     		add	r2, r2, #1
 2585 00da 1A80     		strh	r2, [r3]
 2586              	.L191:
 691:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2587              		.loc 1 691 0 is_stmt 0
 2588 00dc 3B1C     		mov	r3, r7
 2589 00de 1633     		add	r3, r3, #22
 2590 00e0 0021     		mov	r1, #0
 2591 00e2 5A5E     		ldrsh	r2, [r3, r1]
 2592 00e4 1F4B     		ldr	r3, .L203+12
 2593 00e6 9A42     		cmp	r2, r3
 2594 00e8 EADD     		ble	.L194
 2595 00ea 00E0     		b	.L193
 2596              	.L201:
 2597              		.loc 1 693 0 is_stmt 1
 2598 00ec C046     		mov	r8, r8
 2599              	.L193:
 694:../Sources/system/CrystalClock.c ****   }
 695:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 2600              		.loc 1 695 0
 2601 00ee 1A4B     		ldr	r3, .L203
 2602 00f0 9B79     		ldrb	r3, [r3, #6]
 2603 00f2 DBB2     		uxtb	r3, r3
 2604 00f4 1A1C     		mov	r2, r3
 2605 00f6 1023     		mov	r3, #16
 2606 00f8 1340     		and	r3, r2
 2607 00fa 01D1     		bne	.L195
 2608              		.loc 1 695 0 is_stmt 0
 2609 00fc 1223     		mov	r3, #18
 2610 00fe 27E0     		b	.L187
 2611              	.L195:
 696:../Sources/system/CrystalClock.c ****   
 697:../Sources/system/CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
 698:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2612              		.loc 1 698 0 is_stmt 1
 2613 0100 3B1C     		mov	r3, r7
 2614 0102 1633     		add	r3, r3, #22
 2615 0104 0022     		mov	r2, #0
 2616 0106 1A80     		strh	r2, [r3]
 2617 0108 0EE0     		b	.L196
 2618              	.L199:
 699:../Sources/system/CrystalClock.c ****   {
 700:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 2619              		.loc 1 700 0
 2620 010a 134B     		ldr	r3, .L203
 2621 010c 9B79     		ldrb	r3, [r3, #6]
 2622 010e DBB2     		uxtb	r3, r3
 2623 0110 1A1C     		mov	r2, r3
 2624 0112 0C23     		mov	r3, #12
 2625 0114 1340     		and	r3, r2
 2626 0116 9B08     		lsr	r3, r3, #2
 2627 0118 0ED0     		beq	.L202
 2628              	.L197:
 698:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2629              		.loc 1 698 0
 2630 011a 3B1C     		mov	r3, r7
 2631 011c 1633     		add	r3, r3, #22
 2632 011e 3A1C     		mov	r2, r7
 2633 0120 1632     		add	r2, r2, #22
 2634 0122 1288     		ldrh	r2, [r2]
 2635 0124 0132     		add	r2, r2, #1
 2636 0126 1A80     		strh	r2, [r3]
 2637              	.L196:
 698:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2638              		.loc 1 698 0 is_stmt 0
 2639 0128 3B1C     		mov	r3, r7
 2640 012a 1633     		add	r3, r3, #22
 2641 012c 0021     		mov	r1, #0
 2642 012e 5A5E     		ldrsh	r2, [r3, r1]
 2643 0130 0C4B     		ldr	r3, .L203+12
 2644 0132 9A42     		cmp	r2, r3
 2645 0134 E9DD     		ble	.L199
 2646 0136 00E0     		b	.L198
 2647              	.L202:
 2648              		.loc 1 700 0 is_stmt 1
 2649 0138 C046     		mov	r8, r8
 2650              	.L198:
 701:../Sources/system/CrystalClock.c ****   }
 702:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is re
 2651              		.loc 1 702 0
 2652 013a 074B     		ldr	r3, .L203
 2653 013c 9B79     		ldrb	r3, [r3, #6]
 2654 013e DBB2     		uxtb	r3, r3
 2655 0140 1A1C     		mov	r2, r3
 2656 0142 0C23     		mov	r3, #12
 2657 0144 1340     		and	r3, r2
 2658 0146 9B08     		lsr	r3, r3, #2
 2659 0148 01D0     		beq	.L200
 2660              		.loc 1 702 0 is_stmt 0
 2661 014a 1823     		mov	r3, #24
 2662 014c 00E0     		b	.L187
 2663              	.L200:
 703:../Sources/system/CrystalClock.c **** 
 704:../Sources/system/CrystalClock.c **** // Now in FEI mode
 705:../Sources/system/CrystalClock.c ****   return mcg_out;
 2664              		.loc 1 705 0 is_stmt 1
 2665 014e 3B69     		ldr	r3, [r7, #16]
 2666              	.L187:
 706:../Sources/system/CrystalClock.c **** } // fbe_fei
 2667              		.loc 1 706 0
 2668 0150 181C     		mov	r0, r3
 2669 0152 BD46     		mov	sp, r7
 2670 0154 06B0     		add	sp, sp, #24
 2671              		@ sp needed for prologue
 2672 0156 80BD     		pop	{r7, pc}
 2673              	.L204:
 2674              		.align	2
 2675              	.L203:
 2676 0158 00400640 		.word	1074151424
 2677 015c 117A0000 		.word	31249
 2678 0160 97980000 		.word	39063
 2679 0164 CF070000 		.word	1999
 2680              		.cfi_endproc
 2681              	.LFE10:
 2683              		.section	.text.fei_fbe,"ax",%progbits
 2684              		.align	2
 2685              		.global	fei_fbe
 2686              		.code	16
 2687              		.thumb_func
 2689              	fei_fbe:
 2690              	.LFB11:
 707:../Sources/system/CrystalClock.c **** 
 708:../Sources/system/CrystalClock.c **** 
 709:../Sources/system/CrystalClock.c **** /********************************************************************/
 710:../Sources/system/CrystalClock.c **** /* Functon name : fei_fbe
 711:../Sources/system/CrystalClock.c ****  *
 712:../Sources/system/CrystalClock.c ****  * Mode transition: FEI to FBE mode
 713:../Sources/system/CrystalClock.c ****  *
 714:../Sources/system/CrystalClock.c ****  * This function transitions the MCG from FEI mode to FBE mode. This is
 715:../Sources/system/CrystalClock.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
 716:../Sources/system/CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
 717:../Sources/system/CrystalClock.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
 718:../Sources/system/CrystalClock.c ****  *
 719:../Sources/system/CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz
 720:../Sources/system/CrystalClock.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
 721:../Sources/system/CrystalClock.c ****  *                           for the crystal oscillator. This has no meaning if an 
 722:../Sources/system/CrystalClock.c ****  *                           external clock is used.
 723:../Sources/system/CrystalClock.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
 724:../Sources/system/CrystalClock.c ****  *
 725:../Sources/system/CrystalClock.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 726:../Sources/system/CrystalClock.c ****  */
 727:../Sources/system/CrystalClock.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 728:../Sources/system/CrystalClock.c **** {
 2691              		.loc 1 728 0
 2692              		.cfi_startproc
 2693 0000 80B5     		push	{r7, lr}
 2694              	.LCFI33:
 2695              		.cfi_def_cfa_offset 8
 2696              		.cfi_offset 7, -8
 2697              		.cfi_offset 14, -4
 2698 0002 84B0     		sub	sp, sp, #16
 2699              	.LCFI34:
 2700              		.cfi_def_cfa_offset 24
 2701 0004 00AF     		add	r7, sp, #0
 2702              	.LCFI35:
 2703              		.cfi_def_cfa_register 7
 2704 0006 7860     		str	r0, [r7, #4]
 2705 0008 FB1C     		add	r3, r7, #3
 2706 000a 1970     		strb	r1, [r3]
 2707 000c BB1C     		add	r3, r7, #2
 2708 000e 1A70     		strb	r2, [r3]
 729:../Sources/system/CrystalClock.c ****   unsigned char frdiv_val;
 730:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 731:../Sources/system/CrystalClock.c ****   short i;
 732:../Sources/system/CrystalClock.c ****   
 733:../Sources/system/CrystalClock.c **** // check if in FEI mode
 734:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2709              		.loc 1 734 0
 2710 0010 B44B     		ldr	r3, .L241
 2711 0012 9B79     		ldrb	r3, [r3, #6]
 2712 0014 DBB2     		uxtb	r3, r3
 2713 0016 1A1C     		mov	r2, r3
 2714 0018 0C23     		mov	r3, #12
 2715 001a 1340     		and	r3, r2
 2716 001c 9B08     		lsr	r3, r3, #2
 2717 001e 0DD1     		bne	.L206
 735:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2718              		.loc 1 735 0
 2719 0020 B04B     		ldr	r3, .L241
 2720 0022 9B79     		ldrb	r3, [r3, #6]
 2721 0024 DBB2     		uxtb	r3, r3
 2722 0026 1A1C     		mov	r2, r3
 2723 0028 1023     		mov	r3, #16
 2724 002a 1340     		and	r3, r2
 734:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2725              		.loc 1 734 0
 2726 002c 06D0     		beq	.L206
 736:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 2727              		.loc 1 736 0
 2728 002e AD4B     		ldr	r3, .L241
 2729 0030 9B79     		ldrb	r3, [r3, #6]
 2730 0032 DBB2     		uxtb	r3, r3
 2731 0034 1A1C     		mov	r2, r3
 2732 0036 2023     		mov	r3, #32
 2733 0038 1340     		and	r3, r2
 734:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2734              		.loc 1 734 0
 2735 003a 01D0     		beq	.L207
 2736              	.L206:
 737:../Sources/system/CrystalClock.c ****   {
 738:../Sources/system/CrystalClock.c ****     return 0x1;                                                     // return error code
 2737              		.loc 1 738 0
 2738 003c 0123     		mov	r3, #1
 2739 003e 4DE1     		b	.L208
 2740              	.L207:
 739:../Sources/system/CrystalClock.c ****   }
 740:../Sources/system/CrystalClock.c **** 
 741:../Sources/system/CrystalClock.c **** // check external frequency is less than the maximum frequency
 742:../Sources/system/CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 2741              		.loc 1 742 0
 2742 0040 7A68     		ldr	r2, [r7, #4]
 2743 0042 A94B     		ldr	r3, .L241+4
 2744 0044 9A42     		cmp	r2, r3
 2745 0046 01DD     		ble	.L209
 2746              		.loc 1 742 0 is_stmt 0
 2747 0048 2123     		mov	r3, #33
 2748 004a 47E1     		b	.L208
 2749              	.L209:
 743:../Sources/system/CrystalClock.c ****   
 744:../Sources/system/CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
 745:../Sources/system/CrystalClock.c ****   if (erefs_val)
 2750              		.loc 1 745 0 is_stmt 1
 2751 004c BB1C     		add	r3, r7, #2
 2752 004e 1B78     		ldrb	r3, [r3]
 2753 0050 002B     		cmp	r3, #0
 2754 0052 11D0     		beq	.L210
 746:../Sources/system/CrystalClock.c ****   {
 747:../Sources/system/CrystalClock.c ****     if ((crystal_val < 30000) ||
 2755              		.loc 1 747 0
 2756 0054 7A68     		ldr	r2, [r7, #4]
 2757 0056 A54B     		ldr	r3, .L241+8
 2758 0058 9A42     		cmp	r2, r3
 2759 005a 0BDD     		ble	.L211
 2760              		.loc 1 747 0 is_stmt 0
 2761 005c 7A68     		ldr	r2, [r7, #4]
 2762 005e A44B     		ldr	r3, .L241+12
 2763 0060 9A42     		cmp	r2, r3
 2764 0062 03DD     		ble	.L212
 748:../Sources/system/CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2765              		.loc 1 748 0 is_stmt 1
 2766 0064 7A68     		ldr	r2, [r7, #4]
 2767 0066 A34B     		ldr	r3, .L241+16
 2768 0068 9A42     		cmp	r2, r3
 2769 006a 03DD     		ble	.L211
 2770              	.L212:
 2771              		.loc 1 748 0 is_stmt 0
 2772 006c 7A68     		ldr	r2, [r7, #4]
 2773 006e A24B     		ldr	r3, .L241+20
 2774 0070 9A42     		cmp	r2, r3
 2775 0072 01DD     		ble	.L210
 2776              	.L211:
 749:../Sources/system/CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 2777              		.loc 1 749 0 is_stmt 1
 2778 0074 2223     		mov	r3, #34
 2779 0076 31E1     		b	.L208
 2780              	.L210:
 750:../Sources/system/CrystalClock.c ****   }
 751:../Sources/system/CrystalClock.c **** 
 752:../Sources/system/CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
 753:../Sources/system/CrystalClock.c ****   if (hgo_val > 0)
 2781              		.loc 1 753 0
 2782 0078 FB1C     		add	r3, r7, #3
 2783 007a 1B78     		ldrb	r3, [r3]
 2784 007c 002B     		cmp	r3, #0
 2785 007e 02D0     		beq	.L213
 754:../Sources/system/CrystalClock.c ****   {
 755:../Sources/system/CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 2786              		.loc 1 755 0
 2787 0080 FB1C     		add	r3, r7, #3
 2788 0082 0122     		mov	r2, #1
 2789 0084 1A70     		strb	r2, [r3]
 2790              	.L213:
 756:../Sources/system/CrystalClock.c ****   }
 757:../Sources/system/CrystalClock.c **** 
 758:../Sources/system/CrystalClock.c **** // configure the MCG_C2 register
 759:../Sources/system/CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
 760:../Sources/system/CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
 761:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C2;
 2791              		.loc 1 761 0
 2792 0086 974A     		ldr	r2, .L241
 2793 0088 3B1C     		mov	r3, r7
 2794 008a 0E33     		add	r3, r3, #14
 2795 008c 5278     		ldrb	r2, [r2, #1]
 2796 008e 1A70     		strb	r2, [r3]
 762:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 2797              		.loc 1 762 0
 2798 0090 3B1C     		mov	r3, r7
 2799 0092 0E33     		add	r3, r3, #14
 2800 0094 3A1C     		mov	r2, r7
 2801 0096 0E32     		add	r2, r2, #14
 2802 0098 1278     		ldrb	r2, [r2]
 2803 009a 3C21     		mov	r1, #60
 2804 009c 8A43     		bic	r2, r1
 2805 009e 1A70     		strb	r2, [r3]
 763:../Sources/system/CrystalClock.c ****   if (crystal_val <= 40000)
 2806              		.loc 1 763 0
 2807 00a0 7A68     		ldr	r2, [r7, #4]
 2808 00a2 934B     		ldr	r3, .L241+12
 2809 00a4 9A42     		cmp	r2, r3
 2810 00a6 11DC     		bgt	.L214
 764:../Sources/system/CrystalClock.c ****   {
 765:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2811              		.loc 1 765 0
 2812 00a8 FB1C     		add	r3, r7, #3
 2813 00aa 1B78     		ldrb	r3, [r3]
 2814 00ac DB00     		lsl	r3, r3, #3
 2815 00ae DAB2     		uxtb	r2, r3
 2816 00b0 BB1C     		add	r3, r7, #2
 2817 00b2 1B78     		ldrb	r3, [r3]
 2818 00b4 9B00     		lsl	r3, r3, #2
 2819 00b6 DBB2     		uxtb	r3, r3
 2820 00b8 1343     		orr	r3, r2
 2821 00ba D9B2     		uxtb	r1, r3
 2822 00bc 3B1C     		mov	r3, r7
 2823 00be 0E33     		add	r3, r3, #14
 2824 00c0 3A1C     		mov	r2, r7
 2825 00c2 0E32     		add	r2, r2, #14
 2826 00c4 1278     		ldrb	r2, [r2]
 2827 00c6 0A43     		orr	r2, r1
 2828 00c8 1A70     		strb	r2, [r3]
 2829 00ca 2CE0     		b	.L215
 2830              	.L214:
 766:../Sources/system/CrystalClock.c ****   }
 767:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 8000000)
 2831              		.loc 1 767 0
 2832 00cc 7A68     		ldr	r2, [r7, #4]
 2833 00ce 8B4B     		ldr	r3, .L241+24
 2834 00d0 9A42     		cmp	r2, r3
 2835 00d2 14DC     		bgt	.L216
 768:../Sources/system/CrystalClock.c ****   {
 769:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2836              		.loc 1 769 0
 2837 00d4 FB1C     		add	r3, r7, #3
 2838 00d6 1B78     		ldrb	r3, [r3]
 2839 00d8 DB00     		lsl	r3, r3, #3
 2840 00da DAB2     		uxtb	r2, r3
 2841 00dc BB1C     		add	r3, r7, #2
 2842 00de 1B78     		ldrb	r3, [r3]
 2843 00e0 9B00     		lsl	r3, r3, #2
 2844 00e2 DBB2     		uxtb	r3, r3
 2845 00e4 1343     		orr	r3, r2
 2846 00e6 DAB2     		uxtb	r2, r3
 2847 00e8 3B1C     		mov	r3, r7
 2848 00ea 0E33     		add	r3, r3, #14
 2849 00ec 1B78     		ldrb	r3, [r3]
 2850 00ee 1343     		orr	r3, r2
 2851 00f0 DAB2     		uxtb	r2, r3
 2852 00f2 3B1C     		mov	r3, r7
 2853 00f4 0E33     		add	r3, r3, #14
 2854 00f6 1021     		mov	r1, #16
 2855 00f8 0A43     		orr	r2, r1
 2856 00fa 1A70     		strb	r2, [r3]
 2857 00fc 13E0     		b	.L215
 2858              	.L216:
 770:../Sources/system/CrystalClock.c ****   }
 771:../Sources/system/CrystalClock.c ****   else
 772:../Sources/system/CrystalClock.c ****   {
 773:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2859              		.loc 1 773 0
 2860 00fe FB1C     		add	r3, r7, #3
 2861 0100 1B78     		ldrb	r3, [r3]
 2862 0102 DB00     		lsl	r3, r3, #3
 2863 0104 DAB2     		uxtb	r2, r3
 2864 0106 BB1C     		add	r3, r7, #2
 2865 0108 1B78     		ldrb	r3, [r3]
 2866 010a 9B00     		lsl	r3, r3, #2
 2867 010c DBB2     		uxtb	r3, r3
 2868 010e 1343     		orr	r3, r2
 2869 0110 DAB2     		uxtb	r2, r3
 2870 0112 3B1C     		mov	r3, r7
 2871 0114 0E33     		add	r3, r3, #14
 2872 0116 1B78     		ldrb	r3, [r3]
 2873 0118 1343     		orr	r3, r2
 2874 011a DAB2     		uxtb	r2, r3
 2875 011c 3B1C     		mov	r3, r7
 2876 011e 0E33     		add	r3, r3, #14
 2877 0120 2021     		mov	r1, #32
 2878 0122 0A43     		orr	r2, r1
 2879 0124 1A70     		strb	r2, [r3]
 2880              	.L215:
 774:../Sources/system/CrystalClock.c ****   }
 775:../Sources/system/CrystalClock.c ****   MCG_C2 = temp_reg;
 2881              		.loc 1 775 0
 2882 0126 6F4B     		ldr	r3, .L241
 2883 0128 3A1C     		mov	r2, r7
 2884 012a 0E32     		add	r2, r2, #14
 2885 012c 1278     		ldrb	r2, [r2]
 2886 012e 5A70     		strb	r2, [r3, #1]
 776:../Sources/system/CrystalClock.c **** // determine FRDIV based on reference clock frequency
 777:../Sources/system/CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
 778:../Sources/system/CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2887              		.loc 1 778 0
 2888 0130 7A68     		ldr	r2, [r7, #4]
 2889 0132 734B     		ldr	r3, .L241+28
 2890 0134 9A42     		cmp	r2, r3
 2891 0136 04DC     		bgt	.L217
 2892              		.loc 1 778 0 is_stmt 0
 2893 0138 3B1C     		mov	r3, r7
 2894 013a 0F33     		add	r3, r3, #15
 2895 013c 0022     		mov	r2, #0
 2896 013e 1A70     		strb	r2, [r3]
 2897 0140 27E0     		b	.L218
 2898              	.L217:
 779:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 2899              		.loc 1 779 0 is_stmt 1
 2900 0142 7A68     		ldr	r2, [r7, #4]
 2901 0144 6F4B     		ldr	r3, .L241+32
 2902 0146 9A42     		cmp	r2, r3
 2903 0148 04DC     		bgt	.L219
 2904              		.loc 1 779 0 is_stmt 0
 2905 014a 3B1C     		mov	r3, r7
 2906 014c 0F33     		add	r3, r3, #15
 2907 014e 0122     		mov	r2, #1
 2908 0150 1A70     		strb	r2, [r3]
 2909 0152 1EE0     		b	.L218
 2910              	.L219:
 780:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 2911              		.loc 1 780 0 is_stmt 1
 2912 0154 7A68     		ldr	r2, [r7, #4]
 2913 0156 6C4B     		ldr	r3, .L241+36
 2914 0158 9A42     		cmp	r2, r3
 2915 015a 04DC     		bgt	.L220
 2916              		.loc 1 780 0 is_stmt 0
 2917 015c 3B1C     		mov	r3, r7
 2918 015e 0F33     		add	r3, r3, #15
 2919 0160 0222     		mov	r2, #2
 2920 0162 1A70     		strb	r2, [r3]
 2921 0164 15E0     		b	.L218
 2922              	.L220:
 781:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 2923              		.loc 1 781 0 is_stmt 1
 2924 0166 7A68     		ldr	r2, [r7, #4]
 2925 0168 684B     		ldr	r3, .L241+40
 2926 016a 9A42     		cmp	r2, r3
 2927 016c 04DC     		bgt	.L221
 2928              		.loc 1 781 0 is_stmt 0
 2929 016e 3B1C     		mov	r3, r7
 2930 0170 0F33     		add	r3, r3, #15
 2931 0172 0322     		mov	r2, #3
 2932 0174 1A70     		strb	r2, [r3]
 2933 0176 0CE0     		b	.L218
 2934              	.L221:
 782:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2935              		.loc 1 782 0 is_stmt 1
 2936 0178 7A68     		ldr	r2, [r7, #4]
 2937 017a 654B     		ldr	r3, .L241+44
 2938 017c 9A42     		cmp	r2, r3
 2939 017e 04DC     		bgt	.L222
 2940              		.loc 1 782 0 is_stmt 0
 2941 0180 3B1C     		mov	r3, r7
 2942 0182 0F33     		add	r3, r3, #15
 2943 0184 0422     		mov	r2, #4
 2944 0186 1A70     		strb	r2, [r3]
 2945 0188 03E0     		b	.L218
 2946              	.L222:
 783:../Sources/system/CrystalClock.c ****   else {frdiv_val = 5;}
 2947              		.loc 1 783 0 is_stmt 1
 2948 018a 3B1C     		mov	r3, r7
 2949 018c 0F33     		add	r3, r3, #15
 2950 018e 0522     		mov	r2, #5
 2951 0190 1A70     		strb	r2, [r3]
 2952              	.L218:
 784:../Sources/system/CrystalClock.c ****   
 785:../Sources/system/CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
 786:../Sources/system/CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
 787:../Sources/system/CrystalClock.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 788:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 2953              		.loc 1 788 0
 2954 0192 544A     		ldr	r2, .L241
 2955 0194 3B1C     		mov	r3, r7
 2956 0196 0E33     		add	r3, r3, #14
 2957 0198 1278     		ldrb	r2, [r2]
 2958 019a 1A70     		strb	r2, [r3]
 789:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 2959              		.loc 1 789 0
 2960 019c 3B1C     		mov	r3, r7
 2961 019e 0E33     		add	r3, r3, #14
 2962 01a0 3A1C     		mov	r2, r7
 2963 01a2 0E32     		add	r2, r2, #14
 2964 01a4 1178     		ldrb	r1, [r2]
 2965 01a6 0322     		mov	r2, #3
 2966 01a8 0A40     		and	r2, r1
 2967 01aa 1A70     		strb	r2, [r3]
 790:../Sources/system/CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 2968              		.loc 1 790 0
 2969 01ac 3B1C     		mov	r3, r7
 2970 01ae 0F33     		add	r3, r3, #15
 2971 01b0 1B78     		ldrb	r3, [r3]
 2972 01b2 DB00     		lsl	r3, r3, #3
 2973 01b4 DAB2     		uxtb	r2, r3
 2974 01b6 3823     		mov	r3, #56
 2975 01b8 1340     		and	r3, r2
 2976 01ba DAB2     		uxtb	r2, r3
 2977 01bc 3B1C     		mov	r3, r7
 2978 01be 0E33     		add	r3, r3, #14
 2979 01c0 1B78     		ldrb	r3, [r3]
 2980 01c2 1343     		orr	r3, r2
 2981 01c4 DAB2     		uxtb	r2, r3
 2982 01c6 3B1C     		mov	r3, r7
 2983 01c8 0E33     		add	r3, r3, #14
 2984 01ca 8021     		mov	r1, #128
 2985 01cc 4942     		neg	r1, r1
 2986 01ce 0A43     		orr	r2, r1
 2987 01d0 1A70     		strb	r2, [r3]
 791:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg;
 2988              		.loc 1 791 0
 2989 01d2 444B     		ldr	r3, .L241
 2990 01d4 3A1C     		mov	r2, r7
 2991 01d6 0E32     		add	r2, r2, #14
 2992 01d8 1278     		ldrb	r2, [r2]
 2993 01da 1A70     		strb	r2, [r3]
 792:../Sources/system/CrystalClock.c **** 
 793:../Sources/system/CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
 794:../Sources/system/CrystalClock.c ****   if (erefs_val)
 2994              		.loc 1 794 0
 2995 01dc BB1C     		add	r3, r7, #2
 2996 01de 1B78     		ldrb	r3, [r3]
 2997 01e0 002B     		cmp	r3, #0
 2998 01e2 24D0     		beq	.L223
 795:../Sources/system/CrystalClock.c ****   {
 796:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 2999              		.loc 1 796 0
 3000 01e4 3B1C     		mov	r3, r7
 3001 01e6 0C33     		add	r3, r3, #12
 3002 01e8 0022     		mov	r2, #0
 3003 01ea 1A80     		strh	r2, [r3]
 3004 01ec 0DE0     		b	.L224
 3005              	.L227:
 797:../Sources/system/CrystalClock.c ****     {
 798:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 3006              		.loc 1 798 0
 3007 01ee 3D4B     		ldr	r3, .L241
 3008 01f0 9B79     		ldrb	r3, [r3, #6]
 3009 01f2 DBB2     		uxtb	r3, r3
 3010 01f4 1A1C     		mov	r2, r3
 3011 01f6 0223     		mov	r3, #2
 3012 01f8 1340     		and	r3, r2
 3013 01fa 0ED1     		bne	.L238
 3014              	.L225:
 796:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 3015              		.loc 1 796 0
 3016 01fc 3B1C     		mov	r3, r7
 3017 01fe 0C33     		add	r3, r3, #12
 3018 0200 3A1C     		mov	r2, r7
 3019 0202 0C32     		add	r2, r2, #12
 3020 0204 1288     		ldrh	r2, [r2]
 3021 0206 0132     		add	r2, r2, #1
 3022 0208 1A80     		strh	r2, [r3]
 3023              	.L224:
 796:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 3024              		.loc 1 796 0 is_stmt 0
 3025 020a 3B1C     		mov	r3, r7
 3026 020c 0C33     		add	r3, r3, #12
 3027 020e 0021     		mov	r1, #0
 3028 0210 5A5E     		ldrsh	r2, [r3, r1]
 3029 0212 404B     		ldr	r3, .L241+48
 3030 0214 9A42     		cmp	r2, r3
 3031 0216 EADD     		ble	.L227
 3032 0218 00E0     		b	.L226
 3033              	.L238:
 3034              		.loc 1 798 0 is_stmt 1
 3035 021a C046     		mov	r8, r8
 3036              	.L226:
 799:../Sources/system/CrystalClock.c ****     }
 800:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 3037              		.loc 1 800 0
 3038 021c 314B     		ldr	r3, .L241
 3039 021e 9B79     		ldrb	r3, [r3, #6]
 3040 0220 DBB2     		uxtb	r3, r3
 3041 0222 1A1C     		mov	r2, r3
 3042 0224 0223     		mov	r3, #2
 3043 0226 1340     		and	r3, r2
 3044 0228 01D1     		bne	.L223
 3045              		.loc 1 800 0 is_stmt 0
 3046 022a 2323     		mov	r3, #35
 3047 022c 56E0     		b	.L208
 3048              	.L223:
 801:../Sources/system/CrystalClock.c ****   }
 802:../Sources/system/CrystalClock.c **** 
 803:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to clear
 804:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3049              		.loc 1 804 0 is_stmt 1
 3050 022e 3B1C     		mov	r3, r7
 3051 0230 0C33     		add	r3, r3, #12
 3052 0232 0022     		mov	r2, #0
 3053 0234 1A80     		strh	r2, [r3]
 3054 0236 0DE0     		b	.L228
 3055              	.L231:
 805:../Sources/system/CrystalClock.c ****   {
 806:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 3056              		.loc 1 806 0
 3057 0238 2A4B     		ldr	r3, .L241
 3058 023a 9B79     		ldrb	r3, [r3, #6]
 3059 023c DBB2     		uxtb	r3, r3
 3060 023e 1A1C     		mov	r2, r3
 3061 0240 1023     		mov	r3, #16
 3062 0242 1340     		and	r3, r2
 3063 0244 0ED0     		beq	.L239
 3064              	.L229:
 804:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3065              		.loc 1 804 0
 3066 0246 3B1C     		mov	r3, r7
 3067 0248 0C33     		add	r3, r3, #12
 3068 024a 3A1C     		mov	r2, r7
 3069 024c 0C32     		add	r2, r2, #12
 3070 024e 1288     		ldrh	r2, [r2]
 3071 0250 0132     		add	r2, r2, #1
 3072 0252 1A80     		strh	r2, [r3]
 3073              	.L228:
 804:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3074              		.loc 1 804 0 is_stmt 0
 3075 0254 3B1C     		mov	r3, r7
 3076 0256 0C33     		add	r3, r3, #12
 3077 0258 0021     		mov	r1, #0
 3078 025a 5A5E     		ldrsh	r2, [r3, r1]
 3079 025c 2E4B     		ldr	r3, .L241+52
 3080 025e 9A42     		cmp	r2, r3
 3081 0260 EADD     		ble	.L231
 3082 0262 00E0     		b	.L230
 3083              	.L239:
 3084              		.loc 1 806 0 is_stmt 1
 3085 0264 C046     		mov	r8, r8
 3086              	.L230:
 807:../Sources/system/CrystalClock.c ****   }
 808:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 3087              		.loc 1 808 0
 3088 0266 1F4B     		ldr	r3, .L241
 3089 0268 9B79     		ldrb	r3, [r3, #6]
 3090 026a DBB2     		uxtb	r3, r3
 3091 026c 1A1C     		mov	r2, r3
 3092 026e 1023     		mov	r3, #16
 3093 0270 1340     		and	r3, r2
 3094 0272 01D0     		beq	.L232
 3095              		.loc 1 808 0 is_stmt 0
 3096 0274 1123     		mov	r3, #17
 3097 0276 31E0     		b	.L208
 3098              	.L232:
 809:../Sources/system/CrystalClock.c ****   
 810:../Sources/system/CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
 811:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3099              		.loc 1 811 0 is_stmt 1
 3100 0278 3B1C     		mov	r3, r7
 3101 027a 0C33     		add	r3, r3, #12
 3102 027c 0022     		mov	r2, #0
 3103 027e 1A80     		strh	r2, [r3]
 3104 0280 0FE0     		b	.L233
 3105              	.L236:
 812:../Sources/system/CrystalClock.c ****   {
 813:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 3106              		.loc 1 813 0
 3107 0282 184B     		ldr	r3, .L241
 3108 0284 9B79     		ldrb	r3, [r3, #6]
 3109 0286 DBB2     		uxtb	r3, r3
 3110 0288 1A1C     		mov	r2, r3
 3111 028a 0C23     		mov	r3, #12
 3112 028c 1340     		and	r3, r2
 3113 028e 9B08     		lsr	r3, r3, #2
 3114 0290 022B     		cmp	r3, #2
 3115 0292 0ED0     		beq	.L240
 3116              	.L234:
 811:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3117              		.loc 1 811 0
 3118 0294 3B1C     		mov	r3, r7
 3119 0296 0C33     		add	r3, r3, #12
 3120 0298 3A1C     		mov	r2, r7
 3121 029a 0C32     		add	r2, r2, #12
 3122 029c 1288     		ldrh	r2, [r2]
 3123 029e 0132     		add	r2, r2, #1
 3124 02a0 1A80     		strh	r2, [r3]
 3125              	.L233:
 811:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3126              		.loc 1 811 0 is_stmt 0
 3127 02a2 3B1C     		mov	r3, r7
 3128 02a4 0C33     		add	r3, r3, #12
 3129 02a6 0021     		mov	r1, #0
 3130 02a8 5A5E     		ldrsh	r2, [r3, r1]
 3131 02aa 1B4B     		ldr	r3, .L241+52
 3132 02ac 9A42     		cmp	r2, r3
 3133 02ae E8DD     		ble	.L236
 3134 02b0 00E0     		b	.L235
 3135              	.L240:
 3136              		.loc 1 813 0 is_stmt 1
 3137 02b2 C046     		mov	r8, r8
 3138              	.L235:
 814:../Sources/system/CrystalClock.c ****   }
 815:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 3139              		.loc 1 815 0
 3140 02b4 0B4B     		ldr	r3, .L241
 3141 02b6 9B79     		ldrb	r3, [r3, #6]
 3142 02b8 DBB2     		uxtb	r3, r3
 3143 02ba 1A1C     		mov	r2, r3
 3144 02bc 0C23     		mov	r3, #12
 3145 02be 1340     		and	r3, r2
 3146 02c0 9B08     		lsr	r3, r3, #2
 3147 02c2 022B     		cmp	r3, #2
 3148 02c4 01D0     		beq	.L237
 3149              		.loc 1 815 0 is_stmt 0
 3150 02c6 1A23     		mov	r3, #26
 3151 02c8 08E0     		b	.L208
 3152              	.L237:
 816:../Sources/system/CrystalClock.c ****  
 817:../Sources/system/CrystalClock.c **** // Now in FBE  
 818:../Sources/system/CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
 819:../Sources/system/CrystalClock.c **** // It is enabled here but can be removed if this is not required.
 820:../Sources/system/CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 3153              		.loc 1 820 0 is_stmt 1
 3154 02ca 064B     		ldr	r3, .L241
 3155 02cc 054A     		ldr	r2, .L241
 3156 02ce 5279     		ldrb	r2, [r2, #5]
 3157 02d0 D2B2     		uxtb	r2, r2
 3158 02d2 2021     		mov	r1, #32
 3159 02d4 0A43     		orr	r2, r1
 3160 02d6 D2B2     		uxtb	r2, r2
 3161 02d8 5A71     		strb	r2, [r3, #5]
 821:../Sources/system/CrystalClock.c ****   
 822:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 3162              		.loc 1 822 0
 3163 02da 7B68     		ldr	r3, [r7, #4]
 3164              	.L208:
 823:../Sources/system/CrystalClock.c **** } // fei_fbe
 3165              		.loc 1 823 0
 3166 02dc 181C     		mov	r0, r3
 3167 02de BD46     		mov	sp, r7
 3168 02e0 04B0     		add	sp, sp, #16
 3169              		@ sp needed for prologue
 3170 02e2 80BD     		pop	{r7, pc}
 3171              	.L242:
 3172              		.align	2
 3173              	.L241:
 3174 02e4 00400640 		.word	1074151424
 3175 02e8 80F0FA02 		.word	50000000
 3176 02ec 2F750000 		.word	29999
 3177 02f0 409C0000 		.word	40000
 3178 02f4 BFC62D00 		.word	2999999
 3179 02f8 0048E801 		.word	32000000
 3180 02fc 00127A00 		.word	8000000
 3181 0300 D0121300 		.word	1250000
 3182 0304 A0252600 		.word	2500000
 3183 0308 404B4C00 		.word	5000000
 3184 030c 80969800 		.word	10000000
 3185 0310 002D3101 		.word	20000000
 3186 0314 0F270000 		.word	9999
 3187 0318 CF070000 		.word	1999
 3188              		.cfi_endproc
 3189              	.LFE11:
 3191              		.section	.text.fbe_fee,"ax",%progbits
 3192              		.align	2
 3193              		.global	fbe_fee
 3194              		.code	16
 3195              		.thumb_func
 3197              	fbe_fee:
 3198              	.LFB12:
 824:../Sources/system/CrystalClock.c **** 
 825:../Sources/system/CrystalClock.c **** 
 826:../Sources/system/CrystalClock.c **** int fbe_fee(int crystal_val)
 827:../Sources/system/CrystalClock.c **** {
 3199              		.loc 1 827 0
 3200              		.cfi_startproc
 3201 0000 80B5     		push	{r7, lr}
 3202              	.LCFI36:
 3203              		.cfi_def_cfa_offset 8
 3204              		.cfi_offset 7, -8
 3205              		.cfi_offset 14, -4
 3206 0002 84B0     		sub	sp, sp, #16
 3207              	.LCFI37:
 3208              		.cfi_def_cfa_offset 24
 3209 0004 00AF     		add	r7, sp, #0
 3210              	.LCFI38:
 3211              		.cfi_def_cfa_register 7
 3212 0006 7860     		str	r0, [r7, #4]
 828:../Sources/system/CrystalClock.c ****   short i, fll_ref_freq;
 829:../Sources/system/CrystalClock.c ****   int mcg_out;
 830:../Sources/system/CrystalClock.c **** 
 831:../Sources/system/CrystalClock.c **** // Check MCG is in FBE mode
 832:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3213              		.loc 1 832 0
 3214 0008 494B     		ldr	r3, .L256
 3215 000a 9B79     		ldrb	r3, [r3, #6]
 3216 000c DBB2     		uxtb	r3, r3
 3217 000e 1A1C     		mov	r2, r3
 3218 0010 0C23     		mov	r3, #12
 3219 0012 1340     		and	r3, r2
 3220 0014 9B08     		lsr	r3, r3, #2
 3221 0016 022B     		cmp	r3, #2
 3222 0018 14D1     		bne	.L244
 833:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3223              		.loc 1 833 0
 3224 001a 454B     		ldr	r3, .L256
 3225 001c 9B79     		ldrb	r3, [r3, #6]
 3226 001e DBB2     		uxtb	r3, r3
 3227 0020 1A1C     		mov	r2, r3
 3228 0022 1023     		mov	r3, #16
 3229 0024 1340     		and	r3, r2
 832:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3230              		.loc 1 832 0
 3231 0026 0DD1     		bne	.L244
 834:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 3232              		.loc 1 834 0
 3233 0028 414B     		ldr	r3, .L256
 3234 002a 9B79     		ldrb	r3, [r3, #6]
 3235 002c DBB2     		uxtb	r3, r3
 3236 002e 1A1C     		mov	r2, r3
 3237 0030 2023     		mov	r3, #32
 3238 0032 1340     		and	r3, r2
 833:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3239              		.loc 1 833 0
 3240 0034 06D1     		bne	.L244
 835:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 3241              		.loc 1 835 0
 3242 0036 3E4B     		ldr	r3, .L256
 3243 0038 5B78     		ldrb	r3, [r3, #1]
 3244 003a DBB2     		uxtb	r3, r3
 3245 003c 1A1C     		mov	r2, r3
 3246 003e 0223     		mov	r3, #2
 3247 0040 1340     		and	r3, r2
 832:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3248              		.loc 1 832 0
 3249 0042 01D0     		beq	.L245
 3250              	.L244:
 836:../Sources/system/CrystalClock.c ****   {
 837:../Sources/system/CrystalClock.c ****     return 0x4;                                                       // return error code
 3251              		.loc 1 837 0
 3252 0044 0423     		mov	r3, #4
 3253 0046 6EE0     		b	.L246
 3254              	.L245:
 838:../Sources/system/CrystalClock.c ****   }
 839:../Sources/system/CrystalClock.c ****   
 840:../Sources/system/CrystalClock.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
 841:../Sources/system/CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3255              		.loc 1 841 0
 3256 0048 394B     		ldr	r3, .L256
 3257 004a 5B78     		ldrb	r3, [r3, #1]
 3258 004c DBB2     		uxtb	r3, r3
 3259 004e 1A1C     		mov	r2, r3
 3260 0050 3023     		mov	r3, #48
 3261 0052 1340     		and	r3, r2
 3262 0054 1B09     		lsr	r3, r3, #4
 3263 0056 14D0     		beq	.L247
 842:../Sources/system/CrystalClock.c ****   {
 843:../Sources/system/CrystalClock.c ****     fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
 3264              		.loc 1 843 0
 3265 0058 354B     		ldr	r3, .L256
 3266 005a 1B78     		ldrb	r3, [r3]
 3267 005c DBB2     		uxtb	r3, r3
 3268 005e 1A1C     		mov	r2, r3
 3269 0060 3823     		mov	r3, #56
 3270 0062 1340     		and	r3, r2
 3271 0064 DB08     		lsr	r3, r3, #3
 3272 0066 2022     		mov	r2, #32
 3273 0068 111C     		mov	r1, r2
 3274 006a 9940     		lsl	r1, r1, r3
 3275 006c 0B1C     		mov	r3, r1
 3276 006e 7868     		ldr	r0, [r7, #4]
 3277 0070 191C     		mov	r1, r3
 3278 0072 FFF7FEFF 		bl	__aeabi_idiv
 3279 0076 031C     		mov	r3, r0
 3280 0078 1A1C     		mov	r2, r3
 3281 007a 3B1C     		mov	r3, r7
 3282 007c 0C33     		add	r3, r3, #12
 3283 007e 1A80     		strh	r2, [r3]
 3284 0080 13E0     		b	.L248
 3285              	.L247:
 844:../Sources/system/CrystalClock.c ****   }
 845:../Sources/system/CrystalClock.c ****   else
 846:../Sources/system/CrystalClock.c ****   {
 847:../Sources/system/CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)))
 3286              		.loc 1 847 0
 3287 0082 2B4B     		ldr	r3, .L256
 3288 0084 5B78     		ldrb	r3, [r3, #1]
 3289 0086 DBB2     		uxtb	r3, r3
 3290 0088 1A1C     		mov	r2, r3
 3291 008a 3023     		mov	r3, #48
 3292 008c 1340     		and	r3, r2
 3293 008e 1B09     		lsr	r3, r3, #4
 3294 0090 0122     		mov	r2, #1
 3295 0092 111C     		mov	r1, r2
 3296 0094 9940     		lsl	r1, r1, r3
 3297 0096 0B1C     		mov	r3, r1
 3298 0098 7868     		ldr	r0, [r7, #4]
 3299 009a 191C     		mov	r1, r3
 3300 009c FFF7FEFF 		bl	__aeabi_idiv
 3301 00a0 031C     		mov	r3, r0
 3302 00a2 1A1C     		mov	r2, r3
 3303 00a4 3B1C     		mov	r3, r7
 3304 00a6 0C33     		add	r3, r3, #12
 3305 00a8 1A80     		strh	r2, [r3]
 3306              	.L248:
 848:../Sources/system/CrystalClock.c ****   }
 849:../Sources/system/CrystalClock.c ****   
 850:../Sources/system/CrystalClock.c **** // Check resulting FLL frequency 
 851:../Sources/system/CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 3307              		.loc 1 851 0
 3308 00aa 3B1C     		mov	r3, r7
 3309 00ac 0C33     		add	r3, r3, #12
 3310 00ae 0022     		mov	r2, #0
 3311 00b0 9B5E     		ldrsh	r3, [r3, r2]
 3312 00b2 181C     		mov	r0, r3
 3313 00b4 FFF7FEFF 		bl	fll_freq
 3314 00b8 031C     		mov	r3, r0
 3315 00ba BB60     		str	r3, [r7, #8]
 852:../Sources/system/CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 3316              		.loc 1 852 0
 3317 00bc BB68     		ldr	r3, [r7, #8]
 3318 00be 3B2B     		cmp	r3, #59
 3319 00c0 01DC     		bgt	.L249
 3320              		.loc 1 852 0 is_stmt 0
 3321 00c2 BB68     		ldr	r3, [r7, #8]
 3322 00c4 2FE0     		b	.L246
 3323              	.L249:
 853:../Sources/system/CrystalClock.c ****   
 854:../Sources/system/CrystalClock.c **** // Clear CLKS field to switch CLKS mux to select FLL output
 855:../Sources/system/CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 3324              		.loc 1 855 0 is_stmt 1
 3325 00c6 1A4B     		ldr	r3, .L256
 3326 00c8 194A     		ldr	r2, .L256
 3327 00ca 1278     		ldrb	r2, [r2]
 3328 00cc D1B2     		uxtb	r1, r2
 3329 00ce 3F22     		mov	r2, #63
 3330 00d0 0A40     		and	r2, r1
 3331 00d2 D2B2     		uxtb	r2, r2
 3332 00d4 1A70     		strb	r2, [r3]
 856:../Sources/system/CrystalClock.c **** 
 857:../Sources/system/CrystalClock.c **** // Wait for clock status bits to show clock source is FLL
 858:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3333              		.loc 1 858 0
 3334 00d6 3B1C     		mov	r3, r7
 3335 00d8 0E33     		add	r3, r3, #14
 3336 00da 0022     		mov	r2, #0
 3337 00dc 1A80     		strh	r2, [r3]
 3338 00de 0EE0     		b	.L250
 3339              	.L253:
 859:../Sources/system/CrystalClock.c ****   {
 860:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 3340              		.loc 1 860 0
 3341 00e0 134B     		ldr	r3, .L256
 3342 00e2 9B79     		ldrb	r3, [r3, #6]
 3343 00e4 DBB2     		uxtb	r3, r3
 3344 00e6 1A1C     		mov	r2, r3
 3345 00e8 0C23     		mov	r3, #12
 3346 00ea 1340     		and	r3, r2
 3347 00ec 9B08     		lsr	r3, r3, #2
 3348 00ee 0ED0     		beq	.L255
 3349              	.L251:
 858:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3350              		.loc 1 858 0
 3351 00f0 3B1C     		mov	r3, r7
 3352 00f2 0E33     		add	r3, r3, #14
 3353 00f4 3A1C     		mov	r2, r7
 3354 00f6 0E32     		add	r2, r2, #14
 3355 00f8 1288     		ldrh	r2, [r2]
 3356 00fa 0132     		add	r2, r2, #1
 3357 00fc 1A80     		strh	r2, [r3]
 3358              	.L250:
 858:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3359              		.loc 1 858 0 is_stmt 0
 3360 00fe 3B1C     		mov	r3, r7
 3361 0100 0E33     		add	r3, r3, #14
 3362 0102 0021     		mov	r1, #0
 3363 0104 5A5E     		ldrsh	r2, [r3, r1]
 3364 0106 0B4B     		ldr	r3, .L256+4
 3365 0108 9A42     		cmp	r2, r3
 3366 010a E9DD     		ble	.L253
 3367 010c 00E0     		b	.L252
 3368              	.L255:
 3369              		.loc 1 860 0 is_stmt 1
 3370 010e C046     		mov	r8, r8
 3371              	.L252:
 861:../Sources/system/CrystalClock.c ****   }
 862:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 3372              		.loc 1 862 0
 3373 0110 074B     		ldr	r3, .L256
 3374 0112 9B79     		ldrb	r3, [r3, #6]
 3375 0114 DBB2     		uxtb	r3, r3
 3376 0116 1A1C     		mov	r2, r3
 3377 0118 0C23     		mov	r3, #12
 3378 011a 1340     		and	r3, r2
 3379 011c 9B08     		lsr	r3, r3, #2
 3380 011e 01D0     		beq	.L254
 3381              		.loc 1 862 0 is_stmt 0
 3382 0120 1823     		mov	r3, #24
 3383 0122 00E0     		b	.L246
 3384              	.L254:
 863:../Sources/system/CrystalClock.c ****   
 864:../Sources/system/CrystalClock.c **** // Now in FEE mode
 865:../Sources/system/CrystalClock.c ****   return mcg_out;
 3385              		.loc 1 865 0 is_stmt 1
 3386 0124 BB68     		ldr	r3, [r7, #8]
 3387              	.L246:
 866:../Sources/system/CrystalClock.c **** } // fbe_fee
 3388              		.loc 1 866 0
 3389 0126 181C     		mov	r0, r3
 3390 0128 BD46     		mov	sp, r7
 3391 012a 04B0     		add	sp, sp, #16
 3392              		@ sp needed for prologue
 3393 012c 80BD     		pop	{r7, pc}
 3394              	.L257:
 3395 012e C046     		.align	2
 3396              	.L256:
 3397 0130 00400640 		.word	1074151424
 3398 0134 CF070000 		.word	1999
 3399              		.cfi_endproc
 3400              	.LFE12:
 3402              		.section	.text.fee_fbe,"ax",%progbits
 3403              		.align	2
 3404              		.global	fee_fbe
 3405              		.code	16
 3406              		.thumb_func
 3408              	fee_fbe:
 3409              	.LFB13:
 867:../Sources/system/CrystalClock.c **** 
 868:../Sources/system/CrystalClock.c **** 
 869:../Sources/system/CrystalClock.c **** int fee_fbe(int crystal_val)
 870:../Sources/system/CrystalClock.c **** { 
 3410              		.loc 1 870 0
 3411              		.cfi_startproc
 3412 0000 80B5     		push	{r7, lr}
 3413              	.LCFI39:
 3414              		.cfi_def_cfa_offset 8
 3415              		.cfi_offset 7, -8
 3416              		.cfi_offset 14, -4
 3417 0002 84B0     		sub	sp, sp, #16
 3418              	.LCFI40:
 3419              		.cfi_def_cfa_offset 24
 3420 0004 00AF     		add	r7, sp, #0
 3421              	.LCFI41:
 3422              		.cfi_def_cfa_register 7
 3423 0006 7860     		str	r0, [r7, #4]
 871:../Sources/system/CrystalClock.c ****   short i;
 872:../Sources/system/CrystalClock.c ****   
 873:../Sources/system/CrystalClock.c **** // Check MCG is in FEE mode
 874:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3424              		.loc 1 874 0
 3425 0008 274B     		ldr	r3, .L268
 3426 000a 9B79     		ldrb	r3, [r3, #6]
 3427 000c DBB2     		uxtb	r3, r3
 3428 000e 1A1C     		mov	r2, r3
 3429 0010 0C23     		mov	r3, #12
 3430 0012 1340     		and	r3, r2
 3431 0014 9B08     		lsr	r3, r3, #2
 3432 0016 0DD1     		bne	.L259
 875:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3433              		.loc 1 875 0
 3434 0018 234B     		ldr	r3, .L268
 3435 001a 9B79     		ldrb	r3, [r3, #6]
 3436 001c DBB2     		uxtb	r3, r3
 3437 001e 1A1C     		mov	r2, r3
 3438 0020 1023     		mov	r3, #16
 3439 0022 1340     		and	r3, r2
 874:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3440              		.loc 1 874 0
 3441 0024 06D1     		bne	.L259
 876:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3442              		.loc 1 876 0
 3443 0026 204B     		ldr	r3, .L268
 3444 0028 9B79     		ldrb	r3, [r3, #6]
 3445 002a DBB2     		uxtb	r3, r3
 3446 002c 1A1C     		mov	r2, r3
 3447 002e 2023     		mov	r3, #32
 3448 0030 1340     		and	r3, r2
 874:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3449              		.loc 1 874 0
 3450 0032 01D0     		beq	.L260
 3451              	.L259:
 877:../Sources/system/CrystalClock.c ****   {
 878:../Sources/system/CrystalClock.c ****     return 0x2;                                                       // return error code
 3452              		.loc 1 878 0
 3453 0034 0223     		mov	r3, #2
 3454 0036 32E0     		b	.L261
 3455              	.L260:
 879:../Sources/system/CrystalClock.c ****   }
 880:../Sources/system/CrystalClock.c ****   
 881:../Sources/system/CrystalClock.c **** // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
 882:../Sources/system/CrystalClock.c **** // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
 883:../Sources/system/CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
 3456              		.loc 1 883 0
 3457 0038 1B4B     		ldr	r3, .L268
 3458 003a 1B4A     		ldr	r2, .L268
 3459 003c 1278     		ldrb	r2, [r2]
 3460 003e D2B2     		uxtb	r2, r2
 3461 0040 8021     		mov	r1, #128
 3462 0042 4942     		neg	r1, r1
 3463 0044 0A43     		orr	r2, r1
 3464 0046 D2B2     		uxtb	r2, r2
 3465 0048 1A70     		strb	r2, [r3]
 884:../Sources/system/CrystalClock.c **** 
 885:../Sources/system/CrystalClock.c **** /// Wait for clock status bits to show clock source is ext ref clk
 886:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3466              		.loc 1 886 0
 3467 004a 3B1C     		mov	r3, r7
 3468 004c 0E33     		add	r3, r3, #14
 3469 004e 0022     		mov	r2, #0
 3470 0050 1A80     		strh	r2, [r3]
 3471 0052 0FE0     		b	.L262
 3472              	.L265:
 887:../Sources/system/CrystalClock.c ****   {
 888:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 3473              		.loc 1 888 0
 3474 0054 144B     		ldr	r3, .L268
 3475 0056 9B79     		ldrb	r3, [r3, #6]
 3476 0058 DBB2     		uxtb	r3, r3
 3477 005a 1A1C     		mov	r2, r3
 3478 005c 0C23     		mov	r3, #12
 3479 005e 1340     		and	r3, r2
 3480 0060 9B08     		lsr	r3, r3, #2
 3481 0062 022B     		cmp	r3, #2
 3482 0064 0ED0     		beq	.L267
 3483              	.L263:
 886:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3484              		.loc 1 886 0
 3485 0066 3B1C     		mov	r3, r7
 3486 0068 0E33     		add	r3, r3, #14
 3487 006a 3A1C     		mov	r2, r7
 3488 006c 0E32     		add	r2, r2, #14
 3489 006e 1288     		ldrh	r2, [r2]
 3490 0070 0132     		add	r2, r2, #1
 3491 0072 1A80     		strh	r2, [r3]
 3492              	.L262:
 886:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3493              		.loc 1 886 0 is_stmt 0
 3494 0074 3B1C     		mov	r3, r7
 3495 0076 0E33     		add	r3, r3, #14
 3496 0078 0021     		mov	r1, #0
 3497 007a 5A5E     		ldrsh	r2, [r3, r1]
 3498 007c 0B4B     		ldr	r3, .L268+4
 3499 007e 9A42     		cmp	r2, r3
 3500 0080 E8DD     		ble	.L265
 3501 0082 00E0     		b	.L264
 3502              	.L267:
 3503              		.loc 1 888 0 is_stmt 1
 3504 0084 C046     		mov	r8, r8
 3505              	.L264:
 889:../Sources/system/CrystalClock.c ****   }
 890:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 3506              		.loc 1 890 0
 3507 0086 084B     		ldr	r3, .L268
 3508 0088 9B79     		ldrb	r3, [r3, #6]
 3509 008a DBB2     		uxtb	r3, r3
 3510 008c 1A1C     		mov	r2, r3
 3511 008e 0C23     		mov	r3, #12
 3512 0090 1340     		and	r3, r2
 3513 0092 9B08     		lsr	r3, r3, #2
 3514 0094 022B     		cmp	r3, #2
 3515 0096 01D0     		beq	.L266
 3516              		.loc 1 890 0 is_stmt 0
 3517 0098 1A23     		mov	r3, #26
 3518 009a 00E0     		b	.L261
 3519              	.L266:
 891:../Sources/system/CrystalClock.c ****   
 892:../Sources/system/CrystalClock.c **** // Now in FBE mode
 893:../Sources/system/CrystalClock.c ****   return crystal_val;
 3520              		.loc 1 893 0 is_stmt 1
 3521 009c 7B68     		ldr	r3, [r7, #4]
 3522              	.L261:
 894:../Sources/system/CrystalClock.c **** } // fee_fbe
 3523              		.loc 1 894 0
 3524 009e 181C     		mov	r0, r3
 3525 00a0 BD46     		mov	sp, r7
 3526 00a2 04B0     		add	sp, sp, #16
 3527              		@ sp needed for prologue
 3528 00a4 80BD     		pop	{r7, pc}
 3529              	.L269:
 3530 00a6 C046     		.align	2
 3531              	.L268:
 3532 00a8 00400640 		.word	1074151424
 3533 00ac CF070000 		.word	1999
 3534              		.cfi_endproc
 3535              	.LFE13:
 3537              		.section	.text.fbe_fbi,"ax",%progbits
 3538              		.align	2
 3539              		.global	fbe_fbi
 3540              		.code	16
 3541              		.thumb_func
 3543              	fbe_fbi:
 3544              	.LFB14:
 895:../Sources/system/CrystalClock.c **** 
 896:../Sources/system/CrystalClock.c **** 
 897:../Sources/system/CrystalClock.c **** int fbe_fbi(int irc_freq, unsigned char irc_select)
 898:../Sources/system/CrystalClock.c **** {
 3545              		.loc 1 898 0
 3546              		.cfi_startproc
 3547 0000 80B5     		push	{r7, lr}
 3548              	.LCFI42:
 3549              		.cfi_def_cfa_offset 8
 3550              		.cfi_offset 7, -8
 3551              		.cfi_offset 14, -4
 3552 0002 84B0     		sub	sp, sp, #16
 3553              	.LCFI43:
 3554              		.cfi_def_cfa_offset 24
 3555 0004 00AF     		add	r7, sp, #0
 3556              	.LCFI44:
 3557              		.cfi_def_cfa_register 7
 3558 0006 7860     		str	r0, [r7, #4]
 3559 0008 0A1C     		mov	r2, r1
 3560 000a FB1C     		add	r3, r7, #3
 3561 000c 1A70     		strb	r2, [r3]
 899:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 900:../Sources/system/CrystalClock.c ****   unsigned char fcrdiv_val;
 901:../Sources/system/CrystalClock.c ****   short i;
 902:../Sources/system/CrystalClock.c ****   
 903:../Sources/system/CrystalClock.c **** // Check MCG is in FBE mode
 904:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3562              		.loc 1 904 0
 3563 000e 944B     		ldr	r3, .L305
 3564 0010 9B79     		ldrb	r3, [r3, #6]
 3565 0012 DBB2     		uxtb	r3, r3
 3566 0014 1A1C     		mov	r2, r3
 3567 0016 0C23     		mov	r3, #12
 3568 0018 1340     		and	r3, r2
 3569 001a 9B08     		lsr	r3, r3, #2
 3570 001c 022B     		cmp	r3, #2
 3571 001e 14D1     		bne	.L271
 905:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3572              		.loc 1 905 0
 3573 0020 8F4B     		ldr	r3, .L305
 3574 0022 9B79     		ldrb	r3, [r3, #6]
 3575 0024 DBB2     		uxtb	r3, r3
 3576 0026 1A1C     		mov	r2, r3
 3577 0028 1023     		mov	r3, #16
 3578 002a 1340     		and	r3, r2
 904:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3579              		.loc 1 904 0
 3580 002c 0DD1     		bne	.L271
 906:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 3581              		.loc 1 906 0
 3582 002e 8C4B     		ldr	r3, .L305
 3583 0030 9B79     		ldrb	r3, [r3, #6]
 3584 0032 DBB2     		uxtb	r3, r3
 3585 0034 1A1C     		mov	r2, r3
 3586 0036 2023     		mov	r3, #32
 3587 0038 1340     		and	r3, r2
 905:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3588              		.loc 1 905 0
 3589 003a 06D1     		bne	.L271
 907:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 3590              		.loc 1 907 0
 3591 003c 884B     		ldr	r3, .L305
 3592 003e 5B78     		ldrb	r3, [r3, #1]
 3593 0040 DBB2     		uxtb	r3, r3
 3594 0042 1A1C     		mov	r2, r3
 3595 0044 0223     		mov	r3, #2
 3596 0046 1340     		and	r3, r2
 904:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3597              		.loc 1 904 0
 3598 0048 01D0     		beq	.L272
 3599              	.L271:
 908:../Sources/system/CrystalClock.c ****   {
 909:../Sources/system/CrystalClock.c ****     return 0x4;                                                       // return error code
 3600              		.loc 1 909 0
 3601 004a 0423     		mov	r3, #4
 3602 004c 04E1     		b	.L273
 3603              	.L272:
 910:../Sources/system/CrystalClock.c ****   }
 911:../Sources/system/CrystalClock.c **** 
 912:../Sources/system/CrystalClock.c **** // Check that the irc frequency matches the selected IRC 
 913:../Sources/system/CrystalClock.c ****   if (!(irc_select))
 3604              		.loc 1 913 0
 3605 004e FB1C     		add	r3, r7, #3
 3606 0050 1B78     		ldrb	r3, [r3]
 3607 0052 002B     		cmp	r3, #0
 3608 0054 09D1     		bne	.L274
 914:../Sources/system/CrystalClock.c ****   {    
 915:../Sources/system/CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 3609              		.loc 1 915 0
 3610 0056 7A68     		ldr	r2, [r7, #4]
 3611 0058 824B     		ldr	r3, .L305+4
 3612 005a 9A42     		cmp	r2, r3
 3613 005c 03DD     		ble	.L275
 3614              		.loc 1 915 0 is_stmt 0
 3615 005e 7A68     		ldr	r2, [r7, #4]
 3616 0060 814B     		ldr	r3, .L305+8
 3617 0062 9A42     		cmp	r2, r3
 3618 0064 0BDD     		ble	.L276
 3619              	.L275:
 3620              		.loc 1 915 0
 3621 0066 3123     		mov	r3, #49
 3622 0068 F6E0     		b	.L273
 3623              	.L274:
 916:../Sources/system/CrystalClock.c ****   }
 917:../Sources/system/CrystalClock.c ****   else
 918:../Sources/system/CrystalClock.c ****   {
 919:../Sources/system/CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 3624              		.loc 1 919 0 is_stmt 1
 3625 006a 7A68     		ldr	r2, [r7, #4]
 3626 006c 7F4B     		ldr	r3, .L305+12
 3627 006e 9A42     		cmp	r2, r3
 3628 0070 03DD     		ble	.L277
 3629              		.loc 1 919 0 is_stmt 0
 3630 0072 7A68     		ldr	r2, [r7, #4]
 3631 0074 7E4B     		ldr	r3, .L305+16
 3632 0076 9A42     		cmp	r2, r3
 3633 0078 01DD     		ble	.L276
 3634              	.L277:
 3635              		.loc 1 919 0
 3636 007a 3223     		mov	r3, #50
 3637 007c ECE0     		b	.L273
 3638              	.L276:
 920:../Sources/system/CrystalClock.c ****   }
 921:../Sources/system/CrystalClock.c ****   
 922:../Sources/system/CrystalClock.c **** // Select the required IRC
 923:../Sources/system/CrystalClock.c ****   if (irc_select)
 3639              		.loc 1 923 0 is_stmt 1
 3640 007e FB1C     		add	r3, r7, #3
 3641 0080 1B78     		ldrb	r3, [r3]
 3642 0082 002B     		cmp	r3, #0
 3643 0084 08D0     		beq	.L278
 924:../Sources/system/CrystalClock.c ****   {
 925:../Sources/system/CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 3644              		.loc 1 925 0
 3645 0086 764B     		ldr	r3, .L305
 3646 0088 754A     		ldr	r2, .L305
 3647 008a 5278     		ldrb	r2, [r2, #1]
 3648 008c D2B2     		uxtb	r2, r2
 3649 008e 0121     		mov	r1, #1
 3650 0090 0A43     		orr	r2, r1
 3651 0092 D2B2     		uxtb	r2, r2
 3652 0094 5A70     		strb	r2, [r3, #1]
 3653 0096 07E0     		b	.L279
 3654              	.L278:
 926:../Sources/system/CrystalClock.c ****   }
 927:../Sources/system/CrystalClock.c ****   else
 928:../Sources/system/CrystalClock.c ****   {
 929:../Sources/system/CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 3655              		.loc 1 929 0
 3656 0098 714B     		ldr	r3, .L305
 3657 009a 714A     		ldr	r2, .L305
 3658 009c 5278     		ldrb	r2, [r2, #1]
 3659 009e D2B2     		uxtb	r2, r2
 3660 00a0 0121     		mov	r1, #1
 3661 00a2 8A43     		bic	r2, r1
 3662 00a4 D2B2     		uxtb	r2, r2
 3663 00a6 5A70     		strb	r2, [r3, #1]
 3664              	.L279:
 930:../Sources/system/CrystalClock.c ****   }
 931:../Sources/system/CrystalClock.c ****   
 932:../Sources/system/CrystalClock.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
 933:../Sources/system/CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3665              		.loc 1 933 0
 3666 00a8 6D4B     		ldr	r3, .L305
 3667 00aa 6D4A     		ldr	r2, .L305
 3668 00ac 5279     		ldrb	r2, [r2, #5]
 3669 00ae D2B2     		uxtb	r2, r2
 3670 00b0 2021     		mov	r1, #32
 3671 00b2 8A43     		bic	r2, r1
 3672 00b4 D2B2     		uxtb	r2, r2
 3673 00b6 5A71     		strb	r2, [r3, #5]
 934:../Sources/system/CrystalClock.c ****   
 935:../Sources/system/CrystalClock.c **** // Select the IRC as the CLKS mux selection
 936:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 3674              		.loc 1 936 0
 3675 00b8 694A     		ldr	r2, .L305
 3676 00ba 3B1C     		mov	r3, r7
 3677 00bc 0D33     		add	r3, r3, #13
 3678 00be 1278     		ldrb	r2, [r2]
 3679 00c0 1A70     		strb	r2, [r3]
 937:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 3680              		.loc 1 937 0
 3681 00c2 3B1C     		mov	r3, r7
 3682 00c4 0D33     		add	r3, r3, #13
 3683 00c6 3A1C     		mov	r2, r7
 3684 00c8 0D32     		add	r2, r2, #13
 3685 00ca 1178     		ldrb	r1, [r2]
 3686 00cc 3F22     		mov	r2, #63
 3687 00ce 0A40     		and	r2, r1
 3688 00d0 1A70     		strb	r2, [r3]
 938:../Sources/system/CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 3689              		.loc 1 938 0
 3690 00d2 3B1C     		mov	r3, r7
 3691 00d4 0D33     		add	r3, r3, #13
 3692 00d6 3A1C     		mov	r2, r7
 3693 00d8 0D32     		add	r2, r2, #13
 3694 00da 1278     		ldrb	r2, [r2]
 3695 00dc 4421     		mov	r1, #68
 3696 00de 0A43     		orr	r2, r1
 3697 00e0 1A70     		strb	r2, [r3]
 939:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 3698              		.loc 1 939 0
 3699 00e2 5F4B     		ldr	r3, .L305
 3700 00e4 3A1C     		mov	r2, r7
 3701 00e6 0D32     		add	r2, r2, #13
 3702 00e8 1278     		ldrb	r2, [r2]
 3703 00ea 1A70     		strb	r2, [r3]
 940:../Sources/system/CrystalClock.c ****   
 941:../Sources/system/CrystalClock.c **** // wait until internal reference switches to requested irc.
 942:../Sources/system/CrystalClock.c ****   if (!(irc_select))
 3704              		.loc 1 942 0
 3705 00ec FB1C     		add	r3, r7, #3
 3706 00ee 1B78     		ldrb	r3, [r3]
 3707 00f0 002B     		cmp	r3, #0
 3708 00f2 24D1     		bne	.L280
 943:../Sources/system/CrystalClock.c ****   {
 944:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3709              		.loc 1 944 0
 3710 00f4 3B1C     		mov	r3, r7
 3711 00f6 0E33     		add	r3, r3, #14
 3712 00f8 0022     		mov	r2, #0
 3713 00fa 1A80     		strh	r2, [r3]
 3714 00fc 0DE0     		b	.L281
 3715              	.L284:
 945:../Sources/system/CrystalClock.c ****     {
 946:../Sources/system/CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3716              		.loc 1 946 0
 3717 00fe 584B     		ldr	r3, .L305
 3718 0100 9B79     		ldrb	r3, [r3, #6]
 3719 0102 DBB2     		uxtb	r3, r3
 3720 0104 1A1C     		mov	r2, r3
 3721 0106 0123     		mov	r3, #1
 3722 0108 1340     		and	r3, r2
 3723 010a 0ED0     		beq	.L301
 3724              	.L282:
 944:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3725              		.loc 1 944 0
 3726 010c 3B1C     		mov	r3, r7
 3727 010e 0E33     		add	r3, r3, #14
 3728 0110 3A1C     		mov	r2, r7
 3729 0112 0E32     		add	r2, r2, #14
 3730 0114 1288     		ldrh	r2, [r2]
 3731 0116 0132     		add	r2, r2, #1
 3732 0118 1A80     		strh	r2, [r3]
 3733              	.L281:
 944:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3734              		.loc 1 944 0 is_stmt 0
 3735 011a 3B1C     		mov	r3, r7
 3736 011c 0E33     		add	r3, r3, #14
 3737 011e 0021     		mov	r1, #0
 3738 0120 5A5E     		ldrsh	r2, [r3, r1]
 3739 0122 544B     		ldr	r3, .L305+20
 3740 0124 9A42     		cmp	r2, r3
 3741 0126 EADD     		ble	.L284
 3742 0128 00E0     		b	.L283
 3743              	.L301:
 3744              		.loc 1 946 0 is_stmt 1
 3745 012a C046     		mov	r8, r8
 3746              	.L283:
 947:../Sources/system/CrystalClock.c ****     }
 948:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 3747              		.loc 1 948 0
 3748 012c 4C4B     		ldr	r3, .L305
 3749 012e 9B79     		ldrb	r3, [r3, #6]
 3750 0130 DBB2     		uxtb	r3, r3
 3751 0132 1A1C     		mov	r2, r3
 3752 0134 0123     		mov	r3, #1
 3753 0136 1340     		and	r3, r2
 3754 0138 26D0     		beq	.L285
 3755              		.loc 1 948 0 is_stmt 0
 3756 013a 1323     		mov	r3, #19
 3757 013c 8CE0     		b	.L273
 3758              	.L280:
 949:../Sources/system/CrystalClock.c ****   }
 950:../Sources/system/CrystalClock.c ****   else
 951:../Sources/system/CrystalClock.c ****   {
 952:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3759              		.loc 1 952 0 is_stmt 1
 3760 013e 3B1C     		mov	r3, r7
 3761 0140 0E33     		add	r3, r3, #14
 3762 0142 0022     		mov	r2, #0
 3763 0144 1A80     		strh	r2, [r3]
 3764 0146 0DE0     		b	.L286
 3765              	.L289:
 953:../Sources/system/CrystalClock.c ****     {
 954:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3766              		.loc 1 954 0
 3767 0148 454B     		ldr	r3, .L305
 3768 014a 9B79     		ldrb	r3, [r3, #6]
 3769 014c DBB2     		uxtb	r3, r3
 3770 014e 1A1C     		mov	r2, r3
 3771 0150 0123     		mov	r3, #1
 3772 0152 1340     		and	r3, r2
 3773 0154 0ED1     		bne	.L302
 3774              	.L287:
 952:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3775              		.loc 1 952 0
 3776 0156 3B1C     		mov	r3, r7
 3777 0158 0E33     		add	r3, r3, #14
 3778 015a 3A1C     		mov	r2, r7
 3779 015c 0E32     		add	r2, r2, #14
 3780 015e 1288     		ldrh	r2, [r2]
 3781 0160 0132     		add	r2, r2, #1
 3782 0162 1A80     		strh	r2, [r3]
 3783              	.L286:
 952:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3784              		.loc 1 952 0 is_stmt 0
 3785 0164 3B1C     		mov	r3, r7
 3786 0166 0E33     		add	r3, r3, #14
 3787 0168 0021     		mov	r1, #0
 3788 016a 5A5E     		ldrsh	r2, [r3, r1]
 3789 016c 414B     		ldr	r3, .L305+20
 3790 016e 9A42     		cmp	r2, r3
 3791 0170 EADD     		ble	.L289
 3792 0172 00E0     		b	.L288
 3793              	.L302:
 3794              		.loc 1 954 0 is_stmt 1
 3795 0174 C046     		mov	r8, r8
 3796              	.L288:
 955:../Sources/system/CrystalClock.c ****     }
 956:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 3797              		.loc 1 956 0
 3798 0176 3A4B     		ldr	r3, .L305
 3799 0178 9B79     		ldrb	r3, [r3, #6]
 3800 017a DBB2     		uxtb	r3, r3
 3801 017c 1A1C     		mov	r2, r3
 3802 017e 0123     		mov	r3, #1
 3803 0180 1340     		and	r3, r2
 3804 0182 01D1     		bne	.L285
 3805              		.loc 1 956 0 is_stmt 0
 3806 0184 1423     		mov	r3, #20
 3807 0186 67E0     		b	.L273
 3808              	.L285:
 957:../Sources/system/CrystalClock.c ****   }
 958:../Sources/system/CrystalClock.c ****  
 959:../Sources/system/CrystalClock.c **** // Wait for clock status bits to update
 960:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3809              		.loc 1 960 0 is_stmt 1
 3810 0188 3B1C     		mov	r3, r7
 3811 018a 0E33     		add	r3, r3, #14
 3812 018c 0022     		mov	r2, #0
 3813 018e 1A80     		strh	r2, [r3]
 3814 0190 0FE0     		b	.L290
 3815              	.L293:
 961:../Sources/system/CrystalClock.c ****   {
 962:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3816              		.loc 1 962 0
 3817 0192 334B     		ldr	r3, .L305
 3818 0194 9B79     		ldrb	r3, [r3, #6]
 3819 0196 DBB2     		uxtb	r3, r3
 3820 0198 1A1C     		mov	r2, r3
 3821 019a 0C23     		mov	r3, #12
 3822 019c 1340     		and	r3, r2
 3823 019e 9B08     		lsr	r3, r3, #2
 3824 01a0 012B     		cmp	r3, #1
 3825 01a2 0ED0     		beq	.L303
 3826              	.L291:
 960:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3827              		.loc 1 960 0
 3828 01a4 3B1C     		mov	r3, r7
 3829 01a6 0E33     		add	r3, r3, #14
 3830 01a8 3A1C     		mov	r2, r7
 3831 01aa 0E32     		add	r2, r2, #14
 3832 01ac 1288     		ldrh	r2, [r2]
 3833 01ae 0132     		add	r2, r2, #1
 3834 01b0 1A80     		strh	r2, [r3]
 3835              	.L290:
 960:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3836              		.loc 1 960 0 is_stmt 0
 3837 01b2 3B1C     		mov	r3, r7
 3838 01b4 0E33     		add	r3, r3, #14
 3839 01b6 0021     		mov	r1, #0
 3840 01b8 5A5E     		ldrsh	r2, [r3, r1]
 3841 01ba 2E4B     		ldr	r3, .L305+20
 3842 01bc 9A42     		cmp	r2, r3
 3843 01be E8DD     		ble	.L293
 3844 01c0 00E0     		b	.L292
 3845              	.L303:
 3846              		.loc 1 962 0 is_stmt 1
 3847 01c2 C046     		mov	r8, r8
 3848              	.L292:
 963:../Sources/system/CrystalClock.c ****   }
 964:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 3849              		.loc 1 964 0
 3850 01c4 264B     		ldr	r3, .L305
 3851 01c6 9B79     		ldrb	r3, [r3, #6]
 3852 01c8 DBB2     		uxtb	r3, r3
 3853 01ca 1A1C     		mov	r2, r3
 3854 01cc 0C23     		mov	r3, #12
 3855 01ce 1340     		and	r3, r2
 3856 01d0 9B08     		lsr	r3, r3, #2
 3857 01d2 012B     		cmp	r3, #1
 3858 01d4 01D0     		beq	.L294
 3859              		.loc 1 964 0 is_stmt 0
 3860 01d6 1923     		mov	r3, #25
 3861 01d8 3EE0     		b	.L273
 3862              	.L294:
 965:../Sources/system/CrystalClock.c ****   
 966:../Sources/system/CrystalClock.c ****   // wait for Reference clock Status bit to set
 967:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3863              		.loc 1 967 0 is_stmt 1
 3864 01da 3B1C     		mov	r3, r7
 3865 01dc 0E33     		add	r3, r3, #14
 3866 01de 0022     		mov	r2, #0
 3867 01e0 1A80     		strh	r2, [r3]
 3868 01e2 0DE0     		b	.L295
 3869              	.L298:
 968:../Sources/system/CrystalClock.c ****   {
 969:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3870              		.loc 1 969 0
 3871 01e4 1E4B     		ldr	r3, .L305
 3872 01e6 9B79     		ldrb	r3, [r3, #6]
 3873 01e8 DBB2     		uxtb	r3, r3
 3874 01ea 1A1C     		mov	r2, r3
 3875 01ec 1023     		mov	r3, #16
 3876 01ee 1340     		and	r3, r2
 3877 01f0 0ED1     		bne	.L304
 3878              	.L296:
 967:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3879              		.loc 1 967 0
 3880 01f2 3B1C     		mov	r3, r7
 3881 01f4 0E33     		add	r3, r3, #14
 3882 01f6 3A1C     		mov	r2, r7
 3883 01f8 0E32     		add	r2, r2, #14
 3884 01fa 1288     		ldrh	r2, [r2]
 3885 01fc 0132     		add	r2, r2, #1
 3886 01fe 1A80     		strh	r2, [r3]
 3887              	.L295:
 967:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3888              		.loc 1 967 0 is_stmt 0
 3889 0200 3B1C     		mov	r3, r7
 3890 0202 0E33     		add	r3, r3, #14
 3891 0204 0021     		mov	r1, #0
 3892 0206 5A5E     		ldrsh	r2, [r3, r1]
 3893 0208 1A4B     		ldr	r3, .L305+20
 3894 020a 9A42     		cmp	r2, r3
 3895 020c EADD     		ble	.L298
 3896 020e 00E0     		b	.L297
 3897              	.L304:
 3898              		.loc 1 969 0 is_stmt 1
 3899 0210 C046     		mov	r8, r8
 3900              	.L297:
 970:../Sources/system/CrystalClock.c ****   }
 971:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 3901              		.loc 1 971 0
 3902 0212 134B     		ldr	r3, .L305
 3903 0214 9B79     		ldrb	r3, [r3, #6]
 3904 0216 DBB2     		uxtb	r3, r3
 3905 0218 1A1C     		mov	r2, r3
 3906 021a 1023     		mov	r3, #16
 3907 021c 1340     		and	r3, r2
 3908 021e 01D1     		bne	.L299
 3909              		.loc 1 971 0 is_stmt 0
 3910 0220 1223     		mov	r3, #18
 3911 0222 19E0     		b	.L273
 3912              	.L299:
 972:../Sources/system/CrystalClock.c ****   
 973:../Sources/system/CrystalClock.c **** // Now in FBI mode
 974:../Sources/system/CrystalClock.c ****   
 975:../Sources/system/CrystalClock.c ****   if (irc_select)
 3913              		.loc 1 975 0 is_stmt 1
 3914 0224 FB1C     		add	r3, r7, #3
 3915 0226 1B78     		ldrb	r3, [r3]
 3916 0228 002B     		cmp	r3, #0
 3917 022a 14D0     		beq	.L300
 976:../Sources/system/CrystalClock.c ****   {
 977:../Sources/system/CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3918              		.loc 1 977 0
 3919 022c 0C4B     		ldr	r3, .L305
 3920 022e 1B7A     		ldrb	r3, [r3, #8]
 3921 0230 DBB2     		uxtb	r3, r3
 3922 0232 1A1C     		mov	r2, r3
 3923 0234 0E23     		mov	r3, #14
 3924 0236 1340     		and	r3, r2
 3925 0238 5B08     		lsr	r3, r3, #1
 3926 023a 0122     		mov	r2, #1
 3927 023c 9A40     		lsl	r2, r2, r3
 3928 023e 3B1C     		mov	r3, r7
 3929 0240 0C33     		add	r3, r3, #12
 3930 0242 1A70     		strb	r2, [r3]
 978:../Sources/system/CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV
 3931              		.loc 1 978 0
 3932 0244 3B1C     		mov	r3, r7
 3933 0246 0C33     		add	r3, r3, #12
 3934 0248 1B78     		ldrb	r3, [r3]
 3935 024a 7868     		ldr	r0, [r7, #4]
 3936 024c 191C     		mov	r1, r3
 3937 024e FFF7FEFF 		bl	__aeabi_idiv
 3938 0252 031C     		mov	r3, r0
 3939 0254 00E0     		b	.L273
 3940              	.L300:
 979:../Sources/system/CrystalClock.c ****   }
 980:../Sources/system/CrystalClock.c ****   else
 981:../Sources/system/CrystalClock.c ****   {
 982:../Sources/system/CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 3941              		.loc 1 982 0
 3942 0256 7B68     		ldr	r3, [r7, #4]
 3943              	.L273:
 983:../Sources/system/CrystalClock.c ****   }
 984:../Sources/system/CrystalClock.c **** } //fbe_fbi
 3944              		.loc 1 984 0
 3945 0258 181C     		mov	r0, r3
 3946 025a BD46     		mov	sp, r7
 3947 025c 04B0     		add	sp, sp, #16
 3948              		@ sp needed for prologue
 3949 025e 80BD     		pop	{r7, pc}
 3950              	.L306:
 3951              		.align	2
 3952              	.L305:
 3953 0260 00400640 		.word	1074151424
 3954 0264 117A0000 		.word	31249
 3955 0268 97980000 		.word	39063
 3956 026c BFC62D00 		.word	2999999
 3957 0270 404B4C00 		.word	5000000
 3958 0274 CF070000 		.word	1999
 3959              		.cfi_endproc
 3960              	.LFE14:
 3962              		.section	.text.fbi_fbe,"ax",%progbits
 3963              		.align	2
 3964              		.global	fbi_fbe
 3965              		.code	16
 3966              		.thumb_func
 3968              	fbi_fbe:
 3969              	.LFB15:
 985:../Sources/system/CrystalClock.c **** 
 986:../Sources/system/CrystalClock.c **** 
 987:../Sources/system/CrystalClock.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 988:../Sources/system/CrystalClock.c **** {
 3970              		.loc 1 988 0
 3971              		.cfi_startproc
 3972 0000 80B5     		push	{r7, lr}
 3973              	.LCFI45:
 3974              		.cfi_def_cfa_offset 8
 3975              		.cfi_offset 7, -8
 3976              		.cfi_offset 14, -4
 3977 0002 84B0     		sub	sp, sp, #16
 3978              	.LCFI46:
 3979              		.cfi_def_cfa_offset 24
 3980 0004 00AF     		add	r7, sp, #0
 3981              	.LCFI47:
 3982              		.cfi_def_cfa_register 7
 3983 0006 7860     		str	r0, [r7, #4]
 3984 0008 FB1C     		add	r3, r7, #3
 3985 000a 1970     		strb	r1, [r3]
 3986 000c BB1C     		add	r3, r7, #2
 3987 000e 1A70     		strb	r2, [r3]
 989:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
 990:../Sources/system/CrystalClock.c ****   unsigned char frdiv_val;
 991:../Sources/system/CrystalClock.c ****   short i;
 992:../Sources/system/CrystalClock.c ****   
 993:../Sources/system/CrystalClock.c **** // check if in FBI mode
 994:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 3988              		.loc 1 994 0
 3989 0010 B84B     		ldr	r3, .L343
 3990 0012 9B79     		ldrb	r3, [r3, #6]
 3991 0014 DBB2     		uxtb	r3, r3
 3992 0016 1A1C     		mov	r2, r3
 3993 0018 0C23     		mov	r3, #12
 3994 001a 1340     		and	r3, r2
 3995 001c 9B08     		lsr	r3, r3, #2
 3996 001e 012B     		cmp	r3, #1
 3997 0020 14D1     		bne	.L308
 995:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3998              		.loc 1 995 0
 3999 0022 B44B     		ldr	r3, .L343
 4000 0024 9B79     		ldrb	r3, [r3, #6]
 4001 0026 DBB2     		uxtb	r3, r3
 4002 0028 1A1C     		mov	r2, r3
 4003 002a 1023     		mov	r3, #16
 4004 002c 1340     		and	r3, r2
 994:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4005              		.loc 1 994 0
 4006 002e 0DD0     		beq	.L308
 996:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4007              		.loc 1 996 0
 4008 0030 B04B     		ldr	r3, .L343
 4009 0032 9B79     		ldrb	r3, [r3, #6]
 4010 0034 DBB2     		uxtb	r3, r3
 4011 0036 1A1C     		mov	r2, r3
 4012 0038 2023     		mov	r3, #32
 4013 003a 1340     		and	r3, r2
 995:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4014              		.loc 1 995 0
 4015 003c 06D1     		bne	.L308
 997:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4016              		.loc 1 997 0
 4017 003e AD4B     		ldr	r3, .L343
 4018 0040 5B78     		ldrb	r3, [r3, #1]
 4019 0042 DBB2     		uxtb	r3, r3
 4020 0044 1A1C     		mov	r2, r3
 4021 0046 0223     		mov	r3, #2
 4022 0048 1340     		and	r3, r2
 994:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4023              		.loc 1 994 0
 4024 004a 01D0     		beq	.L309
 4025              	.L308:
 998:../Sources/system/CrystalClock.c ****   {  
 999:../Sources/system/CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 4026              		.loc 1 999 0
 4027 004c 0323     		mov	r3, #3
 4028 004e 4DE1     		b	.L310
 4029              	.L309:
1000:../Sources/system/CrystalClock.c ****   }
1001:../Sources/system/CrystalClock.c ****  
1002:../Sources/system/CrystalClock.c **** // check external frequency is less than the maximum frequency
1003:../Sources/system/CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 4030              		.loc 1 1003 0
 4031 0050 7A68     		ldr	r2, [r7, #4]
 4032 0052 A94B     		ldr	r3, .L343+4
 4033 0054 9A42     		cmp	r2, r3
 4034 0056 01DD     		ble	.L311
 4035              		.loc 1 1003 0 is_stmt 0
 4036 0058 2123     		mov	r3, #33
 4037 005a 47E1     		b	.L310
 4038              	.L311:
1004:../Sources/system/CrystalClock.c ****   
1005:../Sources/system/CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
1006:../Sources/system/CrystalClock.c ****   if (erefs_val)
 4039              		.loc 1 1006 0 is_stmt 1
 4040 005c BB1C     		add	r3, r7, #2
 4041 005e 1B78     		ldrb	r3, [r3]
 4042 0060 002B     		cmp	r3, #0
 4043 0062 11D0     		beq	.L312
1007:../Sources/system/CrystalClock.c ****   {
1008:../Sources/system/CrystalClock.c ****     if ((crystal_val < 30000) ||
 4044              		.loc 1 1008 0
 4045 0064 7A68     		ldr	r2, [r7, #4]
 4046 0066 A54B     		ldr	r3, .L343+8
 4047 0068 9A42     		cmp	r2, r3
 4048 006a 0BDD     		ble	.L313
 4049              		.loc 1 1008 0 is_stmt 0
 4050 006c 7A68     		ldr	r2, [r7, #4]
 4051 006e A44B     		ldr	r3, .L343+12
 4052 0070 9A42     		cmp	r2, r3
 4053 0072 03DD     		ble	.L314
1009:../Sources/system/CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4054              		.loc 1 1009 0 is_stmt 1
 4055 0074 7A68     		ldr	r2, [r7, #4]
 4056 0076 A34B     		ldr	r3, .L343+16
 4057 0078 9A42     		cmp	r2, r3
 4058 007a 03DD     		ble	.L313
 4059              	.L314:
 4060              		.loc 1 1009 0 is_stmt 0
 4061 007c 7A68     		ldr	r2, [r7, #4]
 4062 007e A24B     		ldr	r3, .L343+20
 4063 0080 9A42     		cmp	r2, r3
 4064 0082 01DD     		ble	.L312
 4065              	.L313:
1010:../Sources/system/CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 4066              		.loc 1 1010 0 is_stmt 1
 4067 0084 2223     		mov	r3, #34
 4068 0086 31E1     		b	.L310
 4069              	.L312:
1011:../Sources/system/CrystalClock.c ****   }
1012:../Sources/system/CrystalClock.c **** 
1013:../Sources/system/CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1014:../Sources/system/CrystalClock.c ****   if (hgo_val > 0)
 4070              		.loc 1 1014 0
 4071 0088 FB1C     		add	r3, r7, #3
 4072 008a 1B78     		ldrb	r3, [r3]
 4073 008c 002B     		cmp	r3, #0
 4074 008e 02D0     		beq	.L315
1015:../Sources/system/CrystalClock.c ****   {
1016:../Sources/system/CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 4075              		.loc 1 1016 0
 4076 0090 FB1C     		add	r3, r7, #3
 4077 0092 0122     		mov	r2, #1
 4078 0094 1A70     		strb	r2, [r3]
 4079              	.L315:
1017:../Sources/system/CrystalClock.c ****   }
1018:../Sources/system/CrystalClock.c **** 
1019:../Sources/system/CrystalClock.c **** // configure the MCG_C2 register
1020:../Sources/system/CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1021:../Sources/system/CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
1022:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C2;
 4080              		.loc 1 1022 0
 4081 0096 974A     		ldr	r2, .L343
 4082 0098 3B1C     		mov	r3, r7
 4083 009a 0F33     		add	r3, r3, #15
 4084 009c 5278     		ldrb	r2, [r2, #1]
 4085 009e 1A70     		strb	r2, [r3]
1023:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 4086              		.loc 1 1023 0
 4087 00a0 3B1C     		mov	r3, r7
 4088 00a2 0F33     		add	r3, r3, #15
 4089 00a4 3A1C     		mov	r2, r7
 4090 00a6 0F32     		add	r2, r2, #15
 4091 00a8 1278     		ldrb	r2, [r2]
 4092 00aa 3C21     		mov	r1, #60
 4093 00ac 8A43     		bic	r2, r1
 4094 00ae 1A70     		strb	r2, [r3]
1024:../Sources/system/CrystalClock.c ****   if (crystal_val <= 40000)
 4095              		.loc 1 1024 0
 4096 00b0 7A68     		ldr	r2, [r7, #4]
 4097 00b2 934B     		ldr	r3, .L343+12
 4098 00b4 9A42     		cmp	r2, r3
 4099 00b6 11DC     		bgt	.L316
1025:../Sources/system/CrystalClock.c ****   {
1026:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4100              		.loc 1 1026 0
 4101 00b8 FB1C     		add	r3, r7, #3
 4102 00ba 1B78     		ldrb	r3, [r3]
 4103 00bc DB00     		lsl	r3, r3, #3
 4104 00be DAB2     		uxtb	r2, r3
 4105 00c0 BB1C     		add	r3, r7, #2
 4106 00c2 1B78     		ldrb	r3, [r3]
 4107 00c4 9B00     		lsl	r3, r3, #2
 4108 00c6 DBB2     		uxtb	r3, r3
 4109 00c8 1343     		orr	r3, r2
 4110 00ca D9B2     		uxtb	r1, r3
 4111 00cc 3B1C     		mov	r3, r7
 4112 00ce 0F33     		add	r3, r3, #15
 4113 00d0 3A1C     		mov	r2, r7
 4114 00d2 0F32     		add	r2, r2, #15
 4115 00d4 1278     		ldrb	r2, [r2]
 4116 00d6 0A43     		orr	r2, r1
 4117 00d8 1A70     		strb	r2, [r3]
 4118 00da 2CE0     		b	.L317
 4119              	.L316:
1027:../Sources/system/CrystalClock.c ****   }
1028:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 8000000)
 4120              		.loc 1 1028 0
 4121 00dc 7A68     		ldr	r2, [r7, #4]
 4122 00de 8B4B     		ldr	r3, .L343+24
 4123 00e0 9A42     		cmp	r2, r3
 4124 00e2 14DC     		bgt	.L318
1029:../Sources/system/CrystalClock.c ****   {
1030:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4125              		.loc 1 1030 0
 4126 00e4 FB1C     		add	r3, r7, #3
 4127 00e6 1B78     		ldrb	r3, [r3]
 4128 00e8 DB00     		lsl	r3, r3, #3
 4129 00ea DAB2     		uxtb	r2, r3
 4130 00ec BB1C     		add	r3, r7, #2
 4131 00ee 1B78     		ldrb	r3, [r3]
 4132 00f0 9B00     		lsl	r3, r3, #2
 4133 00f2 DBB2     		uxtb	r3, r3
 4134 00f4 1343     		orr	r3, r2
 4135 00f6 DAB2     		uxtb	r2, r3
 4136 00f8 3B1C     		mov	r3, r7
 4137 00fa 0F33     		add	r3, r3, #15
 4138 00fc 1B78     		ldrb	r3, [r3]
 4139 00fe 1343     		orr	r3, r2
 4140 0100 DAB2     		uxtb	r2, r3
 4141 0102 3B1C     		mov	r3, r7
 4142 0104 0F33     		add	r3, r3, #15
 4143 0106 1021     		mov	r1, #16
 4144 0108 0A43     		orr	r2, r1
 4145 010a 1A70     		strb	r2, [r3]
 4146 010c 13E0     		b	.L317
 4147              	.L318:
1031:../Sources/system/CrystalClock.c ****   }
1032:../Sources/system/CrystalClock.c ****   else
1033:../Sources/system/CrystalClock.c ****   {
1034:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4148              		.loc 1 1034 0
 4149 010e FB1C     		add	r3, r7, #3
 4150 0110 1B78     		ldrb	r3, [r3]
 4151 0112 DB00     		lsl	r3, r3, #3
 4152 0114 DAB2     		uxtb	r2, r3
 4153 0116 BB1C     		add	r3, r7, #2
 4154 0118 1B78     		ldrb	r3, [r3]
 4155 011a 9B00     		lsl	r3, r3, #2
 4156 011c DBB2     		uxtb	r3, r3
 4157 011e 1343     		orr	r3, r2
 4158 0120 DAB2     		uxtb	r2, r3
 4159 0122 3B1C     		mov	r3, r7
 4160 0124 0F33     		add	r3, r3, #15
 4161 0126 1B78     		ldrb	r3, [r3]
 4162 0128 1343     		orr	r3, r2
 4163 012a DAB2     		uxtb	r2, r3
 4164 012c 3B1C     		mov	r3, r7
 4165 012e 0F33     		add	r3, r3, #15
 4166 0130 2021     		mov	r1, #32
 4167 0132 0A43     		orr	r2, r1
 4168 0134 1A70     		strb	r2, [r3]
 4169              	.L317:
1035:../Sources/system/CrystalClock.c ****   }
1036:../Sources/system/CrystalClock.c ****   MCG_C2 = temp_reg;
 4170              		.loc 1 1036 0
 4171 0136 6F4B     		ldr	r3, .L343
 4172 0138 3A1C     		mov	r2, r7
 4173 013a 0F32     		add	r2, r2, #15
 4174 013c 1278     		ldrb	r2, [r2]
 4175 013e 5A70     		strb	r2, [r3, #1]
1037:../Sources/system/CrystalClock.c **** 
1038:../Sources/system/CrystalClock.c **** // determine FRDIV based on reference clock frequency
1039:../Sources/system/CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1040:../Sources/system/CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4176              		.loc 1 1040 0
 4177 0140 7A68     		ldr	r2, [r7, #4]
 4178 0142 734B     		ldr	r3, .L343+28
 4179 0144 9A42     		cmp	r2, r3
 4180 0146 04DC     		bgt	.L319
 4181              		.loc 1 1040 0 is_stmt 0
 4182 0148 3B1C     		mov	r3, r7
 4183 014a 0E33     		add	r3, r3, #14
 4184 014c 0022     		mov	r2, #0
 4185 014e 1A70     		strb	r2, [r3]
 4186 0150 27E0     		b	.L320
 4187              	.L319:
1041:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4188              		.loc 1 1041 0 is_stmt 1
 4189 0152 7A68     		ldr	r2, [r7, #4]
 4190 0154 6F4B     		ldr	r3, .L343+32
 4191 0156 9A42     		cmp	r2, r3
 4192 0158 04DC     		bgt	.L321
 4193              		.loc 1 1041 0 is_stmt 0
 4194 015a 3B1C     		mov	r3, r7
 4195 015c 0E33     		add	r3, r3, #14
 4196 015e 0122     		mov	r2, #1
 4197 0160 1A70     		strb	r2, [r3]
 4198 0162 1EE0     		b	.L320
 4199              	.L321:
1042:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4200              		.loc 1 1042 0 is_stmt 1
 4201 0164 7A68     		ldr	r2, [r7, #4]
 4202 0166 6C4B     		ldr	r3, .L343+36
 4203 0168 9A42     		cmp	r2, r3
 4204 016a 04DC     		bgt	.L322
 4205              		.loc 1 1042 0 is_stmt 0
 4206 016c 3B1C     		mov	r3, r7
 4207 016e 0E33     		add	r3, r3, #14
 4208 0170 0222     		mov	r2, #2
 4209 0172 1A70     		strb	r2, [r3]
 4210 0174 15E0     		b	.L320
 4211              	.L322:
1043:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4212              		.loc 1 1043 0 is_stmt 1
 4213 0176 7A68     		ldr	r2, [r7, #4]
 4214 0178 684B     		ldr	r3, .L343+40
 4215 017a 9A42     		cmp	r2, r3
 4216 017c 04DC     		bgt	.L323
 4217              		.loc 1 1043 0 is_stmt 0
 4218 017e 3B1C     		mov	r3, r7
 4219 0180 0E33     		add	r3, r3, #14
 4220 0182 0322     		mov	r2, #3
 4221 0184 1A70     		strb	r2, [r3]
 4222 0186 0CE0     		b	.L320
 4223              	.L323:
1044:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4224              		.loc 1 1044 0 is_stmt 1
 4225 0188 7A68     		ldr	r2, [r7, #4]
 4226 018a 654B     		ldr	r3, .L343+44
 4227 018c 9A42     		cmp	r2, r3
 4228 018e 04DC     		bgt	.L324
 4229              		.loc 1 1044 0 is_stmt 0
 4230 0190 3B1C     		mov	r3, r7
 4231 0192 0E33     		add	r3, r3, #14
 4232 0194 0422     		mov	r2, #4
 4233 0196 1A70     		strb	r2, [r3]
 4234 0198 03E0     		b	.L320
 4235              	.L324:
1045:../Sources/system/CrystalClock.c ****   else {frdiv_val = 5;}
 4236              		.loc 1 1045 0 is_stmt 1
 4237 019a 3B1C     		mov	r3, r7
 4238 019c 0E33     		add	r3, r3, #14
 4239 019e 0522     		mov	r2, #5
 4240 01a0 1A70     		strb	r2, [r3]
 4241              	.L320:
1046:../Sources/system/CrystalClock.c ****   
1047:../Sources/system/CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1048:../Sources/system/CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1049:../Sources/system/CrystalClock.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1050:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 4242              		.loc 1 1050 0
 4243 01a2 544A     		ldr	r2, .L343
 4244 01a4 3B1C     		mov	r3, r7
 4245 01a6 0F33     		add	r3, r3, #15
 4246 01a8 1278     		ldrb	r2, [r2]
 4247 01aa 1A70     		strb	r2, [r3]
1051:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 4248              		.loc 1 1051 0
 4249 01ac 3B1C     		mov	r3, r7
 4250 01ae 0F33     		add	r3, r3, #15
 4251 01b0 3A1C     		mov	r2, r7
 4252 01b2 0F32     		add	r2, r2, #15
 4253 01b4 1178     		ldrb	r1, [r2]
 4254 01b6 0322     		mov	r2, #3
 4255 01b8 0A40     		and	r2, r1
 4256 01ba 1A70     		strb	r2, [r3]
1052:../Sources/system/CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4257              		.loc 1 1052 0
 4258 01bc 3B1C     		mov	r3, r7
 4259 01be 0E33     		add	r3, r3, #14
 4260 01c0 1B78     		ldrb	r3, [r3]
 4261 01c2 DB00     		lsl	r3, r3, #3
 4262 01c4 DAB2     		uxtb	r2, r3
 4263 01c6 3823     		mov	r3, #56
 4264 01c8 1340     		and	r3, r2
 4265 01ca DAB2     		uxtb	r2, r3
 4266 01cc 3B1C     		mov	r3, r7
 4267 01ce 0F33     		add	r3, r3, #15
 4268 01d0 1B78     		ldrb	r3, [r3]
 4269 01d2 1343     		orr	r3, r2
 4270 01d4 DAB2     		uxtb	r2, r3
 4271 01d6 3B1C     		mov	r3, r7
 4272 01d8 0F33     		add	r3, r3, #15
 4273 01da 8021     		mov	r1, #128
 4274 01dc 4942     		neg	r1, r1
 4275 01de 0A43     		orr	r2, r1
 4276 01e0 1A70     		strb	r2, [r3]
1053:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg;
 4277              		.loc 1 1053 0
 4278 01e2 444B     		ldr	r3, .L343
 4279 01e4 3A1C     		mov	r2, r7
 4280 01e6 0F32     		add	r2, r2, #15
 4281 01e8 1278     		ldrb	r2, [r2]
 4282 01ea 1A70     		strb	r2, [r3]
1054:../Sources/system/CrystalClock.c **** 
1055:../Sources/system/CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
1056:../Sources/system/CrystalClock.c ****   if (erefs_val)
 4283              		.loc 1 1056 0
 4284 01ec BB1C     		add	r3, r7, #2
 4285 01ee 1B78     		ldrb	r3, [r3]
 4286 01f0 002B     		cmp	r3, #0
 4287 01f2 24D0     		beq	.L325
1057:../Sources/system/CrystalClock.c ****   {
1058:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 4288              		.loc 1 1058 0
 4289 01f4 3B1C     		mov	r3, r7
 4290 01f6 0C33     		add	r3, r3, #12
 4291 01f8 0022     		mov	r2, #0
 4292 01fa 1A80     		strh	r2, [r3]
 4293 01fc 0DE0     		b	.L326
 4294              	.L329:
1059:../Sources/system/CrystalClock.c ****     {
1060:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4295              		.loc 1 1060 0
 4296 01fe 3D4B     		ldr	r3, .L343
 4297 0200 9B79     		ldrb	r3, [r3, #6]
 4298 0202 DBB2     		uxtb	r3, r3
 4299 0204 1A1C     		mov	r2, r3
 4300 0206 0223     		mov	r3, #2
 4301 0208 1340     		and	r3, r2
 4302 020a 0ED1     		bne	.L340
 4303              	.L327:
1058:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 4304              		.loc 1 1058 0
 4305 020c 3B1C     		mov	r3, r7
 4306 020e 0C33     		add	r3, r3, #12
 4307 0210 3A1C     		mov	r2, r7
 4308 0212 0C32     		add	r2, r2, #12
 4309 0214 1288     		ldrh	r2, [r2]
 4310 0216 0132     		add	r2, r2, #1
 4311 0218 1A80     		strh	r2, [r3]
 4312              	.L326:
1058:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 4313              		.loc 1 1058 0 is_stmt 0
 4314 021a 3B1C     		mov	r3, r7
 4315 021c 0C33     		add	r3, r3, #12
 4316 021e 0021     		mov	r1, #0
 4317 0220 5A5E     		ldrsh	r2, [r3, r1]
 4318 0222 404B     		ldr	r3, .L343+48
 4319 0224 9A42     		cmp	r2, r3
 4320 0226 EADD     		ble	.L329
 4321 0228 00E0     		b	.L328
 4322              	.L340:
 4323              		.loc 1 1060 0 is_stmt 1
 4324 022a C046     		mov	r8, r8
 4325              	.L328:
1061:../Sources/system/CrystalClock.c ****     }
1062:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 4326              		.loc 1 1062 0
 4327 022c 314B     		ldr	r3, .L343
 4328 022e 9B79     		ldrb	r3, [r3, #6]
 4329 0230 DBB2     		uxtb	r3, r3
 4330 0232 1A1C     		mov	r2, r3
 4331 0234 0223     		mov	r3, #2
 4332 0236 1340     		and	r3, r2
 4333 0238 01D1     		bne	.L325
 4334              		.loc 1 1062 0 is_stmt 0
 4335 023a 2323     		mov	r3, #35
 4336 023c 56E0     		b	.L310
 4337              	.L325:
1063:../Sources/system/CrystalClock.c ****   }
1064:../Sources/system/CrystalClock.c **** 
1065:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to clear
1066:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4338              		.loc 1 1066 0 is_stmt 1
 4339 023e 3B1C     		mov	r3, r7
 4340 0240 0C33     		add	r3, r3, #12
 4341 0242 0022     		mov	r2, #0
 4342 0244 1A80     		strh	r2, [r3]
 4343 0246 0DE0     		b	.L330
 4344              	.L333:
1067:../Sources/system/CrystalClock.c ****   {
1068:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4345              		.loc 1 1068 0
 4346 0248 2A4B     		ldr	r3, .L343
 4347 024a 9B79     		ldrb	r3, [r3, #6]
 4348 024c DBB2     		uxtb	r3, r3
 4349 024e 1A1C     		mov	r2, r3
 4350 0250 1023     		mov	r3, #16
 4351 0252 1340     		and	r3, r2
 4352 0254 0ED0     		beq	.L341
 4353              	.L331:
1066:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4354              		.loc 1 1066 0
 4355 0256 3B1C     		mov	r3, r7
 4356 0258 0C33     		add	r3, r3, #12
 4357 025a 3A1C     		mov	r2, r7
 4358 025c 0C32     		add	r2, r2, #12
 4359 025e 1288     		ldrh	r2, [r2]
 4360 0260 0132     		add	r2, r2, #1
 4361 0262 1A80     		strh	r2, [r3]
 4362              	.L330:
1066:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4363              		.loc 1 1066 0 is_stmt 0
 4364 0264 3B1C     		mov	r3, r7
 4365 0266 0C33     		add	r3, r3, #12
 4366 0268 0021     		mov	r1, #0
 4367 026a 5A5E     		ldrsh	r2, [r3, r1]
 4368 026c 2E4B     		ldr	r3, .L343+52
 4369 026e 9A42     		cmp	r2, r3
 4370 0270 EADD     		ble	.L333
 4371 0272 00E0     		b	.L332
 4372              	.L341:
 4373              		.loc 1 1068 0 is_stmt 1
 4374 0274 C046     		mov	r8, r8
 4375              	.L332:
1069:../Sources/system/CrystalClock.c ****   }
1070:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4376              		.loc 1 1070 0
 4377 0276 1F4B     		ldr	r3, .L343
 4378 0278 9B79     		ldrb	r3, [r3, #6]
 4379 027a DBB2     		uxtb	r3, r3
 4380 027c 1A1C     		mov	r2, r3
 4381 027e 1023     		mov	r3, #16
 4382 0280 1340     		and	r3, r2
 4383 0282 01D0     		beq	.L334
 4384              		.loc 1 1070 0 is_stmt 0
 4385 0284 1123     		mov	r3, #17
 4386 0286 31E0     		b	.L310
 4387              	.L334:
1071:../Sources/system/CrystalClock.c ****   
1072:../Sources/system/CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
1073:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4388              		.loc 1 1073 0 is_stmt 1
 4389 0288 3B1C     		mov	r3, r7
 4390 028a 0C33     		add	r3, r3, #12
 4391 028c 0022     		mov	r2, #0
 4392 028e 1A80     		strh	r2, [r3]
 4393 0290 0FE0     		b	.L335
 4394              	.L338:
1074:../Sources/system/CrystalClock.c ****   {
1075:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 4395              		.loc 1 1075 0
 4396 0292 184B     		ldr	r3, .L343
 4397 0294 9B79     		ldrb	r3, [r3, #6]
 4398 0296 DBB2     		uxtb	r3, r3
 4399 0298 1A1C     		mov	r2, r3
 4400 029a 0C23     		mov	r3, #12
 4401 029c 1340     		and	r3, r2
 4402 029e 9B08     		lsr	r3, r3, #2
 4403 02a0 022B     		cmp	r3, #2
 4404 02a2 0ED0     		beq	.L342
 4405              	.L336:
1073:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4406              		.loc 1 1073 0
 4407 02a4 3B1C     		mov	r3, r7
 4408 02a6 0C33     		add	r3, r3, #12
 4409 02a8 3A1C     		mov	r2, r7
 4410 02aa 0C32     		add	r2, r2, #12
 4411 02ac 1288     		ldrh	r2, [r2]
 4412 02ae 0132     		add	r2, r2, #1
 4413 02b0 1A80     		strh	r2, [r3]
 4414              	.L335:
1073:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4415              		.loc 1 1073 0 is_stmt 0
 4416 02b2 3B1C     		mov	r3, r7
 4417 02b4 0C33     		add	r3, r3, #12
 4418 02b6 0021     		mov	r1, #0
 4419 02b8 5A5E     		ldrsh	r2, [r3, r1]
 4420 02ba 1B4B     		ldr	r3, .L343+52
 4421 02bc 9A42     		cmp	r2, r3
 4422 02be E8DD     		ble	.L338
 4423 02c0 00E0     		b	.L337
 4424              	.L342:
 4425              		.loc 1 1075 0 is_stmt 1
 4426 02c2 C046     		mov	r8, r8
 4427              	.L337:
1076:../Sources/system/CrystalClock.c ****   }
1077:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 4428              		.loc 1 1077 0
 4429 02c4 0B4B     		ldr	r3, .L343
 4430 02c6 9B79     		ldrb	r3, [r3, #6]
 4431 02c8 DBB2     		uxtb	r3, r3
 4432 02ca 1A1C     		mov	r2, r3
 4433 02cc 0C23     		mov	r3, #12
 4434 02ce 1340     		and	r3, r2
 4435 02d0 9B08     		lsr	r3, r3, #2
 4436 02d2 022B     		cmp	r3, #2
 4437 02d4 01D0     		beq	.L339
 4438              		.loc 1 1077 0 is_stmt 0
 4439 02d6 1A23     		mov	r3, #26
 4440 02d8 08E0     		b	.L310
 4441              	.L339:
1078:../Sources/system/CrystalClock.c ****  
1079:../Sources/system/CrystalClock.c **** // Now in FBE  
1080:../Sources/system/CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1081:../Sources/system/CrystalClock.c **** // It is enabled here but can be removed if this is not required.
1082:../Sources/system/CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 4442              		.loc 1 1082 0 is_stmt 1
 4443 02da 064B     		ldr	r3, .L343
 4444 02dc 054A     		ldr	r2, .L343
 4445 02de 5279     		ldrb	r2, [r2, #5]
 4446 02e0 D2B2     		uxtb	r2, r2
 4447 02e2 2021     		mov	r1, #32
 4448 02e4 0A43     		orr	r2, r1
 4449 02e6 D2B2     		uxtb	r2, r2
 4450 02e8 5A71     		strb	r2, [r3, #5]
1083:../Sources/system/CrystalClock.c ****   
1084:../Sources/system/CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 4451              		.loc 1 1084 0
 4452 02ea 7B68     		ldr	r3, [r7, #4]
 4453              	.L310:
1085:../Sources/system/CrystalClock.c **** } // fbi_fbe
 4454              		.loc 1 1085 0
 4455 02ec 181C     		mov	r0, r3
 4456 02ee BD46     		mov	sp, r7
 4457 02f0 04B0     		add	sp, sp, #16
 4458              		@ sp needed for prologue
 4459 02f2 80BD     		pop	{r7, pc}
 4460              	.L344:
 4461              		.align	2
 4462              	.L343:
 4463 02f4 00400640 		.word	1074151424
 4464 02f8 80F0FA02 		.word	50000000
 4465 02fc 2F750000 		.word	29999
 4466 0300 409C0000 		.word	40000
 4467 0304 BFC62D00 		.word	2999999
 4468 0308 0048E801 		.word	32000000
 4469 030c 00127A00 		.word	8000000
 4470 0310 D0121300 		.word	1250000
 4471 0314 A0252600 		.word	2500000
 4472 0318 404B4C00 		.word	5000000
 4473 031c 80969800 		.word	10000000
 4474 0320 002D3101 		.word	20000000
 4475 0324 0F270000 		.word	9999
 4476 0328 CF070000 		.word	1999
 4477              		.cfi_endproc
 4478              	.LFE15:
 4480              		.section	.text.fbi_blpi,"ax",%progbits
 4481              		.align	2
 4482              		.global	fbi_blpi
 4483              		.code	16
 4484              		.thumb_func
 4486              	fbi_blpi:
 4487              	.LFB16:
1086:../Sources/system/CrystalClock.c **** 
1087:../Sources/system/CrystalClock.c **** 
1088:../Sources/system/CrystalClock.c **** /********************************************************************/
1089:../Sources/system/CrystalClock.c **** /* Functon name : fbi_blpi
1090:../Sources/system/CrystalClock.c ****  *
1091:../Sources/system/CrystalClock.c ****  * Mode transition: FBI to BLPI mode
1092:../Sources/system/CrystalClock.c ****  *
1093:../Sources/system/CrystalClock.c ****  * This function transitions the MCG from FBI mode to BLPI mode. This is
1094:../Sources/system/CrystalClock.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1095:../Sources/system/CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
1096:../Sources/system/CrystalClock.c ****  * in FBI mode. 
1097:../Sources/system/CrystalClock.c ****  *
1098:../Sources/system/CrystalClock.c ****  * Parameters: irc_freq - internal reference clock frequency
1099:../Sources/system/CrystalClock.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1100:../Sources/system/CrystalClock.c ****  *
1101:../Sources/system/CrystalClock.c ****  * Return value : MCGOUT frequency or error code 0x13
1102:../Sources/system/CrystalClock.c ****  */
1103:../Sources/system/CrystalClock.c **** int fbi_blpi(int irc_freq, unsigned char irc_select)
1104:../Sources/system/CrystalClock.c **** {
 4488              		.loc 1 1104 0
 4489              		.cfi_startproc
 4490 0000 80B5     		push	{r7, lr}
 4491              	.LCFI48:
 4492              		.cfi_def_cfa_offset 8
 4493              		.cfi_offset 7, -8
 4494              		.cfi_offset 14, -4
 4495 0002 84B0     		sub	sp, sp, #16
 4496              	.LCFI49:
 4497              		.cfi_def_cfa_offset 24
 4498 0004 00AF     		add	r7, sp, #0
 4499              	.LCFI50:
 4500              		.cfi_def_cfa_register 7
 4501 0006 7860     		str	r0, [r7, #4]
 4502 0008 0A1C     		mov	r2, r1
 4503 000a FB1C     		add	r3, r7, #3
 4504 000c 1A70     		strb	r2, [r3]
1105:../Sources/system/CrystalClock.c ****   unsigned char fcrdiv_val;
1106:../Sources/system/CrystalClock.c ****   
1107:../Sources/system/CrystalClock.c **** // check if in FBI mode
1108:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4505              		.loc 1 1108 0
 4506 000e 234B     		ldr	r3, .L350
 4507 0010 9B79     		ldrb	r3, [r3, #6]
 4508 0012 DBB2     		uxtb	r3, r3
 4509 0014 1A1C     		mov	r2, r3
 4510 0016 0C23     		mov	r3, #12
 4511 0018 1340     		and	r3, r2
 4512 001a 9B08     		lsr	r3, r3, #2
 4513 001c 012B     		cmp	r3, #1
 4514 001e 14D1     		bne	.L346
1109:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4515              		.loc 1 1109 0
 4516 0020 1E4B     		ldr	r3, .L350
 4517 0022 9B79     		ldrb	r3, [r3, #6]
 4518 0024 DBB2     		uxtb	r3, r3
 4519 0026 1A1C     		mov	r2, r3
 4520 0028 1023     		mov	r3, #16
 4521 002a 1340     		and	r3, r2
1108:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4522              		.loc 1 1108 0
 4523 002c 0DD0     		beq	.L346
1110:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4524              		.loc 1 1110 0
 4525 002e 1B4B     		ldr	r3, .L350
 4526 0030 9B79     		ldrb	r3, [r3, #6]
 4527 0032 DBB2     		uxtb	r3, r3
 4528 0034 1A1C     		mov	r2, r3
 4529 0036 2023     		mov	r3, #32
 4530 0038 1340     		and	r3, r2
1109:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4531              		.loc 1 1109 0
 4532 003a 06D1     		bne	.L346
1111:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4533              		.loc 1 1111 0
 4534 003c 174B     		ldr	r3, .L350
 4535 003e 5B78     		ldrb	r3, [r3, #1]
 4536 0040 DBB2     		uxtb	r3, r3
 4537 0042 1A1C     		mov	r2, r3
 4538 0044 0223     		mov	r3, #2
 4539 0046 1340     		and	r3, r2
1108:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4540              		.loc 1 1108 0
 4541 0048 01D0     		beq	.L347
 4542              	.L346:
1112:../Sources/system/CrystalClock.c ****   {  
1113:../Sources/system/CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 4543              		.loc 1 1113 0
 4544 004a 0323     		mov	r3, #3
 4545 004c 21E0     		b	.L348
 4546              	.L347:
1114:../Sources/system/CrystalClock.c ****   }
1115:../Sources/system/CrystalClock.c **** 
1116:../Sources/system/CrystalClock.c **** // Set LP bit to disable the FLL and enter BLPI
1117:../Sources/system/CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 4547              		.loc 1 1117 0
 4548 004e 134B     		ldr	r3, .L350
 4549 0050 124A     		ldr	r2, .L350
 4550 0052 5278     		ldrb	r2, [r2, #1]
 4551 0054 D2B2     		uxtb	r2, r2
 4552 0056 0221     		mov	r1, #2
 4553 0058 0A43     		orr	r2, r1
 4554 005a D2B2     		uxtb	r2, r2
 4555 005c 5A70     		strb	r2, [r3, #1]
1118:../Sources/system/CrystalClock.c ****   
1119:../Sources/system/CrystalClock.c **** // Now in BLPI
1120:../Sources/system/CrystalClock.c ****   if (irc_select)
 4556              		.loc 1 1120 0
 4557 005e FB1C     		add	r3, r7, #3
 4558 0060 1B78     		ldrb	r3, [r3]
 4559 0062 002B     		cmp	r3, #0
 4560 0064 14D0     		beq	.L349
1121:../Sources/system/CrystalClock.c ****   {
1122:../Sources/system/CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 4561              		.loc 1 1122 0
 4562 0066 0D4B     		ldr	r3, .L350
 4563 0068 1B7A     		ldrb	r3, [r3, #8]
 4564 006a DBB2     		uxtb	r3, r3
 4565 006c 1A1C     		mov	r2, r3
 4566 006e 0E23     		mov	r3, #14
 4567 0070 1340     		and	r3, r2
 4568 0072 5B08     		lsr	r3, r3, #1
 4569 0074 0122     		mov	r2, #1
 4570 0076 9A40     		lsl	r2, r2, r3
 4571 0078 3B1C     		mov	r3, r7
 4572 007a 0F33     		add	r3, r3, #15
 4573 007c 1A70     		strb	r2, [r3]
1123:../Sources/system/CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 4574              		.loc 1 1123 0
 4575 007e 3B1C     		mov	r3, r7
 4576 0080 0F33     		add	r3, r3, #15
 4577 0082 1B78     		ldrb	r3, [r3]
 4578 0084 7868     		ldr	r0, [r7, #4]
 4579 0086 191C     		mov	r1, r3
 4580 0088 FFF7FEFF 		bl	__aeabi_idiv
 4581 008c 031C     		mov	r3, r0
 4582 008e 00E0     		b	.L348
 4583              	.L349:
1124:../Sources/system/CrystalClock.c ****   }
1125:../Sources/system/CrystalClock.c ****   else
1126:../Sources/system/CrystalClock.c ****   {
1127:../Sources/system/CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 4584              		.loc 1 1127 0
 4585 0090 7B68     		ldr	r3, [r7, #4]
 4586              	.L348:
1128:../Sources/system/CrystalClock.c ****   }   
1129:../Sources/system/CrystalClock.c **** } // fbi_blpi
 4587              		.loc 1 1129 0
 4588 0092 181C     		mov	r0, r3
 4589 0094 BD46     		mov	sp, r7
 4590 0096 04B0     		add	sp, sp, #16
 4591              		@ sp needed for prologue
 4592 0098 80BD     		pop	{r7, pc}
 4593              	.L351:
 4594 009a C046     		.align	2
 4595              	.L350:
 4596 009c 00400640 		.word	1074151424
 4597              		.cfi_endproc
 4598              	.LFE16:
 4600              		.section	.text.blpi_fbi,"ax",%progbits
 4601              		.align	2
 4602              		.global	blpi_fbi
 4603              		.code	16
 4604              		.thumb_func
 4606              	blpi_fbi:
 4607              	.LFB17:
1130:../Sources/system/CrystalClock.c **** 
1131:../Sources/system/CrystalClock.c **** 
1132:../Sources/system/CrystalClock.c **** 
1133:../Sources/system/CrystalClock.c **** /********************************************************************/
1134:../Sources/system/CrystalClock.c **** /* Functon name : blpi_fbi
1135:../Sources/system/CrystalClock.c ****  *
1136:../Sources/system/CrystalClock.c ****  * Mode transition: BLPI to FBI mode
1137:../Sources/system/CrystalClock.c ****  *
1138:../Sources/system/CrystalClock.c ****  * This function transitions the MCG from BLPI mode to FBI mode. This is
1139:../Sources/system/CrystalClock.c ****  * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
1140:../Sources/system/CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
1141:../Sources/system/CrystalClock.c ****  * in BLPI mode. 
1142:../Sources/system/CrystalClock.c ****  *
1143:../Sources/system/CrystalClock.c ****  * Parameters: irc_freq - internal reference clock frequency
1144:../Sources/system/CrystalClock.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1145:../Sources/system/CrystalClock.c ****  *
1146:../Sources/system/CrystalClock.c ****  * Return value : MCGOUT frequency or error code 0x15
1147:../Sources/system/CrystalClock.c ****  */
1148:../Sources/system/CrystalClock.c **** int blpi_fbi(int irc_freq, unsigned char irc_select)
1149:../Sources/system/CrystalClock.c **** {
 4608              		.loc 1 1149 0
 4609              		.cfi_startproc
 4610 0000 80B5     		push	{r7, lr}
 4611              	.LCFI51:
 4612              		.cfi_def_cfa_offset 8
 4613              		.cfi_offset 7, -8
 4614              		.cfi_offset 14, -4
 4615 0002 84B0     		sub	sp, sp, #16
 4616              	.LCFI52:
 4617              		.cfi_def_cfa_offset 24
 4618 0004 00AF     		add	r7, sp, #0
 4619              	.LCFI53:
 4620              		.cfi_def_cfa_register 7
 4621 0006 7860     		str	r0, [r7, #4]
 4622 0008 0A1C     		mov	r2, r1
 4623 000a FB1C     		add	r3, r7, #3
 4624 000c 1A70     		strb	r2, [r3]
1150:../Sources/system/CrystalClock.c ****   unsigned char fcrdiv_val;
1151:../Sources/system/CrystalClock.c ****   // check if in BLPI mode
1152:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4625              		.loc 1 1152 0
 4626 000e 234B     		ldr	r3, .L357
 4627 0010 9B79     		ldrb	r3, [r3, #6]
 4628 0012 DBB2     		uxtb	r3, r3
 4629 0014 1A1C     		mov	r2, r3
 4630 0016 0C23     		mov	r3, #12
 4631 0018 1340     		and	r3, r2
 4632 001a 9B08     		lsr	r3, r3, #2
 4633 001c 012B     		cmp	r3, #1
 4634 001e 14D1     		bne	.L353
1153:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4635              		.loc 1 1153 0
 4636 0020 1E4B     		ldr	r3, .L357
 4637 0022 9B79     		ldrb	r3, [r3, #6]
 4638 0024 DBB2     		uxtb	r3, r3
 4639 0026 1A1C     		mov	r2, r3
 4640 0028 1023     		mov	r3, #16
 4641 002a 1340     		and	r3, r2
1152:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4642              		.loc 1 1152 0
 4643 002c 0DD0     		beq	.L353
1154:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4644              		.loc 1 1154 0
 4645 002e 1B4B     		ldr	r3, .L357
 4646 0030 9B79     		ldrb	r3, [r3, #6]
 4647 0032 DBB2     		uxtb	r3, r3
 4648 0034 1A1C     		mov	r2, r3
 4649 0036 2023     		mov	r3, #32
 4650 0038 1340     		and	r3, r2
1153:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4651              		.loc 1 1153 0
 4652 003a 06D1     		bne	.L353
1155:../Sources/system/CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
 4653              		.loc 1 1155 0
 4654 003c 174B     		ldr	r3, .L357
 4655 003e 5B78     		ldrb	r3, [r3, #1]
 4656 0040 DBB2     		uxtb	r3, r3
 4657 0042 1A1C     		mov	r2, r3
 4658 0044 0223     		mov	r3, #2
 4659 0046 1340     		and	r3, r2
1152:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4660              		.loc 1 1152 0
 4661 0048 01D1     		bne	.L354
 4662              	.L353:
1156:../Sources/system/CrystalClock.c ****   {
1157:../Sources/system/CrystalClock.c ****     return 0x5;                                                       // MCG not in correct mode re
 4663              		.loc 1 1157 0
 4664 004a 0523     		mov	r3, #5
 4665 004c 21E0     		b	.L355
 4666              	.L354:
1158:../Sources/system/CrystalClock.c ****   }
1159:../Sources/system/CrystalClock.c **** 
1160:../Sources/system/CrystalClock.c **** // Clear LP bit to enable the FLL and enter FBI mode   
1161:../Sources/system/CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 4667              		.loc 1 1161 0
 4668 004e 134B     		ldr	r3, .L357
 4669 0050 124A     		ldr	r2, .L357
 4670 0052 5278     		ldrb	r2, [r2, #1]
 4671 0054 D2B2     		uxtb	r2, r2
 4672 0056 0221     		mov	r1, #2
 4673 0058 8A43     		bic	r2, r1
 4674 005a D2B2     		uxtb	r2, r2
 4675 005c 5A70     		strb	r2, [r3, #1]
1162:../Sources/system/CrystalClock.c ****   
1163:../Sources/system/CrystalClock.c **** // Now in FBI mode
1164:../Sources/system/CrystalClock.c ****   if (irc_select)
 4676              		.loc 1 1164 0
 4677 005e FB1C     		add	r3, r7, #3
 4678 0060 1B78     		ldrb	r3, [r3]
 4679 0062 002B     		cmp	r3, #0
 4680 0064 14D0     		beq	.L356
1165:../Sources/system/CrystalClock.c ****   {
1166:../Sources/system/CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 4681              		.loc 1 1166 0
 4682 0066 0D4B     		ldr	r3, .L357
 4683 0068 1B7A     		ldrb	r3, [r3, #8]
 4684 006a DBB2     		uxtb	r3, r3
 4685 006c 1A1C     		mov	r2, r3
 4686 006e 0E23     		mov	r3, #14
 4687 0070 1340     		and	r3, r2
 4688 0072 5B08     		lsr	r3, r3, #1
 4689 0074 0122     		mov	r2, #1
 4690 0076 9A40     		lsl	r2, r2, r3
 4691 0078 3B1C     		mov	r3, r7
 4692 007a 0F33     		add	r3, r3, #15
 4693 007c 1A70     		strb	r2, [r3]
1167:../Sources/system/CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 4694              		.loc 1 1167 0
 4695 007e 3B1C     		mov	r3, r7
 4696 0080 0F33     		add	r3, r3, #15
 4697 0082 1B78     		ldrb	r3, [r3]
 4698 0084 7868     		ldr	r0, [r7, #4]
 4699 0086 191C     		mov	r1, r3
 4700 0088 FFF7FEFF 		bl	__aeabi_idiv
 4701 008c 031C     		mov	r3, r0
 4702 008e 00E0     		b	.L355
 4703              	.L356:
1168:../Sources/system/CrystalClock.c ****   }
1169:../Sources/system/CrystalClock.c ****   else
1170:../Sources/system/CrystalClock.c ****   {
1171:../Sources/system/CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 4704              		.loc 1 1171 0
 4705 0090 7B68     		ldr	r3, [r7, #4]
 4706              	.L355:
1172:../Sources/system/CrystalClock.c ****   }
1173:../Sources/system/CrystalClock.c **** } // blpi_fbi
 4707              		.loc 1 1173 0
 4708 0092 181C     		mov	r0, r3
 4709 0094 BD46     		mov	sp, r7
 4710 0096 04B0     		add	sp, sp, #16
 4711              		@ sp needed for prologue
 4712 0098 80BD     		pop	{r7, pc}
 4713              	.L358:
 4714 009a C046     		.align	2
 4715              	.L357:
 4716 009c 00400640 		.word	1074151424
 4717              		.cfi_endproc
 4718              	.LFE17:
 4720              		.section	.text.fbi_fee,"ax",%progbits
 4721              		.align	2
 4722              		.global	fbi_fee
 4723              		.code	16
 4724              		.thumb_func
 4726              	fbi_fee:
 4727              	.LFB18:
1174:../Sources/system/CrystalClock.c **** 
1175:../Sources/system/CrystalClock.c **** 
1176:../Sources/system/CrystalClock.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1177:../Sources/system/CrystalClock.c **** {
 4728              		.loc 1 1177 0
 4729              		.cfi_startproc
 4730 0000 80B5     		push	{r7, lr}
 4731              	.LCFI54:
 4732              		.cfi_def_cfa_offset 8
 4733              		.cfi_offset 7, -8
 4734              		.cfi_offset 14, -4
 4735 0002 86B0     		sub	sp, sp, #24
 4736              	.LCFI55:
 4737              		.cfi_def_cfa_offset 32
 4738 0004 00AF     		add	r7, sp, #0
 4739              	.LCFI56:
 4740              		.cfi_def_cfa_register 7
 4741 0006 7860     		str	r0, [r7, #4]
 4742 0008 FB1C     		add	r3, r7, #3
 4743 000a 1970     		strb	r1, [r3]
 4744 000c BB1C     		add	r3, r7, #2
 4745 000e 1A70     		strb	r2, [r3]
1178:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
1179:../Sources/system/CrystalClock.c ****   unsigned char frdiv_val;
1180:../Sources/system/CrystalClock.c ****   short i;
1181:../Sources/system/CrystalClock.c ****   int mcg_out, fll_ref_freq;
1182:../Sources/system/CrystalClock.c **** 
1183:../Sources/system/CrystalClock.c **** // check if in FBI mode
1184:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4746              		.loc 1 1184 0
 4747 0010 C64B     		ldr	r3, .L398
 4748 0012 9B79     		ldrb	r3, [r3, #6]
 4749 0014 DBB2     		uxtb	r3, r3
 4750 0016 1A1C     		mov	r2, r3
 4751 0018 0C23     		mov	r3, #12
 4752 001a 1340     		and	r3, r2
 4753 001c 9B08     		lsr	r3, r3, #2
 4754 001e 012B     		cmp	r3, #1
 4755 0020 14D1     		bne	.L360
1185:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4756              		.loc 1 1185 0
 4757 0022 C24B     		ldr	r3, .L398
 4758 0024 9B79     		ldrb	r3, [r3, #6]
 4759 0026 DBB2     		uxtb	r3, r3
 4760 0028 1A1C     		mov	r2, r3
 4761 002a 1023     		mov	r3, #16
 4762 002c 1340     		and	r3, r2
1184:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4763              		.loc 1 1184 0
 4764 002e 0DD0     		beq	.L360
1186:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4765              		.loc 1 1186 0
 4766 0030 BE4B     		ldr	r3, .L398
 4767 0032 9B79     		ldrb	r3, [r3, #6]
 4768 0034 DBB2     		uxtb	r3, r3
 4769 0036 1A1C     		mov	r2, r3
 4770 0038 2023     		mov	r3, #32
 4771 003a 1340     		and	r3, r2
1185:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4772              		.loc 1 1185 0
 4773 003c 06D1     		bne	.L360
1187:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4774              		.loc 1 1187 0
 4775 003e BB4B     		ldr	r3, .L398
 4776 0040 5B78     		ldrb	r3, [r3, #1]
 4777 0042 DBB2     		uxtb	r3, r3
 4778 0044 1A1C     		mov	r2, r3
 4779 0046 0223     		mov	r3, #2
 4780 0048 1340     		and	r3, r2
1184:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4781              		.loc 1 1184 0
 4782 004a 01D0     		beq	.L361
 4783              	.L360:
1188:../Sources/system/CrystalClock.c ****   {  
1189:../Sources/system/CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 4784              		.loc 1 1189 0
 4785 004c 0323     		mov	r3, #3
 4786 004e 92E1     		b	.L362
 4787              	.L361:
1190:../Sources/system/CrystalClock.c ****   }
1191:../Sources/system/CrystalClock.c ****   
1192:../Sources/system/CrystalClock.c **** // check external frequency is less than the maximum frequency
1193:../Sources/system/CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 4788              		.loc 1 1193 0
 4789 0050 7A68     		ldr	r2, [r7, #4]
 4790 0052 B74B     		ldr	r3, .L398+4
 4791 0054 9A42     		cmp	r2, r3
 4792 0056 01DD     		ble	.L363
 4793              		.loc 1 1193 0 is_stmt 0
 4794 0058 2123     		mov	r3, #33
 4795 005a 8CE1     		b	.L362
 4796              	.L363:
1194:../Sources/system/CrystalClock.c ****   
1195:../Sources/system/CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
1196:../Sources/system/CrystalClock.c ****   if (erefs_val)
 4797              		.loc 1 1196 0 is_stmt 1
 4798 005c BB1C     		add	r3, r7, #2
 4799 005e 1B78     		ldrb	r3, [r3]
 4800 0060 002B     		cmp	r3, #0
 4801 0062 11D0     		beq	.L364
1197:../Sources/system/CrystalClock.c ****   {
1198:../Sources/system/CrystalClock.c ****     if ((crystal_val < 30000) ||
 4802              		.loc 1 1198 0
 4803 0064 7A68     		ldr	r2, [r7, #4]
 4804 0066 B34B     		ldr	r3, .L398+8
 4805 0068 9A42     		cmp	r2, r3
 4806 006a 0BDD     		ble	.L365
 4807              		.loc 1 1198 0 is_stmt 0
 4808 006c 7A68     		ldr	r2, [r7, #4]
 4809 006e B24B     		ldr	r3, .L398+12
 4810 0070 9A42     		cmp	r2, r3
 4811 0072 03DD     		ble	.L366
1199:../Sources/system/CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4812              		.loc 1 1199 0 is_stmt 1
 4813 0074 7A68     		ldr	r2, [r7, #4]
 4814 0076 B14B     		ldr	r3, .L398+16
 4815 0078 9A42     		cmp	r2, r3
 4816 007a 03DD     		ble	.L365
 4817              	.L366:
 4818              		.loc 1 1199 0 is_stmt 0
 4819 007c 7A68     		ldr	r2, [r7, #4]
 4820 007e B04B     		ldr	r3, .L398+20
 4821 0080 9A42     		cmp	r2, r3
 4822 0082 01DD     		ble	.L364
 4823              	.L365:
1200:../Sources/system/CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 4824              		.loc 1 1200 0 is_stmt 1
 4825 0084 2223     		mov	r3, #34
 4826 0086 76E1     		b	.L362
 4827              	.L364:
1201:../Sources/system/CrystalClock.c ****   }
1202:../Sources/system/CrystalClock.c **** 
1203:../Sources/system/CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1204:../Sources/system/CrystalClock.c ****   if (hgo_val > 0)
 4828              		.loc 1 1204 0
 4829 0088 FB1C     		add	r3, r7, #3
 4830 008a 1B78     		ldrb	r3, [r3]
 4831 008c 002B     		cmp	r3, #0
 4832 008e 02D0     		beq	.L367
1205:../Sources/system/CrystalClock.c ****   {
1206:../Sources/system/CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 4833              		.loc 1 1206 0
 4834 0090 FB1C     		add	r3, r7, #3
 4835 0092 0122     		mov	r2, #1
 4836 0094 1A70     		strb	r2, [r3]
 4837              	.L367:
1207:../Sources/system/CrystalClock.c ****   }
1208:../Sources/system/CrystalClock.c **** 
1209:../Sources/system/CrystalClock.c **** // configure the MCG_C2 register
1210:../Sources/system/CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1211:../Sources/system/CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
1212:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C2;
 4838              		.loc 1 1212 0
 4839 0096 A54A     		ldr	r2, .L398
 4840 0098 3B1C     		mov	r3, r7
 4841 009a 1733     		add	r3, r3, #23
 4842 009c 5278     		ldrb	r2, [r2, #1]
 4843 009e 1A70     		strb	r2, [r3]
1213:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 4844              		.loc 1 1213 0
 4845 00a0 3B1C     		mov	r3, r7
 4846 00a2 1733     		add	r3, r3, #23
 4847 00a4 3A1C     		mov	r2, r7
 4848 00a6 1732     		add	r2, r2, #23
 4849 00a8 1278     		ldrb	r2, [r2]
 4850 00aa 3C21     		mov	r1, #60
 4851 00ac 8A43     		bic	r2, r1
 4852 00ae 1A70     		strb	r2, [r3]
1214:../Sources/system/CrystalClock.c ****   if (crystal_val <= 40000)
 4853              		.loc 1 1214 0
 4854 00b0 7A68     		ldr	r2, [r7, #4]
 4855 00b2 A14B     		ldr	r3, .L398+12
 4856 00b4 9A42     		cmp	r2, r3
 4857 00b6 11DC     		bgt	.L368
1215:../Sources/system/CrystalClock.c ****   {
1216:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4858              		.loc 1 1216 0
 4859 00b8 FB1C     		add	r3, r7, #3
 4860 00ba 1B78     		ldrb	r3, [r3]
 4861 00bc DB00     		lsl	r3, r3, #3
 4862 00be DAB2     		uxtb	r2, r3
 4863 00c0 BB1C     		add	r3, r7, #2
 4864 00c2 1B78     		ldrb	r3, [r3]
 4865 00c4 9B00     		lsl	r3, r3, #2
 4866 00c6 DBB2     		uxtb	r3, r3
 4867 00c8 1343     		orr	r3, r2
 4868 00ca D9B2     		uxtb	r1, r3
 4869 00cc 3B1C     		mov	r3, r7
 4870 00ce 1733     		add	r3, r3, #23
 4871 00d0 3A1C     		mov	r2, r7
 4872 00d2 1732     		add	r2, r2, #23
 4873 00d4 1278     		ldrb	r2, [r2]
 4874 00d6 0A43     		orr	r2, r1
 4875 00d8 1A70     		strb	r2, [r3]
 4876 00da 2CE0     		b	.L369
 4877              	.L368:
1217:../Sources/system/CrystalClock.c ****   }
1218:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 8000000)
 4878              		.loc 1 1218 0
 4879 00dc 7A68     		ldr	r2, [r7, #4]
 4880 00de 994B     		ldr	r3, .L398+24
 4881 00e0 9A42     		cmp	r2, r3
 4882 00e2 14DC     		bgt	.L370
1219:../Sources/system/CrystalClock.c ****   {
1220:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4883              		.loc 1 1220 0
 4884 00e4 FB1C     		add	r3, r7, #3
 4885 00e6 1B78     		ldrb	r3, [r3]
 4886 00e8 DB00     		lsl	r3, r3, #3
 4887 00ea DAB2     		uxtb	r2, r3
 4888 00ec BB1C     		add	r3, r7, #2
 4889 00ee 1B78     		ldrb	r3, [r3]
 4890 00f0 9B00     		lsl	r3, r3, #2
 4891 00f2 DBB2     		uxtb	r3, r3
 4892 00f4 1343     		orr	r3, r2
 4893 00f6 DAB2     		uxtb	r2, r3
 4894 00f8 3B1C     		mov	r3, r7
 4895 00fa 1733     		add	r3, r3, #23
 4896 00fc 1B78     		ldrb	r3, [r3]
 4897 00fe 1343     		orr	r3, r2
 4898 0100 DAB2     		uxtb	r2, r3
 4899 0102 3B1C     		mov	r3, r7
 4900 0104 1733     		add	r3, r3, #23
 4901 0106 1021     		mov	r1, #16
 4902 0108 0A43     		orr	r2, r1
 4903 010a 1A70     		strb	r2, [r3]
 4904 010c 13E0     		b	.L369
 4905              	.L370:
1221:../Sources/system/CrystalClock.c ****   }
1222:../Sources/system/CrystalClock.c ****   else
1223:../Sources/system/CrystalClock.c ****   {
1224:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4906              		.loc 1 1224 0
 4907 010e FB1C     		add	r3, r7, #3
 4908 0110 1B78     		ldrb	r3, [r3]
 4909 0112 DB00     		lsl	r3, r3, #3
 4910 0114 DAB2     		uxtb	r2, r3
 4911 0116 BB1C     		add	r3, r7, #2
 4912 0118 1B78     		ldrb	r3, [r3]
 4913 011a 9B00     		lsl	r3, r3, #2
 4914 011c DBB2     		uxtb	r3, r3
 4915 011e 1343     		orr	r3, r2
 4916 0120 DAB2     		uxtb	r2, r3
 4917 0122 3B1C     		mov	r3, r7
 4918 0124 1733     		add	r3, r3, #23
 4919 0126 1B78     		ldrb	r3, [r3]
 4920 0128 1343     		orr	r3, r2
 4921 012a DAB2     		uxtb	r2, r3
 4922 012c 3B1C     		mov	r3, r7
 4923 012e 1733     		add	r3, r3, #23
 4924 0130 2021     		mov	r1, #32
 4925 0132 0A43     		orr	r2, r1
 4926 0134 1A70     		strb	r2, [r3]
 4927              	.L369:
1225:../Sources/system/CrystalClock.c ****   }
1226:../Sources/system/CrystalClock.c ****   MCG_C2 = temp_reg;
 4928              		.loc 1 1226 0
 4929 0136 7D4B     		ldr	r3, .L398
 4930 0138 3A1C     		mov	r2, r7
 4931 013a 1732     		add	r2, r2, #23
 4932 013c 1278     		ldrb	r2, [r2]
 4933 013e 5A70     		strb	r2, [r3, #1]
1227:../Sources/system/CrystalClock.c **** 
1228:../Sources/system/CrystalClock.c **** // determine FRDIV based on reference clock frequency
1229:../Sources/system/CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1230:../Sources/system/CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4934              		.loc 1 1230 0
 4935 0140 7A68     		ldr	r2, [r7, #4]
 4936 0142 814B     		ldr	r3, .L398+28
 4937 0144 9A42     		cmp	r2, r3
 4938 0146 04DC     		bgt	.L371
 4939              		.loc 1 1230 0 is_stmt 0
 4940 0148 3B1C     		mov	r3, r7
 4941 014a 1633     		add	r3, r3, #22
 4942 014c 0022     		mov	r2, #0
 4943 014e 1A70     		strb	r2, [r3]
 4944 0150 27E0     		b	.L372
 4945              	.L371:
1231:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4946              		.loc 1 1231 0 is_stmt 1
 4947 0152 7A68     		ldr	r2, [r7, #4]
 4948 0154 7D4B     		ldr	r3, .L398+32
 4949 0156 9A42     		cmp	r2, r3
 4950 0158 04DC     		bgt	.L373
 4951              		.loc 1 1231 0 is_stmt 0
 4952 015a 3B1C     		mov	r3, r7
 4953 015c 1633     		add	r3, r3, #22
 4954 015e 0122     		mov	r2, #1
 4955 0160 1A70     		strb	r2, [r3]
 4956 0162 1EE0     		b	.L372
 4957              	.L373:
1232:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4958              		.loc 1 1232 0 is_stmt 1
 4959 0164 7A68     		ldr	r2, [r7, #4]
 4960 0166 7A4B     		ldr	r3, .L398+36
 4961 0168 9A42     		cmp	r2, r3
 4962 016a 04DC     		bgt	.L374
 4963              		.loc 1 1232 0 is_stmt 0
 4964 016c 3B1C     		mov	r3, r7
 4965 016e 1633     		add	r3, r3, #22
 4966 0170 0222     		mov	r2, #2
 4967 0172 1A70     		strb	r2, [r3]
 4968 0174 15E0     		b	.L372
 4969              	.L374:
1233:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4970              		.loc 1 1233 0 is_stmt 1
 4971 0176 7A68     		ldr	r2, [r7, #4]
 4972 0178 764B     		ldr	r3, .L398+40
 4973 017a 9A42     		cmp	r2, r3
 4974 017c 04DC     		bgt	.L375
 4975              		.loc 1 1233 0 is_stmt 0
 4976 017e 3B1C     		mov	r3, r7
 4977 0180 1633     		add	r3, r3, #22
 4978 0182 0322     		mov	r2, #3
 4979 0184 1A70     		strb	r2, [r3]
 4980 0186 0CE0     		b	.L372
 4981              	.L375:
1234:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4982              		.loc 1 1234 0 is_stmt 1
 4983 0188 7A68     		ldr	r2, [r7, #4]
 4984 018a 734B     		ldr	r3, .L398+44
 4985 018c 9A42     		cmp	r2, r3
 4986 018e 04DC     		bgt	.L376
 4987              		.loc 1 1234 0 is_stmt 0
 4988 0190 3B1C     		mov	r3, r7
 4989 0192 1633     		add	r3, r3, #22
 4990 0194 0422     		mov	r2, #4
 4991 0196 1A70     		strb	r2, [r3]
 4992 0198 03E0     		b	.L372
 4993              	.L376:
1235:../Sources/system/CrystalClock.c ****   else {frdiv_val = 5;}
 4994              		.loc 1 1235 0 is_stmt 1
 4995 019a 3B1C     		mov	r3, r7
 4996 019c 1633     		add	r3, r3, #22
 4997 019e 0522     		mov	r2, #5
 4998 01a0 1A70     		strb	r2, [r3]
 4999              	.L372:
1236:../Sources/system/CrystalClock.c **** // The FLL ref clk divide value depends on FRDIV and the RANGE value
1237:../Sources/system/CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 5000              		.loc 1 1237 0
 5001 01a2 624B     		ldr	r3, .L398
 5002 01a4 5B78     		ldrb	r3, [r3, #1]
 5003 01a6 DBB2     		uxtb	r3, r3
 5004 01a8 1A1C     		mov	r2, r3
 5005 01aa 3023     		mov	r3, #48
 5006 01ac 1340     		and	r3, r2
 5007 01ae 1B09     		lsr	r3, r3, #4
 5008 01b0 0DD0     		beq	.L377
1238:../Sources/system/CrystalClock.c ****   {
1239:../Sources/system/CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 5009              		.loc 1 1239 0
 5010 01b2 3B1C     		mov	r3, r7
 5011 01b4 1633     		add	r3, r3, #22
 5012 01b6 1B78     		ldrb	r3, [r3]
 5013 01b8 2022     		mov	r2, #32
 5014 01ba 111C     		mov	r1, r2
 5015 01bc 9940     		lsl	r1, r1, r3
 5016 01be 0B1C     		mov	r3, r1
 5017 01c0 7868     		ldr	r0, [r7, #4]
 5018 01c2 191C     		mov	r1, r3
 5019 01c4 FFF7FEFF 		bl	__aeabi_idiv
 5020 01c8 031C     		mov	r3, r0
 5021 01ca 3B61     		str	r3, [r7, #16]
 5022 01cc 0CE0     		b	.L378
 5023              	.L377:
1240:../Sources/system/CrystalClock.c ****   }
1241:../Sources/system/CrystalClock.c ****   else
1242:../Sources/system/CrystalClock.c ****   {
1243:../Sources/system/CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 5024              		.loc 1 1243 0
 5025 01ce 3B1C     		mov	r3, r7
 5026 01d0 1633     		add	r3, r3, #22
 5027 01d2 1B78     		ldrb	r3, [r3]
 5028 01d4 0122     		mov	r2, #1
 5029 01d6 111C     		mov	r1, r2
 5030 01d8 9940     		lsl	r1, r1, r3
 5031 01da 0B1C     		mov	r3, r1
 5032 01dc 7868     		ldr	r0, [r7, #4]
 5033 01de 191C     		mov	r1, r3
 5034 01e0 FFF7FEFF 		bl	__aeabi_idiv
 5035 01e4 031C     		mov	r3, r0
 5036 01e6 3B61     		str	r3, [r7, #16]
 5037              	.L378:
1244:../Sources/system/CrystalClock.c ****   }
1245:../Sources/system/CrystalClock.c ****   
1246:../Sources/system/CrystalClock.c **** // Check resulting FLL frequency 
1247:../Sources/system/CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 5038              		.loc 1 1247 0
 5039 01e8 3B69     		ldr	r3, [r7, #16]
 5040 01ea 181C     		mov	r0, r3
 5041 01ec FFF7FEFF 		bl	fll_freq
 5042 01f0 031C     		mov	r3, r0
 5043 01f2 FB60     		str	r3, [r7, #12]
1248:../Sources/system/CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 5044              		.loc 1 1248 0
 5045 01f4 FB68     		ldr	r3, [r7, #12]
 5046 01f6 3B2B     		cmp	r3, #59
 5047 01f8 01DC     		bgt	.L379
 5048              		.loc 1 1248 0 is_stmt 0
 5049 01fa FB68     		ldr	r3, [r7, #12]
 5050 01fc BBE0     		b	.L362
 5051              	.L379:
1249:../Sources/system/CrystalClock.c ****   
1250:../Sources/system/CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1251:../Sources/system/CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1252:../Sources/system/CrystalClock.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
1253:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 5052              		.loc 1 1253 0 is_stmt 1
 5053 01fe 4B4A     		ldr	r2, .L398
 5054 0200 3B1C     		mov	r3, r7
 5055 0202 1733     		add	r3, r3, #23
 5056 0204 1278     		ldrb	r2, [r2]
 5057 0206 1A70     		strb	r2, [r3]
1254:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
 5058              		.loc 1 1254 0
 5059 0208 3B1C     		mov	r3, r7
 5060 020a 1733     		add	r3, r3, #23
 5061 020c 3A1C     		mov	r2, r7
 5062 020e 1732     		add	r2, r2, #23
 5063 0210 1178     		ldrb	r1, [r2]
 5064 0212 0322     		mov	r2, #3
 5065 0214 0A40     		and	r2, r1
 5066 0216 1A70     		strb	r2, [r3]
1255:../Sources/system/CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 5067              		.loc 1 1255 0
 5068 0218 3B1C     		mov	r3, r7
 5069 021a 1633     		add	r3, r3, #22
 5070 021c 1B78     		ldrb	r3, [r3]
 5071 021e DB00     		lsl	r3, r3, #3
 5072 0220 DAB2     		uxtb	r2, r3
 5073 0222 3823     		mov	r3, #56
 5074 0224 1340     		and	r3, r2
 5075 0226 D9B2     		uxtb	r1, r3
 5076 0228 3B1C     		mov	r3, r7
 5077 022a 1733     		add	r3, r3, #23
 5078 022c 3A1C     		mov	r2, r7
 5079 022e 1732     		add	r2, r2, #23
 5080 0230 1278     		ldrb	r2, [r2]
 5081 0232 0A43     		orr	r2, r1
 5082 0234 1A70     		strb	r2, [r3]
1256:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg;
 5083              		.loc 1 1256 0
 5084 0236 3D4B     		ldr	r3, .L398
 5085 0238 3A1C     		mov	r2, r7
 5086 023a 1732     		add	r2, r2, #23
 5087 023c 1278     		ldrb	r2, [r2]
 5088 023e 1A70     		strb	r2, [r3]
1257:../Sources/system/CrystalClock.c **** 
1258:../Sources/system/CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
1259:../Sources/system/CrystalClock.c ****   if (erefs_val)
 5089              		.loc 1 1259 0
 5090 0240 BB1C     		add	r3, r7, #2
 5091 0242 1B78     		ldrb	r3, [r3]
 5092 0244 002B     		cmp	r3, #0
 5093 0246 24D0     		beq	.L380
1260:../Sources/system/CrystalClock.c ****   {
1261:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 5094              		.loc 1 1261 0
 5095 0248 3B1C     		mov	r3, r7
 5096 024a 1433     		add	r3, r3, #20
 5097 024c 0022     		mov	r2, #0
 5098 024e 1A80     		strh	r2, [r3]
 5099 0250 0DE0     		b	.L381
 5100              	.L384:
1262:../Sources/system/CrystalClock.c ****     {
1263:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 5101              		.loc 1 1263 0
 5102 0252 364B     		ldr	r3, .L398
 5103 0254 9B79     		ldrb	r3, [r3, #6]
 5104 0256 DBB2     		uxtb	r3, r3
 5105 0258 1A1C     		mov	r2, r3
 5106 025a 0223     		mov	r3, #2
 5107 025c 1340     		and	r3, r2
 5108 025e 0ED1     		bne	.L395
 5109              	.L382:
1261:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 5110              		.loc 1 1261 0
 5111 0260 3B1C     		mov	r3, r7
 5112 0262 1433     		add	r3, r3, #20
 5113 0264 3A1C     		mov	r2, r7
 5114 0266 1432     		add	r2, r2, #20
 5115 0268 1288     		ldrh	r2, [r2]
 5116 026a 0132     		add	r2, r2, #1
 5117 026c 1A80     		strh	r2, [r3]
 5118              	.L381:
1261:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 5119              		.loc 1 1261 0 is_stmt 0
 5120 026e 3B1C     		mov	r3, r7
 5121 0270 1433     		add	r3, r3, #20
 5122 0272 0021     		mov	r1, #0
 5123 0274 5A5E     		ldrsh	r2, [r3, r1]
 5124 0276 394B     		ldr	r3, .L398+48
 5125 0278 9A42     		cmp	r2, r3
 5126 027a EADD     		ble	.L384
 5127 027c 00E0     		b	.L383
 5128              	.L395:
 5129              		.loc 1 1263 0 is_stmt 1
 5130 027e C046     		mov	r8, r8
 5131              	.L383:
1264:../Sources/system/CrystalClock.c ****     }
1265:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 5132              		.loc 1 1265 0
 5133 0280 2A4B     		ldr	r3, .L398
 5134 0282 9B79     		ldrb	r3, [r3, #6]
 5135 0284 DBB2     		uxtb	r3, r3
 5136 0286 1A1C     		mov	r2, r3
 5137 0288 0223     		mov	r3, #2
 5138 028a 1340     		and	r3, r2
 5139 028c 01D1     		bne	.L380
 5140              		.loc 1 1265 0 is_stmt 0
 5141 028e 2323     		mov	r3, #35
 5142 0290 71E0     		b	.L362
 5143              	.L380:
1266:../Sources/system/CrystalClock.c ****   }
1267:../Sources/system/CrystalClock.c **** 
1268:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to clear
1269:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5144              		.loc 1 1269 0 is_stmt 1
 5145 0292 3B1C     		mov	r3, r7
 5146 0294 1433     		add	r3, r3, #20
 5147 0296 0022     		mov	r2, #0
 5148 0298 1A80     		strh	r2, [r3]
 5149 029a 0DE0     		b	.L385
 5150              	.L388:
1270:../Sources/system/CrystalClock.c ****   {
1271:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 5151              		.loc 1 1271 0
 5152 029c 234B     		ldr	r3, .L398
 5153 029e 9B79     		ldrb	r3, [r3, #6]
 5154 02a0 DBB2     		uxtb	r3, r3
 5155 02a2 1A1C     		mov	r2, r3
 5156 02a4 1023     		mov	r3, #16
 5157 02a6 1340     		and	r3, r2
 5158 02a8 0ED0     		beq	.L396
 5159              	.L386:
1269:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5160              		.loc 1 1269 0
 5161 02aa 3B1C     		mov	r3, r7
 5162 02ac 1433     		add	r3, r3, #20
 5163 02ae 3A1C     		mov	r2, r7
 5164 02b0 1432     		add	r2, r2, #20
 5165 02b2 1288     		ldrh	r2, [r2]
 5166 02b4 0132     		add	r2, r2, #1
 5167 02b6 1A80     		strh	r2, [r3]
 5168              	.L385:
1269:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5169              		.loc 1 1269 0 is_stmt 0
 5170 02b8 3B1C     		mov	r3, r7
 5171 02ba 1433     		add	r3, r3, #20
 5172 02bc 0021     		mov	r1, #0
 5173 02be 5A5E     		ldrsh	r2, [r3, r1]
 5174 02c0 274B     		ldr	r3, .L398+52
 5175 02c2 9A42     		cmp	r2, r3
 5176 02c4 EADD     		ble	.L388
 5177 02c6 00E0     		b	.L387
 5178              	.L396:
 5179              		.loc 1 1271 0 is_stmt 1
 5180 02c8 C046     		mov	r8, r8
 5181              	.L387:
1272:../Sources/system/CrystalClock.c ****   }
1273:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 5182              		.loc 1 1273 0
 5183 02ca 184B     		ldr	r3, .L398
 5184 02cc 9B79     		ldrb	r3, [r3, #6]
 5185 02ce DBB2     		uxtb	r3, r3
 5186 02d0 1A1C     		mov	r2, r3
 5187 02d2 1023     		mov	r3, #16
 5188 02d4 1340     		and	r3, r2
 5189 02d6 01D0     		beq	.L389
 5190              		.loc 1 1273 0 is_stmt 0
 5191 02d8 1123     		mov	r3, #17
 5192 02da 4CE0     		b	.L362
 5193              	.L389:
1274:../Sources/system/CrystalClock.c ****   
1275:../Sources/system/CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
1276:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5194              		.loc 1 1276 0 is_stmt 1
 5195 02dc 3B1C     		mov	r3, r7
 5196 02de 1433     		add	r3, r3, #20
 5197 02e0 0022     		mov	r2, #0
 5198 02e2 1A80     		strh	r2, [r3]
 5199 02e4 0EE0     		b	.L390
 5200              	.L393:
1277:../Sources/system/CrystalClock.c ****   {
1278:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 5201              		.loc 1 1278 0
 5202 02e6 114B     		ldr	r3, .L398
 5203 02e8 9B79     		ldrb	r3, [r3, #6]
 5204 02ea DBB2     		uxtb	r3, r3
 5205 02ec 1A1C     		mov	r2, r3
 5206 02ee 0C23     		mov	r3, #12
 5207 02f0 1340     		and	r3, r2
 5208 02f2 9B08     		lsr	r3, r3, #2
 5209 02f4 0ED0     		beq	.L397
 5210              	.L391:
1276:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5211              		.loc 1 1276 0
 5212 02f6 3B1C     		mov	r3, r7
 5213 02f8 1433     		add	r3, r3, #20
 5214 02fa 3A1C     		mov	r2, r7
 5215 02fc 1432     		add	r2, r2, #20
 5216 02fe 1288     		ldrh	r2, [r2]
 5217 0300 0132     		add	r2, r2, #1
 5218 0302 1A80     		strh	r2, [r3]
 5219              	.L390:
1276:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5220              		.loc 1 1276 0 is_stmt 0
 5221 0304 3B1C     		mov	r3, r7
 5222 0306 1433     		add	r3, r3, #20
 5223 0308 0021     		mov	r1, #0
 5224 030a 5A5E     		ldrsh	r2, [r3, r1]
 5225 030c 144B     		ldr	r3, .L398+52
 5226 030e 9A42     		cmp	r2, r3
 5227 0310 E9DD     		ble	.L393
 5228 0312 00E0     		b	.L392
 5229              	.L397:
 5230              		.loc 1 1278 0 is_stmt 1
 5231 0314 C046     		mov	r8, r8
 5232              	.L392:
1279:../Sources/system/CrystalClock.c ****   }
1280:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is reall
 5233              		.loc 1 1280 0
 5234 0316 054B     		ldr	r3, .L398
 5235 0318 9B79     		ldrb	r3, [r3, #6]
 5236 031a DBB2     		uxtb	r3, r3
 5237 031c 1A1C     		mov	r2, r3
 5238 031e 0C23     		mov	r3, #12
 5239 0320 1340     		and	r3, r2
 5240 0322 9B08     		lsr	r3, r3, #2
 5241 0324 1ED0     		beq	.L394
 5242              		.loc 1 1280 0 is_stmt 0
 5243 0326 1823     		mov	r3, #24
 5244 0328 25E0     		b	.L362
 5245              	.L399:
 5246 032a C046     		.align	2
 5247              	.L398:
 5248 032c 00400640 		.word	1074151424
 5249 0330 80F0FA02 		.word	50000000
 5250 0334 2F750000 		.word	29999
 5251 0338 409C0000 		.word	40000
 5252 033c BFC62D00 		.word	2999999
 5253 0340 0048E801 		.word	32000000
 5254 0344 00127A00 		.word	8000000
 5255 0348 D0121300 		.word	1250000
 5256 034c A0252600 		.word	2500000
 5257 0350 404B4C00 		.word	5000000
 5258 0354 80969800 		.word	10000000
 5259 0358 002D3101 		.word	20000000
 5260 035c 0F270000 		.word	9999
 5261 0360 CF070000 		.word	1999
 5262              	.L394:
1281:../Sources/system/CrystalClock.c ****  
1282:../Sources/system/CrystalClock.c **** // Now in FEE  
1283:../Sources/system/CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1284:../Sources/system/CrystalClock.c **** // It is enabled here but can be removed if this is not required.
1285:../Sources/system/CrystalClock.c **** // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLP
1286:../Sources/system/CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 5263              		.loc 1 1286 0 is_stmt 1
 5264 0364 064B     		ldr	r3, .L400
 5265 0366 064A     		ldr	r2, .L400
 5266 0368 5279     		ldrb	r2, [r2, #5]
 5267 036a D2B2     		uxtb	r2, r2
 5268 036c 2021     		mov	r1, #32
 5269 036e 0A43     		orr	r2, r1
 5270 0370 D2B2     		uxtb	r2, r2
 5271 0372 5A71     		strb	r2, [r3, #5]
1287:../Sources/system/CrystalClock.c ****   
1288:../Sources/system/CrystalClock.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 5272              		.loc 1 1288 0
 5273 0374 FB68     		ldr	r3, [r7, #12]
 5274              	.L362:
1289:../Sources/system/CrystalClock.c **** } //fbi_fee
 5275              		.loc 1 1289 0
 5276 0376 181C     		mov	r0, r3
 5277 0378 BD46     		mov	sp, r7
 5278 037a 06B0     		add	sp, sp, #24
 5279              		@ sp needed for prologue
 5280 037c 80BD     		pop	{r7, pc}
 5281              	.L401:
 5282 037e C046     		.align	2
 5283              	.L400:
 5284 0380 00400640 		.word	1074151424
 5285              		.cfi_endproc
 5286              	.LFE18:
 5288              		.section	.text.fee_fbi,"ax",%progbits
 5289              		.align	2
 5290              		.global	fee_fbi
 5291              		.code	16
 5292              		.thumb_func
 5294              	fee_fbi:
 5295              	.LFB19:
1290:../Sources/system/CrystalClock.c **** 
1291:../Sources/system/CrystalClock.c **** 
1292:../Sources/system/CrystalClock.c **** int fee_fbi(int irc_freq, unsigned char irc_select)
1293:../Sources/system/CrystalClock.c **** { 
 5296              		.loc 1 1293 0
 5297              		.cfi_startproc
 5298 0000 80B5     		push	{r7, lr}
 5299              	.LCFI57:
 5300              		.cfi_def_cfa_offset 8
 5301              		.cfi_offset 7, -8
 5302              		.cfi_offset 14, -4
 5303 0002 84B0     		sub	sp, sp, #16
 5304              	.LCFI58:
 5305              		.cfi_def_cfa_offset 24
 5306 0004 00AF     		add	r7, sp, #0
 5307              	.LCFI59:
 5308              		.cfi_def_cfa_register 7
 5309 0006 7860     		str	r0, [r7, #4]
 5310 0008 0A1C     		mov	r2, r1
 5311 000a FB1C     		add	r3, r7, #3
 5312 000c 1A70     		strb	r2, [r3]
1294:../Sources/system/CrystalClock.c ****   unsigned char fcrdiv_val;
1295:../Sources/system/CrystalClock.c ****   short i;
1296:../Sources/system/CrystalClock.c ****   
1297:../Sources/system/CrystalClock.c **** // Check MCG is in FEE mode
1298:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5313              		.loc 1 1298 0
 5314 000e 874B     		ldr	r3, .L437
 5315 0010 9B79     		ldrb	r3, [r3, #6]
 5316 0012 DBB2     		uxtb	r3, r3
 5317 0014 1A1C     		mov	r2, r3
 5318 0016 0C23     		mov	r3, #12
 5319 0018 1340     		and	r3, r2
 5320 001a 9B08     		lsr	r3, r3, #2
 5321 001c 0DD1     		bne	.L403
1299:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 5322              		.loc 1 1299 0
 5323 001e 834B     		ldr	r3, .L437
 5324 0020 9B79     		ldrb	r3, [r3, #6]
 5325 0022 DBB2     		uxtb	r3, r3
 5326 0024 1A1C     		mov	r2, r3
 5327 0026 1023     		mov	r3, #16
 5328 0028 1340     		and	r3, r2
1298:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5329              		.loc 1 1298 0
 5330 002a 06D1     		bne	.L403
1300:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 5331              		.loc 1 1300 0
 5332 002c 7F4B     		ldr	r3, .L437
 5333 002e 9B79     		ldrb	r3, [r3, #6]
 5334 0030 DBB2     		uxtb	r3, r3
 5335 0032 1A1C     		mov	r2, r3
 5336 0034 2023     		mov	r3, #32
 5337 0036 1340     		and	r3, r2
1298:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5338              		.loc 1 1298 0
 5339 0038 01D0     		beq	.L404
 5340              	.L403:
1301:../Sources/system/CrystalClock.c ****   {
1302:../Sources/system/CrystalClock.c ****     return 0x2;                                                     // return error code
 5341              		.loc 1 1302 0
 5342 003a 0223     		mov	r3, #2
 5343 003c F2E0     		b	.L405
 5344              	.L404:
1303:../Sources/system/CrystalClock.c ****   }
1304:../Sources/system/CrystalClock.c ****   
1305:../Sources/system/CrystalClock.c ****   // Check that the irc frequency matches the selected IRC 
1306:../Sources/system/CrystalClock.c ****   if (!(irc_select))
 5345              		.loc 1 1306 0
 5346 003e FB1C     		add	r3, r7, #3
 5347 0040 1B78     		ldrb	r3, [r3]
 5348 0042 002B     		cmp	r3, #0
 5349 0044 09D1     		bne	.L406
1307:../Sources/system/CrystalClock.c ****   {    
1308:../Sources/system/CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 5350              		.loc 1 1308 0
 5351 0046 7A68     		ldr	r2, [r7, #4]
 5352 0048 794B     		ldr	r3, .L437+4
 5353 004a 9A42     		cmp	r2, r3
 5354 004c 03DD     		ble	.L407
 5355              		.loc 1 1308 0 is_stmt 0
 5356 004e 7A68     		ldr	r2, [r7, #4]
 5357 0050 784B     		ldr	r3, .L437+8
 5358 0052 9A42     		cmp	r2, r3
 5359 0054 0BDD     		ble	.L408
 5360              	.L407:
 5361              		.loc 1 1308 0
 5362 0056 3123     		mov	r3, #49
 5363 0058 E4E0     		b	.L405
 5364              	.L406:
1309:../Sources/system/CrystalClock.c ****   }
1310:../Sources/system/CrystalClock.c ****   else
1311:../Sources/system/CrystalClock.c ****   {
1312:../Sources/system/CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 5365              		.loc 1 1312 0 is_stmt 1
 5366 005a 7A68     		ldr	r2, [r7, #4]
 5367 005c 764B     		ldr	r3, .L437+12
 5368 005e 9A42     		cmp	r2, r3
 5369 0060 03DD     		ble	.L409
 5370              		.loc 1 1312 0 is_stmt 0
 5371 0062 7A68     		ldr	r2, [r7, #4]
 5372 0064 754B     		ldr	r3, .L437+16
 5373 0066 9A42     		cmp	r2, r3
 5374 0068 01DD     		ble	.L408
 5375              	.L409:
 5376              		.loc 1 1312 0
 5377 006a 3223     		mov	r3, #50
 5378 006c DAE0     		b	.L405
 5379              	.L408:
1313:../Sources/system/CrystalClock.c ****   }
1314:../Sources/system/CrystalClock.c ****   
1315:../Sources/system/CrystalClock.c **** // Select the required IRC
1316:../Sources/system/CrystalClock.c ****   if (irc_select)
 5380              		.loc 1 1316 0 is_stmt 1
 5381 006e FB1C     		add	r3, r7, #3
 5382 0070 1B78     		ldrb	r3, [r3]
 5383 0072 002B     		cmp	r3, #0
 5384 0074 08D0     		beq	.L410
1317:../Sources/system/CrystalClock.c ****   {
1318:../Sources/system/CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 5385              		.loc 1 1318 0
 5386 0076 6D4B     		ldr	r3, .L437
 5387 0078 6C4A     		ldr	r2, .L437
 5388 007a 5278     		ldrb	r2, [r2, #1]
 5389 007c D2B2     		uxtb	r2, r2
 5390 007e 0121     		mov	r1, #1
 5391 0080 0A43     		orr	r2, r1
 5392 0082 D2B2     		uxtb	r2, r2
 5393 0084 5A70     		strb	r2, [r3, #1]
 5394 0086 07E0     		b	.L411
 5395              	.L410:
1319:../Sources/system/CrystalClock.c ****   }
1320:../Sources/system/CrystalClock.c ****   else
1321:../Sources/system/CrystalClock.c ****   {
1322:../Sources/system/CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 5396              		.loc 1 1322 0
 5397 0088 684B     		ldr	r3, .L437
 5398 008a 684A     		ldr	r2, .L437
 5399 008c 5278     		ldrb	r2, [r2, #1]
 5400 008e D2B2     		uxtb	r2, r2
 5401 0090 0121     		mov	r1, #1
 5402 0092 8A43     		bic	r2, r1
 5403 0094 D2B2     		uxtb	r2, r2
 5404 0096 5A70     		strb	r2, [r3, #1]
 5405              	.L411:
1323:../Sources/system/CrystalClock.c ****   }
1324:../Sources/system/CrystalClock.c ****   
1325:../Sources/system/CrystalClock.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
1326:../Sources/system/CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 5406              		.loc 1 1326 0
 5407 0098 644B     		ldr	r3, .L437
 5408 009a 644A     		ldr	r2, .L437
 5409 009c 5279     		ldrb	r2, [r2, #5]
 5410 009e D2B2     		uxtb	r2, r2
 5411 00a0 2021     		mov	r1, #32
 5412 00a2 8A43     		bic	r2, r1
 5413 00a4 D2B2     		uxtb	r2, r2
 5414 00a6 5A71     		strb	r2, [r3, #5]
1327:../Sources/system/CrystalClock.c ****   
1328:../Sources/system/CrystalClock.c **** // Select the IRC as the CLKS mux selection
1329:../Sources/system/CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 5415              		.loc 1 1329 0
 5416 00a8 604B     		ldr	r3, .L437
 5417 00aa 604A     		ldr	r2, .L437
 5418 00ac 1278     		ldrb	r2, [r2]
 5419 00ae D2B2     		uxtb	r2, r2
 5420 00b0 4421     		mov	r1, #68
 5421 00b2 0A43     		orr	r2, r1
 5422 00b4 D2B2     		uxtb	r2, r2
 5423 00b6 1A70     		strb	r2, [r3]
1330:../Sources/system/CrystalClock.c ****  
1331:../Sources/system/CrystalClock.c **** // wait until internal reference switches to requested irc.
1332:../Sources/system/CrystalClock.c ****   if (!(irc_select))
 5424              		.loc 1 1332 0
 5425 00b8 FB1C     		add	r3, r7, #3
 5426 00ba 1B78     		ldrb	r3, [r3]
 5427 00bc 002B     		cmp	r3, #0
 5428 00be 24D1     		bne	.L412
1333:../Sources/system/CrystalClock.c ****   {
1334:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 5429              		.loc 1 1334 0
 5430 00c0 3B1C     		mov	r3, r7
 5431 00c2 0E33     		add	r3, r3, #14
 5432 00c4 0022     		mov	r2, #0
 5433 00c6 1A80     		strh	r2, [r3]
 5434 00c8 0DE0     		b	.L413
 5435              	.L416:
1335:../Sources/system/CrystalClock.c ****     {
1336:../Sources/system/CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 5436              		.loc 1 1336 0
 5437 00ca 584B     		ldr	r3, .L437
 5438 00cc 9B79     		ldrb	r3, [r3, #6]
 5439 00ce DBB2     		uxtb	r3, r3
 5440 00d0 1A1C     		mov	r2, r3
 5441 00d2 0123     		mov	r3, #1
 5442 00d4 1340     		and	r3, r2
 5443 00d6 0ED0     		beq	.L433
 5444              	.L414:
1334:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 5445              		.loc 1 1334 0
 5446 00d8 3B1C     		mov	r3, r7
 5447 00da 0E33     		add	r3, r3, #14
 5448 00dc 3A1C     		mov	r2, r7
 5449 00de 0E32     		add	r2, r2, #14
 5450 00e0 1288     		ldrh	r2, [r2]
 5451 00e2 0132     		add	r2, r2, #1
 5452 00e4 1A80     		strh	r2, [r3]
 5453              	.L413:
1334:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 5454              		.loc 1 1334 0 is_stmt 0
 5455 00e6 3B1C     		mov	r3, r7
 5456 00e8 0E33     		add	r3, r3, #14
 5457 00ea 0021     		mov	r1, #0
 5458 00ec 5A5E     		ldrsh	r2, [r3, r1]
 5459 00ee 544B     		ldr	r3, .L437+20
 5460 00f0 9A42     		cmp	r2, r3
 5461 00f2 EADD     		ble	.L416
 5462 00f4 00E0     		b	.L415
 5463              	.L433:
 5464              		.loc 1 1336 0 is_stmt 1
 5465 00f6 C046     		mov	r8, r8
 5466              	.L415:
1337:../Sources/system/CrystalClock.c ****     }
1338:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 5467              		.loc 1 1338 0
 5468 00f8 4C4B     		ldr	r3, .L437
 5469 00fa 9B79     		ldrb	r3, [r3, #6]
 5470 00fc DBB2     		uxtb	r3, r3
 5471 00fe 1A1C     		mov	r2, r3
 5472 0100 0123     		mov	r3, #1
 5473 0102 1340     		and	r3, r2
 5474 0104 26D0     		beq	.L417
 5475              		.loc 1 1338 0 is_stmt 0
 5476 0106 1323     		mov	r3, #19
 5477 0108 8CE0     		b	.L405
 5478              	.L412:
1339:../Sources/system/CrystalClock.c ****   }
1340:../Sources/system/CrystalClock.c ****   else
1341:../Sources/system/CrystalClock.c ****   {
1342:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 5479              		.loc 1 1342 0 is_stmt 1
 5480 010a 3B1C     		mov	r3, r7
 5481 010c 0E33     		add	r3, r3, #14
 5482 010e 0022     		mov	r2, #0
 5483 0110 1A80     		strh	r2, [r3]
 5484 0112 0DE0     		b	.L418
 5485              	.L421:
1343:../Sources/system/CrystalClock.c ****     {
1344:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 5486              		.loc 1 1344 0
 5487 0114 454B     		ldr	r3, .L437
 5488 0116 9B79     		ldrb	r3, [r3, #6]
 5489 0118 DBB2     		uxtb	r3, r3
 5490 011a 1A1C     		mov	r2, r3
 5491 011c 0123     		mov	r3, #1
 5492 011e 1340     		and	r3, r2
 5493 0120 0ED1     		bne	.L434
 5494              	.L419:
1342:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 5495              		.loc 1 1342 0
 5496 0122 3B1C     		mov	r3, r7
 5497 0124 0E33     		add	r3, r3, #14
 5498 0126 3A1C     		mov	r2, r7
 5499 0128 0E32     		add	r2, r2, #14
 5500 012a 1288     		ldrh	r2, [r2]
 5501 012c 0132     		add	r2, r2, #1
 5502 012e 1A80     		strh	r2, [r3]
 5503              	.L418:
1342:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 5504              		.loc 1 1342 0 is_stmt 0
 5505 0130 3B1C     		mov	r3, r7
 5506 0132 0E33     		add	r3, r3, #14
 5507 0134 0021     		mov	r1, #0
 5508 0136 5A5E     		ldrsh	r2, [r3, r1]
 5509 0138 414B     		ldr	r3, .L437+20
 5510 013a 9A42     		cmp	r2, r3
 5511 013c EADD     		ble	.L421
 5512 013e 00E0     		b	.L420
 5513              	.L434:
 5514              		.loc 1 1344 0 is_stmt 1
 5515 0140 C046     		mov	r8, r8
 5516              	.L420:
1345:../Sources/system/CrystalClock.c ****     }
1346:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 5517              		.loc 1 1346 0
 5518 0142 3A4B     		ldr	r3, .L437
 5519 0144 9B79     		ldrb	r3, [r3, #6]
 5520 0146 DBB2     		uxtb	r3, r3
 5521 0148 1A1C     		mov	r2, r3
 5522 014a 0123     		mov	r3, #1
 5523 014c 1340     		and	r3, r2
 5524 014e 01D1     		bne	.L417
 5525              		.loc 1 1346 0 is_stmt 0
 5526 0150 1423     		mov	r3, #20
 5527 0152 67E0     		b	.L405
 5528              	.L417:
1347:../Sources/system/CrystalClock.c ****   }
1348:../Sources/system/CrystalClock.c ****   
1349:../Sources/system/CrystalClock.c **** // Wait for clock status bits to update
1350:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5529              		.loc 1 1350 0 is_stmt 1
 5530 0154 3B1C     		mov	r3, r7
 5531 0156 0E33     		add	r3, r3, #14
 5532 0158 0022     		mov	r2, #0
 5533 015a 1A80     		strh	r2, [r3]
 5534 015c 0FE0     		b	.L422
 5535              	.L425:
1351:../Sources/system/CrystalClock.c ****   {
1352:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 5536              		.loc 1 1352 0
 5537 015e 334B     		ldr	r3, .L437
 5538 0160 9B79     		ldrb	r3, [r3, #6]
 5539 0162 DBB2     		uxtb	r3, r3
 5540 0164 1A1C     		mov	r2, r3
 5541 0166 0C23     		mov	r3, #12
 5542 0168 1340     		and	r3, r2
 5543 016a 9B08     		lsr	r3, r3, #2
 5544 016c 012B     		cmp	r3, #1
 5545 016e 0ED0     		beq	.L435
 5546              	.L423:
1350:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5547              		.loc 1 1350 0
 5548 0170 3B1C     		mov	r3, r7
 5549 0172 0E33     		add	r3, r3, #14
 5550 0174 3A1C     		mov	r2, r7
 5551 0176 0E32     		add	r2, r2, #14
 5552 0178 1288     		ldrh	r2, [r2]
 5553 017a 0132     		add	r2, r2, #1
 5554 017c 1A80     		strh	r2, [r3]
 5555              	.L422:
1350:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5556              		.loc 1 1350 0 is_stmt 0
 5557 017e 3B1C     		mov	r3, r7
 5558 0180 0E33     		add	r3, r3, #14
 5559 0182 0021     		mov	r1, #0
 5560 0184 5A5E     		ldrsh	r2, [r3, r1]
 5561 0186 2E4B     		ldr	r3, .L437+20
 5562 0188 9A42     		cmp	r2, r3
 5563 018a E8DD     		ble	.L425
 5564 018c 00E0     		b	.L424
 5565              	.L435:
 5566              		.loc 1 1352 0 is_stmt 1
 5567 018e C046     		mov	r8, r8
 5568              	.L424:
1353:../Sources/system/CrystalClock.c ****   }
1354:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 5569              		.loc 1 1354 0
 5570 0190 264B     		ldr	r3, .L437
 5571 0192 9B79     		ldrb	r3, [r3, #6]
 5572 0194 DBB2     		uxtb	r3, r3
 5573 0196 1A1C     		mov	r2, r3
 5574 0198 0C23     		mov	r3, #12
 5575 019a 1340     		and	r3, r2
 5576 019c 9B08     		lsr	r3, r3, #2
 5577 019e 012B     		cmp	r3, #1
 5578 01a0 01D0     		beq	.L426
 5579              		.loc 1 1354 0 is_stmt 0
 5580 01a2 1923     		mov	r3, #25
 5581 01a4 3EE0     		b	.L405
 5582              	.L426:
1355:../Sources/system/CrystalClock.c ****   
1356:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to set
1357:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5583              		.loc 1 1357 0 is_stmt 1
 5584 01a6 3B1C     		mov	r3, r7
 5585 01a8 0E33     		add	r3, r3, #14
 5586 01aa 0022     		mov	r2, #0
 5587 01ac 1A80     		strh	r2, [r3]
 5588 01ae 0DE0     		b	.L427
 5589              	.L430:
1358:../Sources/system/CrystalClock.c ****   {
1359:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 5590              		.loc 1 1359 0
 5591 01b0 1E4B     		ldr	r3, .L437
 5592 01b2 9B79     		ldrb	r3, [r3, #6]
 5593 01b4 DBB2     		uxtb	r3, r3
 5594 01b6 1A1C     		mov	r2, r3
 5595 01b8 1023     		mov	r3, #16
 5596 01ba 1340     		and	r3, r2
 5597 01bc 0ED1     		bne	.L436
 5598              	.L428:
1357:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5599              		.loc 1 1357 0
 5600 01be 3B1C     		mov	r3, r7
 5601 01c0 0E33     		add	r3, r3, #14
 5602 01c2 3A1C     		mov	r2, r7
 5603 01c4 0E32     		add	r2, r2, #14
 5604 01c6 1288     		ldrh	r2, [r2]
 5605 01c8 0132     		add	r2, r2, #1
 5606 01ca 1A80     		strh	r2, [r3]
 5607              	.L427:
1357:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5608              		.loc 1 1357 0 is_stmt 0
 5609 01cc 3B1C     		mov	r3, r7
 5610 01ce 0E33     		add	r3, r3, #14
 5611 01d0 0021     		mov	r1, #0
 5612 01d2 5A5E     		ldrsh	r2, [r3, r1]
 5613 01d4 1A4B     		ldr	r3, .L437+20
 5614 01d6 9A42     		cmp	r2, r3
 5615 01d8 EADD     		ble	.L430
 5616 01da 00E0     		b	.L429
 5617              	.L436:
 5618              		.loc 1 1359 0 is_stmt 1
 5619 01dc C046     		mov	r8, r8
 5620              	.L429:
1360:../Sources/system/CrystalClock.c ****   }
1361:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 5621              		.loc 1 1361 0
 5622 01de 134B     		ldr	r3, .L437
 5623 01e0 9B79     		ldrb	r3, [r3, #6]
 5624 01e2 DBB2     		uxtb	r3, r3
 5625 01e4 1A1C     		mov	r2, r3
 5626 01e6 1023     		mov	r3, #16
 5627 01e8 1340     		and	r3, r2
 5628 01ea 01D1     		bne	.L431
 5629              		.loc 1 1361 0 is_stmt 0
 5630 01ec 1223     		mov	r3, #18
 5631 01ee 19E0     		b	.L405
 5632              	.L431:
1362:../Sources/system/CrystalClock.c ****   
1363:../Sources/system/CrystalClock.c **** // Now in FBI mode
1364:../Sources/system/CrystalClock.c ****   if (irc_select)
 5633              		.loc 1 1364 0 is_stmt 1
 5634 01f0 FB1C     		add	r3, r7, #3
 5635 01f2 1B78     		ldrb	r3, [r3]
 5636 01f4 002B     		cmp	r3, #0
 5637 01f6 14D0     		beq	.L432
1365:../Sources/system/CrystalClock.c ****   {
1366:../Sources/system/CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 5638              		.loc 1 1366 0
 5639 01f8 0C4B     		ldr	r3, .L437
 5640 01fa 1B7A     		ldrb	r3, [r3, #8]
 5641 01fc DBB2     		uxtb	r3, r3
 5642 01fe 1A1C     		mov	r2, r3
 5643 0200 0E23     		mov	r3, #14
 5644 0202 1340     		and	r3, r2
 5645 0204 5B08     		lsr	r3, r3, #1
 5646 0206 0122     		mov	r2, #1
 5647 0208 9A40     		lsl	r2, r2, r3
 5648 020a 3B1C     		mov	r3, r7
 5649 020c 0D33     		add	r3, r3, #13
 5650 020e 1A70     		strb	r2, [r3]
1367:../Sources/system/CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 5651              		.loc 1 1367 0
 5652 0210 3B1C     		mov	r3, r7
 5653 0212 0D33     		add	r3, r3, #13
 5654 0214 1B78     		ldrb	r3, [r3]
 5655 0216 7868     		ldr	r0, [r7, #4]
 5656 0218 191C     		mov	r1, r3
 5657 021a FFF7FEFF 		bl	__aeabi_idiv
 5658 021e 031C     		mov	r3, r0
 5659 0220 00E0     		b	.L405
 5660              	.L432:
1368:../Sources/system/CrystalClock.c ****   }
1369:../Sources/system/CrystalClock.c ****   else
1370:../Sources/system/CrystalClock.c ****   {
1371:../Sources/system/CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 5661              		.loc 1 1371 0
 5662 0222 7B68     		ldr	r3, [r7, #4]
 5663              	.L405:
1372:../Sources/system/CrystalClock.c ****   }
1373:../Sources/system/CrystalClock.c **** } // fee_fbi 
 5664              		.loc 1 1373 0
 5665 0224 181C     		mov	r0, r3
 5666 0226 BD46     		mov	sp, r7
 5667 0228 04B0     		add	sp, sp, #16
 5668              		@ sp needed for prologue
 5669 022a 80BD     		pop	{r7, pc}
 5670              	.L438:
 5671              		.align	2
 5672              	.L437:
 5673 022c 00400640 		.word	1074151424
 5674 0230 117A0000 		.word	31249
 5675 0234 97980000 		.word	39063
 5676 0238 BFC62D00 		.word	2999999
 5677 023c 404B4C00 		.word	5000000
 5678 0240 CF070000 		.word	1999
 5679              		.cfi_endproc
 5680              	.LFE19:
 5682              		.section	.text.fbi_fei,"ax",%progbits
 5683              		.align	2
 5684              		.global	fbi_fei
 5685              		.code	16
 5686              		.thumb_func
 5688              	fbi_fei:
 5689              	.LFB20:
1374:../Sources/system/CrystalClock.c **** 
1375:../Sources/system/CrystalClock.c **** 
1376:../Sources/system/CrystalClock.c **** int fbi_fei(int slow_irc_freq)
1377:../Sources/system/CrystalClock.c **** {
 5690              		.loc 1 1377 0
 5691              		.cfi_startproc
 5692 0000 80B5     		push	{r7, lr}
 5693              	.LCFI60:
 5694              		.cfi_def_cfa_offset 8
 5695              		.cfi_offset 7, -8
 5696              		.cfi_offset 14, -4
 5697 0002 86B0     		sub	sp, sp, #24
 5698              	.LCFI61:
 5699              		.cfi_def_cfa_offset 32
 5700 0004 00AF     		add	r7, sp, #0
 5701              	.LCFI62:
 5702              		.cfi_def_cfa_register 7
 5703 0006 7860     		str	r0, [r7, #4]
1378:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
1379:../Sources/system/CrystalClock.c ****   short i;
1380:../Sources/system/CrystalClock.c ****   int mcg_out;
1381:../Sources/system/CrystalClock.c **** 
1382:../Sources/system/CrystalClock.c **** // check if in FBI mode
1383:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5704              		.loc 1 1383 0
 5705 0008 524B     		ldr	r3, .L458
 5706 000a 9B79     		ldrb	r3, [r3, #6]
 5707 000c DBB2     		uxtb	r3, r3
 5708 000e 1A1C     		mov	r2, r3
 5709 0010 0C23     		mov	r3, #12
 5710 0012 1340     		and	r3, r2
 5711 0014 9B08     		lsr	r3, r3, #2
 5712 0016 012B     		cmp	r3, #1
 5713 0018 14D1     		bne	.L440
1384:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5714              		.loc 1 1384 0
 5715 001a 4E4B     		ldr	r3, .L458
 5716 001c 9B79     		ldrb	r3, [r3, #6]
 5717 001e DBB2     		uxtb	r3, r3
 5718 0020 1A1C     		mov	r2, r3
 5719 0022 1023     		mov	r3, #16
 5720 0024 1340     		and	r3, r2
1383:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5721              		.loc 1 1383 0
 5722 0026 0DD0     		beq	.L440
1385:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 5723              		.loc 1 1385 0
 5724 0028 4A4B     		ldr	r3, .L458
 5725 002a 9B79     		ldrb	r3, [r3, #6]
 5726 002c DBB2     		uxtb	r3, r3
 5727 002e 1A1C     		mov	r2, r3
 5728 0030 2023     		mov	r3, #32
 5729 0032 1340     		and	r3, r2
1384:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5730              		.loc 1 1384 0
 5731 0034 06D1     		bne	.L440
1386:../Sources/system/CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 5732              		.loc 1 1386 0
 5733 0036 474B     		ldr	r3, .L458
 5734 0038 5B78     		ldrb	r3, [r3, #1]
 5735 003a DBB2     		uxtb	r3, r3
 5736 003c 1A1C     		mov	r2, r3
 5737 003e 0223     		mov	r3, #2
 5738 0040 1340     		and	r3, r2
1383:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5739              		.loc 1 1383 0
 5740 0042 01D0     		beq	.L441
 5741              	.L440:
1387:../Sources/system/CrystalClock.c ****   {  
1388:../Sources/system/CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 5742              		.loc 1 1388 0
 5743 0044 0323     		mov	r3, #3
 5744 0046 81E0     		b	.L442
 5745              	.L441:
1389:../Sources/system/CrystalClock.c ****   }
1390:../Sources/system/CrystalClock.c **** 
1391:../Sources/system/CrystalClock.c **** // Check IRC frequency is within spec.
1392:../Sources/system/CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 5746              		.loc 1 1392 0
 5747 0048 7A68     		ldr	r2, [r7, #4]
 5748 004a 434B     		ldr	r3, .L458+4
 5749 004c 9A42     		cmp	r2, r3
 5750 004e 03DD     		ble	.L443
 5751              		.loc 1 1392 0 is_stmt 0
 5752 0050 7A68     		ldr	r2, [r7, #4]
 5753 0052 424B     		ldr	r3, .L458+8
 5754 0054 9A42     		cmp	r2, r3
 5755 0056 01DD     		ble	.L444
 5756              	.L443:
1393:../Sources/system/CrystalClock.c ****   {
1394:../Sources/system/CrystalClock.c ****     return 0x31;
 5757              		.loc 1 1394 0 is_stmt 1
 5758 0058 3123     		mov	r3, #49
 5759 005a 77E0     		b	.L442
 5760              	.L444:
1395:../Sources/system/CrystalClock.c ****   }
1396:../Sources/system/CrystalClock.c **** 
1397:../Sources/system/CrystalClock.c **** // Check resulting FLL frequency 
1398:../Sources/system/CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
 5761              		.loc 1 1398 0
 5762 005c 7B68     		ldr	r3, [r7, #4]
 5763 005e 181C     		mov	r0, r3
 5764 0060 FFF7FEFF 		bl	fll_freq
 5765 0064 031C     		mov	r3, r0
 5766 0066 3B61     		str	r3, [r7, #16]
1399:../Sources/system/CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 5767              		.loc 1 1399 0
 5768 0068 3B69     		ldr	r3, [r7, #16]
 5769 006a 3B2B     		cmp	r3, #59
 5770 006c 01DC     		bgt	.L445
 5771              		.loc 1 1399 0 is_stmt 0
 5772 006e 3B69     		ldr	r3, [r7, #16]
 5773 0070 6CE0     		b	.L442
 5774              	.L445:
1400:../Sources/system/CrystalClock.c ****   
1401:../Sources/system/CrystalClock.c **** // Change the CLKS mux to select the FLL output as MCGOUT  
1402:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 5775              		.loc 1 1402 0 is_stmt 1
 5776 0072 384A     		ldr	r2, .L458
 5777 0074 3B1C     		mov	r3, r7
 5778 0076 0F33     		add	r3, r3, #15
 5779 0078 1278     		ldrb	r2, [r2]
 5780 007a 1A70     		strb	r2, [r3]
1403:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
 5781              		.loc 1 1403 0
 5782 007c 3B1C     		mov	r3, r7
 5783 007e 0F33     		add	r3, r3, #15
 5784 0080 3A1C     		mov	r2, r7
 5785 0082 0F32     		add	r2, r2, #15
 5786 0084 1178     		ldrb	r1, [r2]
 5787 0086 3F22     		mov	r2, #63
 5788 0088 0A40     		and	r2, r1
 5789 008a 1A70     		strb	r2, [r3]
1404:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
 5790              		.loc 1 1404 0
 5791 008c 3B1C     		mov	r3, r7
 5792 008e 0F33     		add	r3, r3, #15
 5793 0090 3A1C     		mov	r2, r7
 5794 0092 0F32     		add	r2, r2, #15
 5795 0094 1278     		ldrb	r2, [r2]
 5796 0096 1A70     		strb	r2, [r3]
1405:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
 5797              		.loc 1 1405 0
 5798 0098 3B1C     		mov	r3, r7
 5799 009a 0F33     		add	r3, r3, #15
 5800 009c 3A1C     		mov	r2, r7
 5801 009e 0F32     		add	r2, r2, #15
 5802 00a0 1278     		ldrb	r2, [r2]
 5803 00a2 0421     		mov	r1, #4
 5804 00a4 0A43     		orr	r2, r1
 5805 00a6 1A70     		strb	r2, [r3]
1406:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 5806              		.loc 1 1406 0
 5807 00a8 2A4B     		ldr	r3, .L458
 5808 00aa 3A1C     		mov	r2, r7
 5809 00ac 0F32     		add	r2, r2, #15
 5810 00ae 1278     		ldrb	r2, [r2]
 5811 00b0 1A70     		strb	r2, [r3]
1407:../Sources/system/CrystalClock.c ****   
1408:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to clear
1409:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5812              		.loc 1 1409 0
 5813 00b2 3B1C     		mov	r3, r7
 5814 00b4 1633     		add	r3, r3, #22
 5815 00b6 0022     		mov	r2, #0
 5816 00b8 1A80     		strh	r2, [r3]
 5817 00ba 0DE0     		b	.L446
 5818              	.L449:
1410:../Sources/system/CrystalClock.c ****   {
1411:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 5819              		.loc 1 1411 0
 5820 00bc 254B     		ldr	r3, .L458
 5821 00be 9B79     		ldrb	r3, [r3, #6]
 5822 00c0 DBB2     		uxtb	r3, r3
 5823 00c2 1A1C     		mov	r2, r3
 5824 00c4 1023     		mov	r3, #16
 5825 00c6 1340     		and	r3, r2
 5826 00c8 0ED1     		bne	.L456
 5827              	.L447:
1409:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5828              		.loc 1 1409 0
 5829 00ca 3B1C     		mov	r3, r7
 5830 00cc 1633     		add	r3, r3, #22
 5831 00ce 3A1C     		mov	r2, r7
 5832 00d0 1632     		add	r2, r2, #22
 5833 00d2 1288     		ldrh	r2, [r2]
 5834 00d4 0132     		add	r2, r2, #1
 5835 00d6 1A80     		strh	r2, [r3]
 5836              	.L446:
1409:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5837              		.loc 1 1409 0 is_stmt 0
 5838 00d8 3B1C     		mov	r3, r7
 5839 00da 1633     		add	r3, r3, #22
 5840 00dc 0021     		mov	r1, #0
 5841 00de 5A5E     		ldrsh	r2, [r3, r1]
 5842 00e0 1F4B     		ldr	r3, .L458+12
 5843 00e2 9A42     		cmp	r2, r3
 5844 00e4 EADD     		ble	.L449
 5845 00e6 00E0     		b	.L448
 5846              	.L456:
 5847              		.loc 1 1411 0 is_stmt 1
 5848 00e8 C046     		mov	r8, r8
 5849              	.L448:
1412:../Sources/system/CrystalClock.c ****   }
1413:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 5850              		.loc 1 1413 0
 5851 00ea 1A4B     		ldr	r3, .L458
 5852 00ec 9B79     		ldrb	r3, [r3, #6]
 5853 00ee DBB2     		uxtb	r3, r3
 5854 00f0 1A1C     		mov	r2, r3
 5855 00f2 1023     		mov	r3, #16
 5856 00f4 1340     		and	r3, r2
 5857 00f6 01D1     		bne	.L450
 5858              		.loc 1 1413 0 is_stmt 0
 5859 00f8 1223     		mov	r3, #18
 5860 00fa 27E0     		b	.L442
 5861              	.L450:
1414:../Sources/system/CrystalClock.c ****   
1415:../Sources/system/CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
1416:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5862              		.loc 1 1416 0 is_stmt 1
 5863 00fc 3B1C     		mov	r3, r7
 5864 00fe 1633     		add	r3, r3, #22
 5865 0100 0022     		mov	r2, #0
 5866 0102 1A80     		strh	r2, [r3]
 5867 0104 0EE0     		b	.L451
 5868              	.L454:
1417:../Sources/system/CrystalClock.c ****   {
1418:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 5869              		.loc 1 1418 0
 5870 0106 134B     		ldr	r3, .L458
 5871 0108 9B79     		ldrb	r3, [r3, #6]
 5872 010a DBB2     		uxtb	r3, r3
 5873 010c 1A1C     		mov	r2, r3
 5874 010e 0C23     		mov	r3, #12
 5875 0110 1340     		and	r3, r2
 5876 0112 9B08     		lsr	r3, r3, #2
 5877 0114 0ED0     		beq	.L457
 5878              	.L452:
1416:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5879              		.loc 1 1416 0
 5880 0116 3B1C     		mov	r3, r7
 5881 0118 1633     		add	r3, r3, #22
 5882 011a 3A1C     		mov	r2, r7
 5883 011c 1632     		add	r2, r2, #22
 5884 011e 1288     		ldrh	r2, [r2]
 5885 0120 0132     		add	r2, r2, #1
 5886 0122 1A80     		strh	r2, [r3]
 5887              	.L451:
1416:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 5888              		.loc 1 1416 0 is_stmt 0
 5889 0124 3B1C     		mov	r3, r7
 5890 0126 1633     		add	r3, r3, #22
 5891 0128 0021     		mov	r1, #0
 5892 012a 5A5E     		ldrsh	r2, [r3, r1]
 5893 012c 0C4B     		ldr	r3, .L458+12
 5894 012e 9A42     		cmp	r2, r3
 5895 0130 E9DD     		ble	.L454
 5896 0132 00E0     		b	.L453
 5897              	.L457:
 5898              		.loc 1 1418 0 is_stmt 1
 5899 0134 C046     		mov	r8, r8
 5900              	.L453:
1419:../Sources/system/CrystalClock.c ****   }
1420:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 5901              		.loc 1 1420 0
 5902 0136 074B     		ldr	r3, .L458
 5903 0138 9B79     		ldrb	r3, [r3, #6]
 5904 013a DBB2     		uxtb	r3, r3
 5905 013c 1A1C     		mov	r2, r3
 5906 013e 0C23     		mov	r3, #12
 5907 0140 1340     		and	r3, r2
 5908 0142 9B08     		lsr	r3, r3, #2
 5909 0144 01D0     		beq	.L455
 5910              		.loc 1 1420 0 is_stmt 0
 5911 0146 1823     		mov	r3, #24
 5912 0148 00E0     		b	.L442
 5913              	.L455:
1421:../Sources/system/CrystalClock.c **** 
1422:../Sources/system/CrystalClock.c **** // Now in FEI mode
1423:../Sources/system/CrystalClock.c ****   return mcg_out;  
 5914              		.loc 1 1423 0 is_stmt 1
 5915 014a 3B69     		ldr	r3, [r7, #16]
 5916              	.L442:
1424:../Sources/system/CrystalClock.c **** } // fbi_fei
 5917              		.loc 1 1424 0
 5918 014c 181C     		mov	r0, r3
 5919 014e BD46     		mov	sp, r7
 5920 0150 06B0     		add	sp, sp, #24
 5921              		@ sp needed for prologue
 5922 0152 80BD     		pop	{r7, pc}
 5923              	.L459:
 5924              		.align	2
 5925              	.L458:
 5926 0154 00400640 		.word	1074151424
 5927 0158 117A0000 		.word	31249
 5928 015c 97980000 		.word	39063
 5929 0160 CF070000 		.word	1999
 5930              		.cfi_endproc
 5931              	.LFE20:
 5933              		.section	.text.fei_fbi,"ax",%progbits
 5934              		.align	2
 5935              		.global	fei_fbi
 5936              		.code	16
 5937              		.thumb_func
 5939              	fei_fbi:
 5940              	.LFB21:
1425:../Sources/system/CrystalClock.c **** 
1426:../Sources/system/CrystalClock.c **** 
1427:../Sources/system/CrystalClock.c **** int fei_fbi(int irc_freq, unsigned char irc_select)
1428:../Sources/system/CrystalClock.c **** {
 5941              		.loc 1 1428 0
 5942              		.cfi_startproc
 5943 0000 80B5     		push	{r7, lr}
 5944              	.LCFI63:
 5945              		.cfi_def_cfa_offset 8
 5946              		.cfi_offset 7, -8
 5947              		.cfi_offset 14, -4
 5948 0002 84B0     		sub	sp, sp, #16
 5949              	.LCFI64:
 5950              		.cfi_def_cfa_offset 24
 5951 0004 00AF     		add	r7, sp, #0
 5952              	.LCFI65:
 5953              		.cfi_def_cfa_register 7
 5954 0006 7860     		str	r0, [r7, #4]
 5955 0008 0A1C     		mov	r2, r1
 5956 000a FB1C     		add	r3, r7, #3
 5957 000c 1A70     		strb	r2, [r3]
1429:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
1430:../Sources/system/CrystalClock.c ****   unsigned char fcrdiv_val;
1431:../Sources/system/CrystalClock.c ****   short i;
1432:../Sources/system/CrystalClock.c ****   
1433:../Sources/system/CrystalClock.c **** // Check MCG is in FEI mode
1434:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5958              		.loc 1 1434 0
 5959 000e 7A4B     		ldr	r3, .L489
 5960 0010 9B79     		ldrb	r3, [r3, #6]
 5961 0012 DBB2     		uxtb	r3, r3
 5962 0014 1A1C     		mov	r2, r3
 5963 0016 0C23     		mov	r3, #12
 5964 0018 1340     		and	r3, r2
 5965 001a 9B08     		lsr	r3, r3, #2
 5966 001c 0DD1     		bne	.L461
1435:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5967              		.loc 1 1435 0
 5968 001e 764B     		ldr	r3, .L489
 5969 0020 9B79     		ldrb	r3, [r3, #6]
 5970 0022 DBB2     		uxtb	r3, r3
 5971 0024 1A1C     		mov	r2, r3
 5972 0026 1023     		mov	r3, #16
 5973 0028 1340     		and	r3, r2
1434:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5974              		.loc 1 1434 0
 5975 002a 06D0     		beq	.L461
1436:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 5976              		.loc 1 1436 0
 5977 002c 724B     		ldr	r3, .L489
 5978 002e 9B79     		ldrb	r3, [r3, #6]
 5979 0030 DBB2     		uxtb	r3, r3
 5980 0032 1A1C     		mov	r2, r3
 5981 0034 2023     		mov	r3, #32
 5982 0036 1340     		and	r3, r2
1434:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5983              		.loc 1 1434 0
 5984 0038 01D0     		beq	.L462
 5985              	.L461:
1437:../Sources/system/CrystalClock.c ****   {
1438:../Sources/system/CrystalClock.c ****     return 0x1;                                                       // return error code
 5986              		.loc 1 1438 0
 5987 003a 0123     		mov	r3, #1
 5988 003c D7E0     		b	.L463
 5989              	.L462:
1439:../Sources/system/CrystalClock.c ****   } 
1440:../Sources/system/CrystalClock.c **** 
1441:../Sources/system/CrystalClock.c **** // Check that the irc frequency matches the selected IRC 
1442:../Sources/system/CrystalClock.c ****   if (!(irc_select))
 5990              		.loc 1 1442 0
 5991 003e FB1C     		add	r3, r7, #3
 5992 0040 1B78     		ldrb	r3, [r3]
 5993 0042 002B     		cmp	r3, #0
 5994 0044 09D1     		bne	.L464
1443:../Sources/system/CrystalClock.c ****   {    
1444:../Sources/system/CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 5995              		.loc 1 1444 0
 5996 0046 7A68     		ldr	r2, [r7, #4]
 5997 0048 6C4B     		ldr	r3, .L489+4
 5998 004a 9A42     		cmp	r2, r3
 5999 004c 03DD     		ble	.L465
 6000              		.loc 1 1444 0 is_stmt 0
 6001 004e 7A68     		ldr	r2, [r7, #4]
 6002 0050 6B4B     		ldr	r3, .L489+8
 6003 0052 9A42     		cmp	r2, r3
 6004 0054 0BDD     		ble	.L466
 6005              	.L465:
 6006              		.loc 1 1444 0
 6007 0056 3123     		mov	r3, #49
 6008 0058 C9E0     		b	.L463
 6009              	.L464:
1445:../Sources/system/CrystalClock.c ****   }
1446:../Sources/system/CrystalClock.c ****   else
1447:../Sources/system/CrystalClock.c ****   {
1448:../Sources/system/CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 6010              		.loc 1 1448 0 is_stmt 1
 6011 005a 7A68     		ldr	r2, [r7, #4]
 6012 005c 694B     		ldr	r3, .L489+12
 6013 005e 9A42     		cmp	r2, r3
 6014 0060 03DD     		ble	.L467
 6015              		.loc 1 1448 0 is_stmt 0
 6016 0062 7A68     		ldr	r2, [r7, #4]
 6017 0064 684B     		ldr	r3, .L489+16
 6018 0066 9A42     		cmp	r2, r3
 6019 0068 01DD     		ble	.L466
 6020              	.L467:
 6021              		.loc 1 1448 0
 6022 006a 3223     		mov	r3, #50
 6023 006c BFE0     		b	.L463
 6024              	.L466:
1449:../Sources/system/CrystalClock.c ****   }
1450:../Sources/system/CrystalClock.c ****   
1451:../Sources/system/CrystalClock.c **** // Select the desired IRC
1452:../Sources/system/CrystalClock.c ****   if (irc_select)
 6025              		.loc 1 1452 0 is_stmt 1
 6026 006e FB1C     		add	r3, r7, #3
 6027 0070 1B78     		ldrb	r3, [r3]
 6028 0072 002B     		cmp	r3, #0
 6029 0074 08D0     		beq	.L468
1453:../Sources/system/CrystalClock.c ****   {
1454:../Sources/system/CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
 6030              		.loc 1 1454 0
 6031 0076 604B     		ldr	r3, .L489
 6032 0078 5F4A     		ldr	r2, .L489
 6033 007a 5278     		ldrb	r2, [r2, #1]
 6034 007c D2B2     		uxtb	r2, r2
 6035 007e 0121     		mov	r1, #1
 6036 0080 0A43     		orr	r2, r1
 6037 0082 D2B2     		uxtb	r2, r2
 6038 0084 5A70     		strb	r2, [r3, #1]
 6039 0086 07E0     		b	.L469
 6040              	.L468:
1455:../Sources/system/CrystalClock.c ****   }
1456:../Sources/system/CrystalClock.c ****   else
1457:../Sources/system/CrystalClock.c ****   {
1458:../Sources/system/CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
 6041              		.loc 1 1458 0
 6042 0088 5B4B     		ldr	r3, .L489
 6043 008a 5B4A     		ldr	r2, .L489
 6044 008c 5278     		ldrb	r2, [r2, #1]
 6045 008e D2B2     		uxtb	r2, r2
 6046 0090 0121     		mov	r1, #1
 6047 0092 8A43     		bic	r2, r1
 6048 0094 D2B2     		uxtb	r2, r2
 6049 0096 5A70     		strb	r2, [r3, #1]
 6050              	.L469:
1459:../Sources/system/CrystalClock.c ****   }
1460:../Sources/system/CrystalClock.c ****   
1461:../Sources/system/CrystalClock.c **** // Change the CLKS mux to select the IRC as the MCGOUT
1462:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 6051              		.loc 1 1462 0
 6052 0098 574A     		ldr	r2, .L489
 6053 009a 3B1C     		mov	r3, r7
 6054 009c 0D33     		add	r3, r3, #13
 6055 009e 1278     		ldrb	r2, [r2]
 6056 00a0 1A70     		strb	r2, [r3]
1463:../Sources/system/CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 6057              		.loc 1 1463 0
 6058 00a2 3B1C     		mov	r3, r7
 6059 00a4 0D33     		add	r3, r3, #13
 6060 00a6 3A1C     		mov	r2, r7
 6061 00a8 0D32     		add	r2, r2, #13
 6062 00aa 1178     		ldrb	r1, [r2]
 6063 00ac 3F22     		mov	r2, #63
 6064 00ae 0A40     		and	r2, r1
 6065 00b0 1A70     		strb	r2, [r3]
1464:../Sources/system/CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 6066              		.loc 1 1464 0
 6067 00b2 3B1C     		mov	r3, r7
 6068 00b4 0D33     		add	r3, r3, #13
 6069 00b6 3A1C     		mov	r2, r7
 6070 00b8 0D32     		add	r2, r2, #13
 6071 00ba 1278     		ldrb	r2, [r2]
 6072 00bc 4021     		mov	r1, #64
 6073 00be 0A43     		orr	r2, r1
 6074 00c0 1A70     		strb	r2, [r3]
1465:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg;
 6075              		.loc 1 1465 0
 6076 00c2 4D4B     		ldr	r3, .L489
 6077 00c4 3A1C     		mov	r2, r7
 6078 00c6 0D32     		add	r2, r2, #13
 6079 00c8 1278     		ldrb	r2, [r2]
 6080 00ca 1A70     		strb	r2, [r3]
1466:../Sources/system/CrystalClock.c **** 
1467:../Sources/system/CrystalClock.c **** // wait until internal reference switches to requested irc.
1468:../Sources/system/CrystalClock.c ****   if (!(irc_select))
 6081              		.loc 1 1468 0
 6082 00cc FB1C     		add	r3, r7, #3
 6083 00ce 1B78     		ldrb	r3, [r3]
 6084 00d0 002B     		cmp	r3, #0
 6085 00d2 24D1     		bne	.L470
1469:../Sources/system/CrystalClock.c ****   {
1470:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 6086              		.loc 1 1470 0
 6087 00d4 3B1C     		mov	r3, r7
 6088 00d6 0E33     		add	r3, r3, #14
 6089 00d8 0022     		mov	r2, #0
 6090 00da 1A80     		strh	r2, [r3]
 6091 00dc 0DE0     		b	.L471
 6092              	.L474:
1471:../Sources/system/CrystalClock.c ****     {
1472:../Sources/system/CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 6093              		.loc 1 1472 0
 6094 00de 464B     		ldr	r3, .L489
 6095 00e0 9B79     		ldrb	r3, [r3, #6]
 6096 00e2 DBB2     		uxtb	r3, r3
 6097 00e4 1A1C     		mov	r2, r3
 6098 00e6 0123     		mov	r3, #1
 6099 00e8 1340     		and	r3, r2
 6100 00ea 0ED0     		beq	.L486
 6101              	.L472:
1470:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 6102              		.loc 1 1470 0
 6103 00ec 3B1C     		mov	r3, r7
 6104 00ee 0E33     		add	r3, r3, #14
 6105 00f0 3A1C     		mov	r2, r7
 6106 00f2 0E32     		add	r2, r2, #14
 6107 00f4 1288     		ldrh	r2, [r2]
 6108 00f6 0132     		add	r2, r2, #1
 6109 00f8 1A80     		strh	r2, [r3]
 6110              	.L471:
1470:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 6111              		.loc 1 1470 0 is_stmt 0
 6112 00fa 3B1C     		mov	r3, r7
 6113 00fc 0E33     		add	r3, r3, #14
 6114 00fe 0021     		mov	r1, #0
 6115 0100 5A5E     		ldrsh	r2, [r3, r1]
 6116 0102 424B     		ldr	r3, .L489+20
 6117 0104 9A42     		cmp	r2, r3
 6118 0106 EADD     		ble	.L474
 6119 0108 00E0     		b	.L473
 6120              	.L486:
 6121              		.loc 1 1472 0 is_stmt 1
 6122 010a C046     		mov	r8, r8
 6123              	.L473:
1473:../Sources/system/CrystalClock.c ****     }
1474:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 6124              		.loc 1 1474 0
 6125 010c 3A4B     		ldr	r3, .L489
 6126 010e 9B79     		ldrb	r3, [r3, #6]
 6127 0110 DBB2     		uxtb	r3, r3
 6128 0112 1A1C     		mov	r2, r3
 6129 0114 0123     		mov	r3, #1
 6130 0116 1340     		and	r3, r2
 6131 0118 26D0     		beq	.L475
 6132              		.loc 1 1474 0 is_stmt 0
 6133 011a 1323     		mov	r3, #19
 6134 011c 67E0     		b	.L463
 6135              	.L470:
1475:../Sources/system/CrystalClock.c ****   }
1476:../Sources/system/CrystalClock.c ****   else
1477:../Sources/system/CrystalClock.c ****   {
1478:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 6136              		.loc 1 1478 0 is_stmt 1
 6137 011e 3B1C     		mov	r3, r7
 6138 0120 0E33     		add	r3, r3, #14
 6139 0122 0022     		mov	r2, #0
 6140 0124 1A80     		strh	r2, [r3]
 6141 0126 0DE0     		b	.L476
 6142              	.L479:
1479:../Sources/system/CrystalClock.c ****     {
1480:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 6143              		.loc 1 1480 0
 6144 0128 334B     		ldr	r3, .L489
 6145 012a 9B79     		ldrb	r3, [r3, #6]
 6146 012c DBB2     		uxtb	r3, r3
 6147 012e 1A1C     		mov	r2, r3
 6148 0130 0123     		mov	r3, #1
 6149 0132 1340     		and	r3, r2
 6150 0134 0ED1     		bne	.L487
 6151              	.L477:
1478:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 6152              		.loc 1 1478 0
 6153 0136 3B1C     		mov	r3, r7
 6154 0138 0E33     		add	r3, r3, #14
 6155 013a 3A1C     		mov	r2, r7
 6156 013c 0E32     		add	r2, r2, #14
 6157 013e 1288     		ldrh	r2, [r2]
 6158 0140 0132     		add	r2, r2, #1
 6159 0142 1A80     		strh	r2, [r3]
 6160              	.L476:
1478:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 6161              		.loc 1 1478 0 is_stmt 0
 6162 0144 3B1C     		mov	r3, r7
 6163 0146 0E33     		add	r3, r3, #14
 6164 0148 0021     		mov	r1, #0
 6165 014a 5A5E     		ldrsh	r2, [r3, r1]
 6166 014c 2F4B     		ldr	r3, .L489+20
 6167 014e 9A42     		cmp	r2, r3
 6168 0150 EADD     		ble	.L479
 6169 0152 00E0     		b	.L478
 6170              	.L487:
 6171              		.loc 1 1480 0 is_stmt 1
 6172 0154 C046     		mov	r8, r8
 6173              	.L478:
1481:../Sources/system/CrystalClock.c ****     }
1482:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 6174              		.loc 1 1482 0
 6175 0156 284B     		ldr	r3, .L489
 6176 0158 9B79     		ldrb	r3, [r3, #6]
 6177 015a DBB2     		uxtb	r3, r3
 6178 015c 1A1C     		mov	r2, r3
 6179 015e 0123     		mov	r3, #1
 6180 0160 1340     		and	r3, r2
 6181 0162 01D1     		bne	.L475
 6182              		.loc 1 1482 0 is_stmt 0
 6183 0164 1423     		mov	r3, #20
 6184 0166 42E0     		b	.L463
 6185              	.L475:
1483:../Sources/system/CrystalClock.c ****   }
1484:../Sources/system/CrystalClock.c ****   
1485:../Sources/system/CrystalClock.c **** // Wait for clock status bits to update
1486:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6186              		.loc 1 1486 0 is_stmt 1
 6187 0168 3B1C     		mov	r3, r7
 6188 016a 0E33     		add	r3, r3, #14
 6189 016c 0022     		mov	r2, #0
 6190 016e 1A80     		strh	r2, [r3]
 6191 0170 0FE0     		b	.L480
 6192              	.L483:
1487:../Sources/system/CrystalClock.c ****   {
1488:../Sources/system/CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 6193              		.loc 1 1488 0
 6194 0172 214B     		ldr	r3, .L489
 6195 0174 9B79     		ldrb	r3, [r3, #6]
 6196 0176 DBB2     		uxtb	r3, r3
 6197 0178 1A1C     		mov	r2, r3
 6198 017a 0C23     		mov	r3, #12
 6199 017c 1340     		and	r3, r2
 6200 017e 9B08     		lsr	r3, r3, #2
 6201 0180 012B     		cmp	r3, #1
 6202 0182 0ED0     		beq	.L488
 6203              	.L481:
1486:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6204              		.loc 1 1486 0
 6205 0184 3B1C     		mov	r3, r7
 6206 0186 0E33     		add	r3, r3, #14
 6207 0188 3A1C     		mov	r2, r7
 6208 018a 0E32     		add	r2, r2, #14
 6209 018c 1288     		ldrh	r2, [r2]
 6210 018e 0132     		add	r2, r2, #1
 6211 0190 1A80     		strh	r2, [r3]
 6212              	.L480:
1486:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6213              		.loc 1 1486 0 is_stmt 0
 6214 0192 3B1C     		mov	r3, r7
 6215 0194 0E33     		add	r3, r3, #14
 6216 0196 0021     		mov	r1, #0
 6217 0198 5A5E     		ldrsh	r2, [r3, r1]
 6218 019a 1C4B     		ldr	r3, .L489+20
 6219 019c 9A42     		cmp	r2, r3
 6220 019e E8DD     		ble	.L483
 6221 01a0 00E0     		b	.L482
 6222              	.L488:
 6223              		.loc 1 1488 0 is_stmt 1
 6224 01a2 C046     		mov	r8, r8
 6225              	.L482:
1489:../Sources/system/CrystalClock.c ****   }
1490:../Sources/system/CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 6226              		.loc 1 1490 0
 6227 01a4 144B     		ldr	r3, .L489
 6228 01a6 9B79     		ldrb	r3, [r3, #6]
 6229 01a8 DBB2     		uxtb	r3, r3
 6230 01aa 1A1C     		mov	r2, r3
 6231 01ac 0C23     		mov	r3, #12
 6232 01ae 1340     		and	r3, r2
 6233 01b0 9B08     		lsr	r3, r3, #2
 6234 01b2 012B     		cmp	r3, #1
 6235 01b4 01D0     		beq	.L484
 6236              		.loc 1 1490 0 is_stmt 0
 6237 01b6 1923     		mov	r3, #25
 6238 01b8 19E0     		b	.L463
 6239              	.L484:
1491:../Sources/system/CrystalClock.c ****   
1492:../Sources/system/CrystalClock.c **** // Now in FBI mode
1493:../Sources/system/CrystalClock.c ****   if (irc_select)
 6240              		.loc 1 1493 0 is_stmt 1
 6241 01ba FB1C     		add	r3, r7, #3
 6242 01bc 1B78     		ldrb	r3, [r3]
 6243 01be 002B     		cmp	r3, #0
 6244 01c0 14D0     		beq	.L485
1494:../Sources/system/CrystalClock.c ****   {
1495:../Sources/system/CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 6245              		.loc 1 1495 0
 6246 01c2 0D4B     		ldr	r3, .L489
 6247 01c4 1B7A     		ldrb	r3, [r3, #8]
 6248 01c6 DBB2     		uxtb	r3, r3
 6249 01c8 1A1C     		mov	r2, r3
 6250 01ca 0E23     		mov	r3, #14
 6251 01cc 1340     		and	r3, r2
 6252 01ce 5B08     		lsr	r3, r3, #1
 6253 01d0 0122     		mov	r2, #1
 6254 01d2 9A40     		lsl	r2, r2, r3
 6255 01d4 3B1C     		mov	r3, r7
 6256 01d6 0C33     		add	r3, r3, #12
 6257 01d8 1A70     		strb	r2, [r3]
1496:../Sources/system/CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 6258              		.loc 1 1496 0
 6259 01da 3B1C     		mov	r3, r7
 6260 01dc 0C33     		add	r3, r3, #12
 6261 01de 1B78     		ldrb	r3, [r3]
 6262 01e0 7868     		ldr	r0, [r7, #4]
 6263 01e2 191C     		mov	r1, r3
 6264 01e4 FFF7FEFF 		bl	__aeabi_idiv
 6265 01e8 031C     		mov	r3, r0
 6266 01ea 00E0     		b	.L463
 6267              	.L485:
1497:../Sources/system/CrystalClock.c ****   }
1498:../Sources/system/CrystalClock.c ****   else
1499:../Sources/system/CrystalClock.c ****   {
1500:../Sources/system/CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 6268              		.loc 1 1500 0
 6269 01ec 7B68     		ldr	r3, [r7, #4]
 6270              	.L463:
1501:../Sources/system/CrystalClock.c ****   }   
1502:../Sources/system/CrystalClock.c **** } // fei_fbi
 6271              		.loc 1 1502 0
 6272 01ee 181C     		mov	r0, r3
 6273 01f0 BD46     		mov	sp, r7
 6274 01f2 04B0     		add	sp, sp, #16
 6275              		@ sp needed for prologue
 6276 01f4 80BD     		pop	{r7, pc}
 6277              	.L490:
 6278 01f6 C046     		.align	2
 6279              	.L489:
 6280 01f8 00400640 		.word	1074151424
 6281 01fc 117A0000 		.word	31249
 6282 0200 97980000 		.word	39063
 6283 0204 BFC62D00 		.word	2999999
 6284 0208 404B4C00 		.word	5000000
 6285 020c CF070000 		.word	1999
 6286              		.cfi_endproc
 6287              	.LFE21:
 6289              		.section	.text.fei_fee,"ax",%progbits
 6290              		.align	2
 6291              		.global	fei_fee
 6292              		.code	16
 6293              		.thumb_func
 6295              	fei_fee:
 6296              	.LFB22:
1503:../Sources/system/CrystalClock.c **** 
1504:../Sources/system/CrystalClock.c **** 
1505:../Sources/system/CrystalClock.c **** /********************************************************************/
1506:../Sources/system/CrystalClock.c **** /* Functon name : fei_fee
1507:../Sources/system/CrystalClock.c ****  *
1508:../Sources/system/CrystalClock.c ****  * Mode transition: FEI to FEE mode
1509:../Sources/system/CrystalClock.c ****  *
1510:../Sources/system/CrystalClock.c ****  * This function transitions the MCG from FEI mode to FEE mode. This is
1511:../Sources/system/CrystalClock.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1512:../Sources/system/CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
1513:../Sources/system/CrystalClock.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
1514:../Sources/system/CrystalClock.c ****  *
1515:../Sources/system/CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz
1516:../Sources/system/CrystalClock.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
1517:../Sources/system/CrystalClock.c ****  *                           for the crystal oscillator. This has no meaning if an 
1518:../Sources/system/CrystalClock.c ****  *                           external clock is used.
1519:../Sources/system/CrystalClock.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
1520:../Sources/system/CrystalClock.c ****  *
1521:../Sources/system/CrystalClock.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
1522:../Sources/system/CrystalClock.c ****  */
1523:../Sources/system/CrystalClock.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1524:../Sources/system/CrystalClock.c **** {
 6297              		.loc 1 1524 0
 6298              		.cfi_startproc
 6299 0000 80B5     		push	{r7, lr}
 6300              	.LCFI66:
 6301              		.cfi_def_cfa_offset 8
 6302              		.cfi_offset 7, -8
 6303              		.cfi_offset 14, -4
 6304 0002 86B0     		sub	sp, sp, #24
 6305              	.LCFI67:
 6306              		.cfi_def_cfa_offset 32
 6307 0004 00AF     		add	r7, sp, #0
 6308              	.LCFI68:
 6309              		.cfi_def_cfa_register 7
 6310 0006 7860     		str	r0, [r7, #4]
 6311 0008 FB1C     		add	r3, r7, #3
 6312 000a 1970     		strb	r1, [r3]
 6313 000c BB1C     		add	r3, r7, #2
 6314 000e 1A70     		strb	r2, [r3]
1525:../Sources/system/CrystalClock.c ****   unsigned char frdiv_val;
1526:../Sources/system/CrystalClock.c ****   unsigned char temp_reg;
1527:../Sources/system/CrystalClock.c ****  // short i;
1528:../Sources/system/CrystalClock.c ****   int mcg_out, fll_ref_freq, i;
1529:../Sources/system/CrystalClock.c ****   
1530:../Sources/system/CrystalClock.c **** // check if in FEI mode
1531:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6315              		.loc 1 1531 0
 6316 0010 AC4B     		ldr	r3, .L524
 6317 0012 9B79     		ldrb	r3, [r3, #6]
 6318 0014 DBB2     		uxtb	r3, r3
 6319 0016 1A1C     		mov	r2, r3
 6320 0018 0C23     		mov	r3, #12
 6321 001a 1340     		and	r3, r2
 6322 001c 9B08     		lsr	r3, r3, #2
 6323 001e 0DD1     		bne	.L492
1532:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 6324              		.loc 1 1532 0
 6325 0020 A84B     		ldr	r3, .L524
 6326 0022 9B79     		ldrb	r3, [r3, #6]
 6327 0024 DBB2     		uxtb	r3, r3
 6328 0026 1A1C     		mov	r2, r3
 6329 0028 1023     		mov	r3, #16
 6330 002a 1340     		and	r3, r2
1531:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6331              		.loc 1 1531 0
 6332 002c 06D0     		beq	.L492
1533:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 6333              		.loc 1 1533 0
 6334 002e A54B     		ldr	r3, .L524
 6335 0030 9B79     		ldrb	r3, [r3, #6]
 6336 0032 DBB2     		uxtb	r3, r3
 6337 0034 1A1C     		mov	r2, r3
 6338 0036 2023     		mov	r3, #32
 6339 0038 1340     		and	r3, r2
1531:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6340              		.loc 1 1531 0
 6341 003a 01D0     		beq	.L493
 6342              	.L492:
1534:../Sources/system/CrystalClock.c ****   {
1535:../Sources/system/CrystalClock.c ****     return 0x1;                                                     // return error code
 6343              		.loc 1 1535 0
 6344 003c 0123     		mov	r3, #1
 6345 003e 3CE1     		b	.L494
 6346              	.L493:
1536:../Sources/system/CrystalClock.c ****   }
1537:../Sources/system/CrystalClock.c **** 
1538:../Sources/system/CrystalClock.c **** // check external frequency is less than the maximum frequency
1539:../Sources/system/CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 6347              		.loc 1 1539 0
 6348 0040 7A68     		ldr	r2, [r7, #4]
 6349 0042 A14B     		ldr	r3, .L524+4
 6350 0044 9A42     		cmp	r2, r3
 6351 0046 01DD     		ble	.L495
 6352              		.loc 1 1539 0 is_stmt 0
 6353 0048 2123     		mov	r3, #33
 6354 004a 36E1     		b	.L494
 6355              	.L495:
1540:../Sources/system/CrystalClock.c ****   
1541:../Sources/system/CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
1542:../Sources/system/CrystalClock.c ****   if (erefs_val)
 6356              		.loc 1 1542 0 is_stmt 1
 6357 004c BB1C     		add	r3, r7, #2
 6358 004e 1B78     		ldrb	r3, [r3]
 6359 0050 002B     		cmp	r3, #0
 6360 0052 11D0     		beq	.L496
1543:../Sources/system/CrystalClock.c ****   {
1544:../Sources/system/CrystalClock.c ****     if ((crystal_val < 30000) ||
 6361              		.loc 1 1544 0
 6362 0054 7A68     		ldr	r2, [r7, #4]
 6363 0056 9D4B     		ldr	r3, .L524+8
 6364 0058 9A42     		cmp	r2, r3
 6365 005a 0BDD     		ble	.L497
 6366              		.loc 1 1544 0 is_stmt 0
 6367 005c 7A68     		ldr	r2, [r7, #4]
 6368 005e 9C4B     		ldr	r3, .L524+12
 6369 0060 9A42     		cmp	r2, r3
 6370 0062 03DD     		ble	.L498
1545:../Sources/system/CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 6371              		.loc 1 1545 0 is_stmt 1
 6372 0064 7A68     		ldr	r2, [r7, #4]
 6373 0066 9B4B     		ldr	r3, .L524+16
 6374 0068 9A42     		cmp	r2, r3
 6375 006a 03DD     		ble	.L497
 6376              	.L498:
 6377              		.loc 1 1545 0 is_stmt 0
 6378 006c 7A68     		ldr	r2, [r7, #4]
 6379 006e 9A4B     		ldr	r3, .L524+20
 6380 0070 9A42     		cmp	r2, r3
 6381 0072 01DD     		ble	.L496
 6382              	.L497:
1546:../Sources/system/CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 6383              		.loc 1 1546 0 is_stmt 1
 6384 0074 2223     		mov	r3, #34
 6385 0076 20E1     		b	.L494
 6386              	.L496:
1547:../Sources/system/CrystalClock.c ****   }
1548:../Sources/system/CrystalClock.c **** 
1549:../Sources/system/CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1550:../Sources/system/CrystalClock.c ****   if (hgo_val > 0)
 6387              		.loc 1 1550 0
 6388 0078 FB1C     		add	r3, r7, #3
 6389 007a 1B78     		ldrb	r3, [r3]
 6390 007c 002B     		cmp	r3, #0
 6391 007e 02D0     		beq	.L499
1551:../Sources/system/CrystalClock.c ****   {
1552:../Sources/system/CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 6392              		.loc 1 1552 0
 6393 0080 FB1C     		add	r3, r7, #3
 6394 0082 0122     		mov	r2, #1
 6395 0084 1A70     		strb	r2, [r3]
 6396              	.L499:
1553:../Sources/system/CrystalClock.c ****   }
1554:../Sources/system/CrystalClock.c **** 
1555:../Sources/system/CrystalClock.c **** // configure the MCG_C2 register
1556:../Sources/system/CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1557:../Sources/system/CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
1558:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C2;
 6397              		.loc 1 1558 0
 6398 0086 8F4A     		ldr	r2, .L524
 6399 0088 3B1C     		mov	r3, r7
 6400 008a 1633     		add	r3, r3, #22
 6401 008c 5278     		ldrb	r2, [r2, #1]
 6402 008e 1A70     		strb	r2, [r3]
1559:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 6403              		.loc 1 1559 0
 6404 0090 3B1C     		mov	r3, r7
 6405 0092 1633     		add	r3, r3, #22
 6406 0094 3A1C     		mov	r2, r7
 6407 0096 1632     		add	r2, r2, #22
 6408 0098 1278     		ldrb	r2, [r2]
 6409 009a 3C21     		mov	r1, #60
 6410 009c 8A43     		bic	r2, r1
 6411 009e 1A70     		strb	r2, [r3]
1560:../Sources/system/CrystalClock.c ****   if (crystal_val <= 40000)
 6412              		.loc 1 1560 0
 6413 00a0 7A68     		ldr	r2, [r7, #4]
 6414 00a2 8B4B     		ldr	r3, .L524+12
 6415 00a4 9A42     		cmp	r2, r3
 6416 00a6 11DC     		bgt	.L500
1561:../Sources/system/CrystalClock.c ****   {
1562:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 6417              		.loc 1 1562 0
 6418 00a8 FB1C     		add	r3, r7, #3
 6419 00aa 1B78     		ldrb	r3, [r3]
 6420 00ac DB00     		lsl	r3, r3, #3
 6421 00ae DAB2     		uxtb	r2, r3
 6422 00b0 BB1C     		add	r3, r7, #2
 6423 00b2 1B78     		ldrb	r3, [r3]
 6424 00b4 9B00     		lsl	r3, r3, #2
 6425 00b6 DBB2     		uxtb	r3, r3
 6426 00b8 1343     		orr	r3, r2
 6427 00ba D9B2     		uxtb	r1, r3
 6428 00bc 3B1C     		mov	r3, r7
 6429 00be 1633     		add	r3, r3, #22
 6430 00c0 3A1C     		mov	r2, r7
 6431 00c2 1632     		add	r2, r2, #22
 6432 00c4 1278     		ldrb	r2, [r2]
 6433 00c6 0A43     		orr	r2, r1
 6434 00c8 1A70     		strb	r2, [r3]
 6435 00ca 2CE0     		b	.L501
 6436              	.L500:
1563:../Sources/system/CrystalClock.c ****   }
1564:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 8000000)
 6437              		.loc 1 1564 0
 6438 00cc 7A68     		ldr	r2, [r7, #4]
 6439 00ce 834B     		ldr	r3, .L524+24
 6440 00d0 9A42     		cmp	r2, r3
 6441 00d2 14DC     		bgt	.L502
1565:../Sources/system/CrystalClock.c ****   {
1566:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 6442              		.loc 1 1566 0
 6443 00d4 FB1C     		add	r3, r7, #3
 6444 00d6 1B78     		ldrb	r3, [r3]
 6445 00d8 DB00     		lsl	r3, r3, #3
 6446 00da DAB2     		uxtb	r2, r3
 6447 00dc BB1C     		add	r3, r7, #2
 6448 00de 1B78     		ldrb	r3, [r3]
 6449 00e0 9B00     		lsl	r3, r3, #2
 6450 00e2 DBB2     		uxtb	r3, r3
 6451 00e4 1343     		orr	r3, r2
 6452 00e6 DAB2     		uxtb	r2, r3
 6453 00e8 3B1C     		mov	r3, r7
 6454 00ea 1633     		add	r3, r3, #22
 6455 00ec 1B78     		ldrb	r3, [r3]
 6456 00ee 1343     		orr	r3, r2
 6457 00f0 DAB2     		uxtb	r2, r3
 6458 00f2 3B1C     		mov	r3, r7
 6459 00f4 1633     		add	r3, r3, #22
 6460 00f6 1021     		mov	r1, #16
 6461 00f8 0A43     		orr	r2, r1
 6462 00fa 1A70     		strb	r2, [r3]
 6463 00fc 13E0     		b	.L501
 6464              	.L502:
1567:../Sources/system/CrystalClock.c ****   }
1568:../Sources/system/CrystalClock.c ****   else
1569:../Sources/system/CrystalClock.c ****   {
1570:../Sources/system/CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 6465              		.loc 1 1570 0
 6466 00fe FB1C     		add	r3, r7, #3
 6467 0100 1B78     		ldrb	r3, [r3]
 6468 0102 DB00     		lsl	r3, r3, #3
 6469 0104 DAB2     		uxtb	r2, r3
 6470 0106 BB1C     		add	r3, r7, #2
 6471 0108 1B78     		ldrb	r3, [r3]
 6472 010a 9B00     		lsl	r3, r3, #2
 6473 010c DBB2     		uxtb	r3, r3
 6474 010e 1343     		orr	r3, r2
 6475 0110 DAB2     		uxtb	r2, r3
 6476 0112 3B1C     		mov	r3, r7
 6477 0114 1633     		add	r3, r3, #22
 6478 0116 1B78     		ldrb	r3, [r3]
 6479 0118 1343     		orr	r3, r2
 6480 011a DAB2     		uxtb	r2, r3
 6481 011c 3B1C     		mov	r3, r7
 6482 011e 1633     		add	r3, r3, #22
 6483 0120 2021     		mov	r1, #32
 6484 0122 0A43     		orr	r2, r1
 6485 0124 1A70     		strb	r2, [r3]
 6486              	.L501:
1571:../Sources/system/CrystalClock.c ****   }
1572:../Sources/system/CrystalClock.c ****   MCG_C2 = temp_reg;
 6487              		.loc 1 1572 0
 6488 0126 674B     		ldr	r3, .L524
 6489 0128 3A1C     		mov	r2, r7
 6490 012a 1632     		add	r2, r2, #22
 6491 012c 1278     		ldrb	r2, [r2]
 6492 012e 5A70     		strb	r2, [r3, #1]
1573:../Sources/system/CrystalClock.c **** 
1574:../Sources/system/CrystalClock.c **** // determine FRDIV based on reference clock frequency
1575:../Sources/system/CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1576:../Sources/system/CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 6493              		.loc 1 1576 0
 6494 0130 7A68     		ldr	r2, [r7, #4]
 6495 0132 6B4B     		ldr	r3, .L524+28
 6496 0134 9A42     		cmp	r2, r3
 6497 0136 04DC     		bgt	.L503
 6498              		.loc 1 1576 0 is_stmt 0
 6499 0138 3B1C     		mov	r3, r7
 6500 013a 1733     		add	r3, r3, #23
 6501 013c 0022     		mov	r2, #0
 6502 013e 1A70     		strb	r2, [r3]
 6503 0140 27E0     		b	.L504
 6504              	.L503:
1577:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 6505              		.loc 1 1577 0 is_stmt 1
 6506 0142 7A68     		ldr	r2, [r7, #4]
 6507 0144 674B     		ldr	r3, .L524+32
 6508 0146 9A42     		cmp	r2, r3
 6509 0148 04DC     		bgt	.L505
 6510              		.loc 1 1577 0 is_stmt 0
 6511 014a 3B1C     		mov	r3, r7
 6512 014c 1733     		add	r3, r3, #23
 6513 014e 0122     		mov	r2, #1
 6514 0150 1A70     		strb	r2, [r3]
 6515 0152 1EE0     		b	.L504
 6516              	.L505:
1578:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 6517              		.loc 1 1578 0 is_stmt 1
 6518 0154 7A68     		ldr	r2, [r7, #4]
 6519 0156 644B     		ldr	r3, .L524+36
 6520 0158 9A42     		cmp	r2, r3
 6521 015a 04DC     		bgt	.L506
 6522              		.loc 1 1578 0 is_stmt 0
 6523 015c 3B1C     		mov	r3, r7
 6524 015e 1733     		add	r3, r3, #23
 6525 0160 0222     		mov	r2, #2
 6526 0162 1A70     		strb	r2, [r3]
 6527 0164 15E0     		b	.L504
 6528              	.L506:
1579:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 6529              		.loc 1 1579 0 is_stmt 1
 6530 0166 7A68     		ldr	r2, [r7, #4]
 6531 0168 604B     		ldr	r3, .L524+40
 6532 016a 9A42     		cmp	r2, r3
 6533 016c 04DC     		bgt	.L507
 6534              		.loc 1 1579 0 is_stmt 0
 6535 016e 3B1C     		mov	r3, r7
 6536 0170 1733     		add	r3, r3, #23
 6537 0172 0322     		mov	r2, #3
 6538 0174 1A70     		strb	r2, [r3]
 6539 0176 0CE0     		b	.L504
 6540              	.L507:
1580:../Sources/system/CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 6541              		.loc 1 1580 0 is_stmt 1
 6542 0178 7A68     		ldr	r2, [r7, #4]
 6543 017a 5D4B     		ldr	r3, .L524+44
 6544 017c 9A42     		cmp	r2, r3
 6545 017e 04DC     		bgt	.L508
 6546              		.loc 1 1580 0 is_stmt 0
 6547 0180 3B1C     		mov	r3, r7
 6548 0182 1733     		add	r3, r3, #23
 6549 0184 0422     		mov	r2, #4
 6550 0186 1A70     		strb	r2, [r3]
 6551 0188 03E0     		b	.L504
 6552              	.L508:
1581:../Sources/system/CrystalClock.c ****   else {frdiv_val = 5;}
 6553              		.loc 1 1581 0 is_stmt 1
 6554 018a 3B1C     		mov	r3, r7
 6555 018c 1733     		add	r3, r3, #23
 6556 018e 0522     		mov	r2, #5
 6557 0190 1A70     		strb	r2, [r3]
 6558              	.L504:
1582:../Sources/system/CrystalClock.c ****    
1583:../Sources/system/CrystalClock.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
1584:../Sources/system/CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 6559              		.loc 1 1584 0
 6560 0192 4C4B     		ldr	r3, .L524
 6561 0194 5B78     		ldrb	r3, [r3, #1]
 6562 0196 DBB2     		uxtb	r3, r3
 6563 0198 1A1C     		mov	r2, r3
 6564 019a 3023     		mov	r3, #48
 6565 019c 1340     		and	r3, r2
 6566 019e 1B09     		lsr	r3, r3, #4
 6567 01a0 0DD0     		beq	.L509
1585:../Sources/system/CrystalClock.c ****   {
1586:../Sources/system/CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 6568              		.loc 1 1586 0
 6569 01a2 3B1C     		mov	r3, r7
 6570 01a4 1733     		add	r3, r3, #23
 6571 01a6 1B78     		ldrb	r3, [r3]
 6572 01a8 2022     		mov	r2, #32
 6573 01aa 111C     		mov	r1, r2
 6574 01ac 9940     		lsl	r1, r1, r3
 6575 01ae 0B1C     		mov	r3, r1
 6576 01b0 7868     		ldr	r0, [r7, #4]
 6577 01b2 191C     		mov	r1, r3
 6578 01b4 FFF7FEFF 		bl	__aeabi_idiv
 6579 01b8 031C     		mov	r3, r0
 6580 01ba 3B61     		str	r3, [r7, #16]
 6581 01bc 0CE0     		b	.L510
 6582              	.L509:
1587:../Sources/system/CrystalClock.c ****   }
1588:../Sources/system/CrystalClock.c ****   else
1589:../Sources/system/CrystalClock.c ****   {
1590:../Sources/system/CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 6583              		.loc 1 1590 0
 6584 01be 3B1C     		mov	r3, r7
 6585 01c0 1733     		add	r3, r3, #23
 6586 01c2 1B78     		ldrb	r3, [r3]
 6587 01c4 0122     		mov	r2, #1
 6588 01c6 111C     		mov	r1, r2
 6589 01c8 9940     		lsl	r1, r1, r3
 6590 01ca 0B1C     		mov	r3, r1
 6591 01cc 7868     		ldr	r0, [r7, #4]
 6592 01ce 191C     		mov	r1, r3
 6593 01d0 FFF7FEFF 		bl	__aeabi_idiv
 6594 01d4 031C     		mov	r3, r0
 6595 01d6 3B61     		str	r3, [r7, #16]
 6596              	.L510:
1591:../Sources/system/CrystalClock.c ****   }
1592:../Sources/system/CrystalClock.c ****   
1593:../Sources/system/CrystalClock.c **** // Check resulting FLL frequency 
1594:../Sources/system/CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 6597              		.loc 1 1594 0
 6598 01d8 3B69     		ldr	r3, [r7, #16]
 6599 01da 181C     		mov	r0, r3
 6600 01dc FFF7FEFF 		bl	fll_freq
 6601 01e0 031C     		mov	r3, r0
 6602 01e2 BB60     		str	r3, [r7, #8]
1595:../Sources/system/CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 6603              		.loc 1 1595 0
 6604 01e4 BB68     		ldr	r3, [r7, #8]
 6605 01e6 3B2B     		cmp	r3, #59
 6606 01e8 01DC     		bgt	.L511
 6607              		.loc 1 1595 0 is_stmt 0
 6608 01ea BB68     		ldr	r3, [r7, #8]
 6609 01ec 65E0     		b	.L494
 6610              	.L511:
1596:../Sources/system/CrystalClock.c ****   
1597:../Sources/system/CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1598:../Sources/system/CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1599:../Sources/system/CrystalClock.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1600:../Sources/system/CrystalClock.c ****   temp_reg = MCG_C1;
 6611              		.loc 1 1600 0 is_stmt 1
 6612 01ee 354A     		ldr	r2, .L524
 6613 01f0 3B1C     		mov	r3, r7
 6614 01f2 1633     		add	r3, r3, #22
 6615 01f4 1278     		ldrb	r2, [r2]
 6616 01f6 1A70     		strb	r2, [r3]
1601:../Sources/system/CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 6617              		.loc 1 1601 0
 6618 01f8 3B1C     		mov	r3, r7
 6619 01fa 1633     		add	r3, r3, #22
 6620 01fc 3A1C     		mov	r2, r7
 6621 01fe 1632     		add	r2, r2, #22
 6622 0200 1178     		ldrb	r1, [r2]
 6623 0202 0322     		mov	r2, #3
 6624 0204 0A40     		and	r2, r1
 6625 0206 1A70     		strb	r2, [r3]
1602:../Sources/system/CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 6626              		.loc 1 1602 0
 6627 0208 3B1C     		mov	r3, r7
 6628 020a 1733     		add	r3, r3, #23
 6629 020c 1B78     		ldrb	r3, [r3]
 6630 020e DB00     		lsl	r3, r3, #3
 6631 0210 DAB2     		uxtb	r2, r3
 6632 0212 3823     		mov	r3, #56
 6633 0214 1340     		and	r3, r2
 6634 0216 D9B2     		uxtb	r1, r3
 6635 0218 3B1C     		mov	r3, r7
 6636 021a 1633     		add	r3, r3, #22
 6637 021c 3A1C     		mov	r2, r7
 6638 021e 1632     		add	r2, r2, #22
 6639 0220 1278     		ldrb	r2, [r2]
 6640 0222 0A43     		orr	r2, r1
 6641 0224 1A70     		strb	r2, [r3]
1603:../Sources/system/CrystalClock.c ****   MCG_C1 = temp_reg;
 6642              		.loc 1 1603 0
 6643 0226 274B     		ldr	r3, .L524
 6644 0228 3A1C     		mov	r2, r7
 6645 022a 1632     		add	r2, r2, #22
 6646 022c 1278     		ldrb	r2, [r2]
 6647 022e 1A70     		strb	r2, [r3]
1604:../Sources/system/CrystalClock.c **** 
1605:../Sources/system/CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
1606:../Sources/system/CrystalClock.c ****   if (erefs_val)
 6648              		.loc 1 1606 0
 6649 0230 BB1C     		add	r3, r7, #2
 6650 0232 1B78     		ldrb	r3, [r3]
 6651 0234 002B     		cmp	r3, #0
 6652 0236 1BD0     		beq	.L512
1607:../Sources/system/CrystalClock.c ****   {
1608:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 20000000 ; i++)
 6653              		.loc 1 1608 0
 6654 0238 0023     		mov	r3, #0
 6655 023a FB60     		str	r3, [r7, #12]
 6656 023c 09E0     		b	.L513
 6657              	.L516:
1609:../Sources/system/CrystalClock.c ****     {
1610:../Sources/system/CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 6658              		.loc 1 1610 0
 6659 023e 214B     		ldr	r3, .L524
 6660 0240 9B79     		ldrb	r3, [r3, #6]
 6661 0242 DBB2     		uxtb	r3, r3
 6662 0244 1A1C     		mov	r2, r3
 6663 0246 0223     		mov	r3, #2
 6664 0248 1340     		and	r3, r2
 6665 024a 07D1     		bne	.L522
 6666              	.L514:
1608:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 20000000 ; i++)
 6667              		.loc 1 1608 0
 6668 024c FB68     		ldr	r3, [r7, #12]
 6669 024e 0133     		add	r3, r3, #1
 6670 0250 FB60     		str	r3, [r7, #12]
 6671              	.L513:
1608:../Sources/system/CrystalClock.c ****     for (i = 0 ; i < 20000000 ; i++)
 6672              		.loc 1 1608 0 is_stmt 0
 6673 0252 FA68     		ldr	r2, [r7, #12]
 6674 0254 274B     		ldr	r3, .L524+48
 6675 0256 9A42     		cmp	r2, r3
 6676 0258 F1DD     		ble	.L516
 6677 025a 00E0     		b	.L515
 6678              	.L522:
 6679              		.loc 1 1610 0 is_stmt 1
 6680 025c C046     		mov	r8, r8
 6681              	.L515:
1611:../Sources/system/CrystalClock.c ****     }
1612:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 6682              		.loc 1 1612 0
 6683 025e 194B     		ldr	r3, .L524
 6684 0260 9B79     		ldrb	r3, [r3, #6]
 6685 0262 DBB2     		uxtb	r3, r3
 6686 0264 1A1C     		mov	r2, r3
 6687 0266 0223     		mov	r3, #2
 6688 0268 1340     		and	r3, r2
 6689 026a 01D1     		bne	.L512
 6690              		.loc 1 1612 0 is_stmt 0
 6691 026c 2323     		mov	r3, #35
 6692 026e 24E0     		b	.L494
 6693              	.L512:
1613:../Sources/system/CrystalClock.c ****   }
1614:../Sources/system/CrystalClock.c **** 
1615:../Sources/system/CrystalClock.c **** // wait for Reference clock Status bit to clear
1616:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6694              		.loc 1 1616 0 is_stmt 1
 6695 0270 0023     		mov	r3, #0
 6696 0272 FB60     		str	r3, [r7, #12]
 6697 0274 09E0     		b	.L517
 6698              	.L520:
1617:../Sources/system/CrystalClock.c ****   {
1618:../Sources/system/CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 6699              		.loc 1 1618 0
 6700 0276 134B     		ldr	r3, .L524
 6701 0278 9B79     		ldrb	r3, [r3, #6]
 6702 027a DBB2     		uxtb	r3, r3
 6703 027c 1A1C     		mov	r2, r3
 6704 027e 1023     		mov	r3, #16
 6705 0280 1340     		and	r3, r2
 6706 0282 07D0     		beq	.L523
 6707              	.L518:
1616:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6708              		.loc 1 1616 0
 6709 0284 FB68     		ldr	r3, [r7, #12]
 6710 0286 0133     		add	r3, r3, #1
 6711 0288 FB60     		str	r3, [r7, #12]
 6712              	.L517:
1616:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6713              		.loc 1 1616 0 is_stmt 0
 6714 028a FA68     		ldr	r2, [r7, #12]
 6715 028c 1A4B     		ldr	r3, .L524+52
 6716 028e 9A42     		cmp	r2, r3
 6717 0290 F1DD     		ble	.L520
 6718 0292 00E0     		b	.L519
 6719              	.L523:
 6720              		.loc 1 1618 0 is_stmt 1
 6721 0294 C046     		mov	r8, r8
 6722              	.L519:
1619:../Sources/system/CrystalClock.c ****   }
1620:../Sources/system/CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 6723              		.loc 1 1620 0
 6724 0296 0B4B     		ldr	r3, .L524
 6725 0298 9B79     		ldrb	r3, [r3, #6]
 6726 029a DBB2     		uxtb	r3, r3
 6727 029c 1A1C     		mov	r2, r3
 6728 029e 1023     		mov	r3, #16
 6729 02a0 1340     		and	r3, r2
 6730 02a2 01D0     		beq	.L521
 6731              		.loc 1 1620 0 is_stmt 0
 6732 02a4 1123     		mov	r3, #17
 6733 02a6 08E0     		b	.L494
 6734              	.L521:
1621:../Sources/system/CrystalClock.c ****   
1622:../Sources/system/CrystalClock.c **** // Now in FBE  
1623:../Sources/system/CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1624:../Sources/system/CrystalClock.c **** // It is enabled here but can be removed if this is not required.
1625:../Sources/system/CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 6735              		.loc 1 1625 0 is_stmt 1
 6736 02a8 064B     		ldr	r3, .L524
 6737 02aa 064A     		ldr	r2, .L524
 6738 02ac 5279     		ldrb	r2, [r2, #5]
 6739 02ae D2B2     		uxtb	r2, r2
 6740 02b0 2021     		mov	r1, #32
 6741 02b2 0A43     		orr	r2, r1
 6742 02b4 D2B2     		uxtb	r2, r2
 6743 02b6 5A71     		strb	r2, [r3, #5]
1626:../Sources/system/CrystalClock.c ****   
1627:../Sources/system/CrystalClock.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 6744              		.loc 1 1627 0
 6745 02b8 BB68     		ldr	r3, [r7, #8]
 6746              	.L494:
1628:../Sources/system/CrystalClock.c **** } // fei_fee
 6747              		.loc 1 1628 0
 6748 02ba 181C     		mov	r0, r3
 6749 02bc BD46     		mov	sp, r7
 6750 02be 06B0     		add	sp, sp, #24
 6751              		@ sp needed for prologue
 6752 02c0 80BD     		pop	{r7, pc}
 6753              	.L525:
 6754 02c2 C046     		.align	2
 6755              	.L524:
 6756 02c4 00400640 		.word	1074151424
 6757 02c8 80F0FA02 		.word	50000000
 6758 02cc 2F750000 		.word	29999
 6759 02d0 409C0000 		.word	40000
 6760 02d4 BFC62D00 		.word	2999999
 6761 02d8 0048E801 		.word	32000000
 6762 02dc 00127A00 		.word	8000000
 6763 02e0 D0121300 		.word	1250000
 6764 02e4 A0252600 		.word	2500000
 6765 02e8 404B4C00 		.word	5000000
 6766 02ec 80969800 		.word	10000000
 6767 02f0 002D3101 		.word	20000000
 6768 02f4 FF2C3101 		.word	19999999
 6769 02f8 CF070000 		.word	1999
 6770              		.cfi_endproc
 6771              	.LFE22:
 6773              		.section	.text.fee_fei,"ax",%progbits
 6774              		.align	2
 6775              		.global	fee_fei
 6776              		.code	16
 6777              		.thumb_func
 6779              	fee_fei:
 6780              	.LFB23:
1629:../Sources/system/CrystalClock.c **** 
1630:../Sources/system/CrystalClock.c **** 
1631:../Sources/system/CrystalClock.c **** int fee_fei(int slow_irc_freq)
1632:../Sources/system/CrystalClock.c **** {
 6781              		.loc 1 1632 0
 6782              		.cfi_startproc
 6783 0000 80B5     		push	{r7, lr}
 6784              	.LCFI69:
 6785              		.cfi_def_cfa_offset 8
 6786              		.cfi_offset 7, -8
 6787              		.cfi_offset 14, -4
 6788 0002 84B0     		sub	sp, sp, #16
 6789              	.LCFI70:
 6790              		.cfi_def_cfa_offset 24
 6791 0004 00AF     		add	r7, sp, #0
 6792              	.LCFI71:
 6793              		.cfi_def_cfa_register 7
 6794 0006 7860     		str	r0, [r7, #4]
1633:../Sources/system/CrystalClock.c ****   short i;
1634:../Sources/system/CrystalClock.c ****   int mcg_out;
1635:../Sources/system/CrystalClock.c **** 
1636:../Sources/system/CrystalClock.c **** // Check MCG is in FEE mode
1637:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6795              		.loc 1 1637 0
 6796 0008 334B     		ldr	r3, .L539
 6797 000a 9B79     		ldrb	r3, [r3, #6]
 6798 000c DBB2     		uxtb	r3, r3
 6799 000e 1A1C     		mov	r2, r3
 6800 0010 0C23     		mov	r3, #12
 6801 0012 1340     		and	r3, r2
 6802 0014 9B08     		lsr	r3, r3, #2
 6803 0016 0DD1     		bne	.L527
1638:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 6804              		.loc 1 1638 0
 6805 0018 2F4B     		ldr	r3, .L539
 6806 001a 9B79     		ldrb	r3, [r3, #6]
 6807 001c DBB2     		uxtb	r3, r3
 6808 001e 1A1C     		mov	r2, r3
 6809 0020 1023     		mov	r3, #16
 6810 0022 1340     		and	r3, r2
1637:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6811              		.loc 1 1637 0
 6812 0024 06D1     		bne	.L527
1639:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 6813              		.loc 1 1639 0
 6814 0026 2C4B     		ldr	r3, .L539
 6815 0028 9B79     		ldrb	r3, [r3, #6]
 6816 002a DBB2     		uxtb	r3, r3
 6817 002c 1A1C     		mov	r2, r3
 6818 002e 2023     		mov	r3, #32
 6819 0030 1340     		and	r3, r2
1637:../Sources/system/CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6820              		.loc 1 1637 0
 6821 0032 01D0     		beq	.L528
 6822              	.L527:
1640:../Sources/system/CrystalClock.c ****   {
1641:../Sources/system/CrystalClock.c ****     return 0x2;                                                     // return error code
 6823              		.loc 1 1641 0
 6824 0034 0223     		mov	r3, #2
 6825 0036 4AE0     		b	.L529
 6826              	.L528:
1642:../Sources/system/CrystalClock.c ****   } 
1643:../Sources/system/CrystalClock.c ****       
1644:../Sources/system/CrystalClock.c **** // Check IRC frequency is within spec.
1645:../Sources/system/CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 6827              		.loc 1 1645 0
 6828 0038 7A68     		ldr	r2, [r7, #4]
 6829 003a 284B     		ldr	r3, .L539+4
 6830 003c 9A42     		cmp	r2, r3
 6831 003e 03DD     		ble	.L530
 6832              		.loc 1 1645 0 is_stmt 0
 6833 0040 7A68     		ldr	r2, [r7, #4]
 6834 0042 274B     		ldr	r3, .L539+8
 6835 0044 9A42     		cmp	r2, r3
 6836 0046 01DD     		ble	.L531
 6837              	.L530:
1646:../Sources/system/CrystalClock.c ****   {
1647:../Sources/system/CrystalClock.c ****     return 0x31;
 6838              		.loc 1 1647 0 is_stmt 1
 6839 0048 3123     		mov	r3, #49
 6840 004a 40E0     		b	.L529
 6841              	.L531:
1648:../Sources/system/CrystalClock.c ****   }
1649:../Sources/system/CrystalClock.c **** 
1650:../Sources/system/CrystalClock.c ****   // Check resulting FLL frequency 
1651:../Sources/system/CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
 6842              		.loc 1 1651 0
 6843 004c 7B68     		ldr	r3, [r7, #4]
 6844 004e 181C     		mov	r0, r3
 6845 0050 FFF7FEFF 		bl	fll_freq
 6846 0054 031C     		mov	r3, r0
 6847 0056 BB60     		str	r3, [r7, #8]
1652:../Sources/system/CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 6848              		.loc 1 1652 0
 6849 0058 BB68     		ldr	r3, [r7, #8]
 6850 005a 3B2B     		cmp	r3, #59
 6851 005c 01DC     		bgt	.L532
 6852              		.loc 1 1652 0 is_stmt 0
 6853 005e BB68     		ldr	r3, [r7, #8]
 6854 0060 35E0     		b	.L529
 6855              	.L532:
1653:../Sources/system/CrystalClock.c ****   
1654:../Sources/system/CrystalClock.c **** // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
1655:../Sources/system/CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 6856              		.loc 1 1655 0 is_stmt 1
 6857 0062 1D4B     		ldr	r3, .L539
 6858 0064 1C4A     		ldr	r2, .L539
 6859 0066 5279     		ldrb	r2, [r2, #5]
 6860 0068 D2B2     		uxtb	r2, r2
 6861 006a 2021     		mov	r1, #32
 6862 006c 8A43     		bic	r2, r1
 6863 006e D2B2     		uxtb	r2, r2
 6864 0070 5A71     		strb	r2, [r3, #5]
1656:../Sources/system/CrystalClock.c **** 
1657:../Sources/system/CrystalClock.c **** // Change FLL reference clock from external to internal by setting IREFS bit
1658:../Sources/system/CrystalClock.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 6865              		.loc 1 1658 0
 6866 0072 194B     		ldr	r3, .L539
 6867 0074 184A     		ldr	r2, .L539
 6868 0076 1278     		ldrb	r2, [r2]
 6869 0078 D2B2     		uxtb	r2, r2
 6870 007a 0421     		mov	r1, #4
 6871 007c 0A43     		orr	r2, r1
 6872 007e D2B2     		uxtb	r2, r2
 6873 0080 1A70     		strb	r2, [r3]
1659:../Sources/system/CrystalClock.c ****   
1660:../Sources/system/CrystalClock.c **** // wait for Reference clock to switch to internal reference 
1661:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6874              		.loc 1 1661 0
 6875 0082 3B1C     		mov	r3, r7
 6876 0084 0E33     		add	r3, r3, #14
 6877 0086 0022     		mov	r2, #0
 6878 0088 1A80     		strh	r2, [r3]
 6879 008a 0DE0     		b	.L533
 6880              	.L536:
1662:../Sources/system/CrystalClock.c ****   {
1663:../Sources/system/CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 6881              		.loc 1 1663 0
 6882 008c 124B     		ldr	r3, .L539
 6883 008e 9B79     		ldrb	r3, [r3, #6]
 6884 0090 DBB2     		uxtb	r3, r3
 6885 0092 1A1C     		mov	r2, r3
 6886 0094 1023     		mov	r3, #16
 6887 0096 1340     		and	r3, r2
 6888 0098 0ED1     		bne	.L538
 6889              	.L534:
1661:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6890              		.loc 1 1661 0
 6891 009a 3B1C     		mov	r3, r7
 6892 009c 0E33     		add	r3, r3, #14
 6893 009e 3A1C     		mov	r2, r7
 6894 00a0 0E32     		add	r2, r2, #14
 6895 00a2 1288     		ldrh	r2, [r2]
 6896 00a4 0132     		add	r2, r2, #1
 6897 00a6 1A80     		strh	r2, [r3]
 6898              	.L533:
1661:../Sources/system/CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 6899              		.loc 1 1661 0 is_stmt 0
 6900 00a8 3B1C     		mov	r3, r7
 6901 00aa 0E33     		add	r3, r3, #14
 6902 00ac 0021     		mov	r1, #0
 6903 00ae 5A5E     		ldrsh	r2, [r3, r1]
 6904 00b0 0C4B     		ldr	r3, .L539+12
 6905 00b2 9A42     		cmp	r2, r3
 6906 00b4 EADD     		ble	.L536
 6907 00b6 00E0     		b	.L535
 6908              	.L538:
 6909              		.loc 1 1663 0 is_stmt 1
 6910 00b8 C046     		mov	r8, r8
 6911              	.L535:
1664:../Sources/system/CrystalClock.c ****   }
1665:../Sources/system/CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 6912              		.loc 1 1665 0
 6913 00ba 074B     		ldr	r3, .L539
 6914 00bc 9B79     		ldrb	r3, [r3, #6]
 6915 00be DBB2     		uxtb	r3, r3
 6916 00c0 1A1C     		mov	r2, r3
 6917 00c2 1023     		mov	r3, #16
 6918 00c4 1340     		and	r3, r2
 6919 00c6 01D1     		bne	.L537
 6920              		.loc 1 1665 0 is_stmt 0
 6921 00c8 1223     		mov	r3, #18
 6922 00ca 00E0     		b	.L529
 6923              	.L537:
1666:../Sources/system/CrystalClock.c ****   
1667:../Sources/system/CrystalClock.c **** // Now in FEI mode  
1668:../Sources/system/CrystalClock.c ****   return mcg_out;  
 6924              		.loc 1 1668 0 is_stmt 1
 6925 00cc BB68     		ldr	r3, [r7, #8]
 6926              	.L529:
1669:../Sources/system/CrystalClock.c **** } // fee_fei
 6927              		.loc 1 1669 0
 6928 00ce 181C     		mov	r0, r3
 6929 00d0 BD46     		mov	sp, r7
 6930 00d2 04B0     		add	sp, sp, #16
 6931              		@ sp needed for prologue
 6932 00d4 80BD     		pop	{r7, pc}
 6933              	.L540:
 6934 00d6 C046     		.align	2
 6935              	.L539:
 6936 00d8 00400640 		.word	1074151424
 6937 00dc 117A0000 		.word	31249
 6938 00e0 97980000 		.word	39063
 6939 00e4 CF070000 		.word	1999
 6940              		.cfi_endproc
 6941              	.LFE23:
 6943              		.global	__aeabi_uidiv
 6944              		.global	__aeabi_i2f
 6945              		.global	__aeabi_fdiv
 6946              		.global	__aeabi_fmul
 6947              		.global	__aeabi_f2uiz
 6948              		.section	.text.atc,"ax",%progbits
 6949              		.align	2
 6950              		.global	atc
 6951              		.code	16
 6952              		.thumb_func
 6954              	atc:
 6955              	.LFB24:
1670:../Sources/system/CrystalClock.c **** 
1671:../Sources/system/CrystalClock.c **** 
1672:../Sources/system/CrystalClock.c **** 
1673:../Sources/system/CrystalClock.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
1674:../Sources/system/CrystalClock.c **** {
 6956              		.loc 1 1674 0
 6957              		.cfi_startproc
 6958 0000 90B5     		push	{r4, r7, lr}
 6959              	.LCFI72:
 6960              		.cfi_def_cfa_offset 12
 6961              		.cfi_offset 4, -12
 6962              		.cfi_offset 7, -8
 6963              		.cfi_offset 14, -4
 6964 0002 8BB0     		sub	sp, sp, #44
 6965              	.LCFI73:
 6966              		.cfi_def_cfa_offset 56
 6967 0004 00AF     		add	r7, sp, #0
 6968              	.LCFI74:
 6969              		.cfi_def_cfa_register 7
 6970 0006 B960     		str	r1, [r7, #8]
 6971 0008 7A60     		str	r2, [r7, #4]
 6972 000a 3B1C     		mov	r3, r7
 6973 000c 0F33     		add	r3, r3, #15
 6974 000e 021C     		add	r2, r0, #0
 6975 0010 1A70     		strb	r2, [r3]
1675:../Sources/system/CrystalClock.c ****   unsigned char mcg_mode;
1676:../Sources/system/CrystalClock.c ****   unsigned short atcv;
1677:../Sources/system/CrystalClock.c ****   int bus_clock_freq;
1678:../Sources/system/CrystalClock.c ****   int  bus_clk_div_val;
1679:../Sources/system/CrystalClock.c ****   int orig_div;
1680:../Sources/system/CrystalClock.c ****   int temp_reg;
1681:../Sources/system/CrystalClock.c ****   
1682:../Sources/system/CrystalClock.c ****   if (irc_select > 0) // force irc to 1 if greater than 0
 6976              		.loc 1 1682 0
 6977 0012 3B1C     		mov	r3, r7
 6978 0014 0F33     		add	r3, r3, #15
 6979 0016 1B78     		ldrb	r3, [r3]
 6980 0018 002B     		cmp	r3, #0
 6981 001a 03D0     		beq	.L542
1683:../Sources/system/CrystalClock.c ****   {
1684:../Sources/system/CrystalClock.c ****     irc_select = 1;
 6982              		.loc 1 1684 0
 6983 001c 3B1C     		mov	r3, r7
 6984 001e 0F33     		add	r3, r3, #15
 6985 0020 0122     		mov	r2, #1
 6986 0022 1A70     		strb	r2, [r3]
 6987              	.L542:
1685:../Sources/system/CrystalClock.c ****   }
1686:../Sources/system/CrystalClock.c ****   
1687:../Sources/system/CrystalClock.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
 6988              		.loc 1 1687 0
 6989 0024 3C1C     		mov	r4, r7
 6990 0026 2534     		add	r4, r4, #37
 6991 0028 FFF7FEFF 		bl	what_mcg_mode
 6992 002c 031C     		mov	r3, r0
 6993 002e 2370     		strb	r3, [r4]
1688:../Sources/system/CrystalClock.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 6994              		.loc 1 1688 0
 6995 0030 3B1C     		mov	r3, r7
 6996 0032 2533     		add	r3, r3, #37
 6997 0034 1B78     		ldrb	r3, [r3]
 6998 0036 082B     		cmp	r3, #8
 6999 0038 0BD0     		beq	.L543
 7000              		.loc 1 1688 0 is_stmt 0
 7001 003a 3B1C     		mov	r3, r7
 7002 003c 2533     		add	r3, r3, #37
 7003 003e 1B78     		ldrb	r3, [r3]
 7004 0040 072B     		cmp	r3, #7
 7005 0042 06D0     		beq	.L543
 7006 0044 3B1C     		mov	r3, r7
 7007 0046 2533     		add	r3, r3, #37
 7008 0048 1B78     		ldrb	r3, [r3]
 7009 004a 052B     		cmp	r3, #5
 7010 004c 01D0     		beq	.L543
1689:../Sources/system/CrystalClock.c ****   {
1690:../Sources/system/CrystalClock.c ****     return 1; // return error code if not in PEE, PBE or FBE modes
 7011              		.loc 1 1690 0 is_stmt 1
 7012 004e 0123     		mov	r3, #1
 7013 0050 11E1     		b	.L544
 7014              	.L543:
1691:../Sources/system/CrystalClock.c ****   }
1692:../Sources/system/CrystalClock.c ****   
1693:../Sources/system/CrystalClock.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 7015              		.loc 1 1693 0
 7016 0052 8B4A     		ldr	r2, .L559
 7017 0054 8B4B     		ldr	r3, .L559+4
 7018 0056 D358     		ldr	r3, [r2, r3]
 7019 0058 3B62     		str	r3, [r7, #32]
1694:../Sources/system/CrystalClock.c ****   
1695:../Sources/system/CrystalClock.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 7020              		.loc 1 1695 0
 7021 005a 7B68     		ldr	r3, [r7, #4]
 7022 005c 181C     		mov	r0, r3
 7023 005e 8A49     		ldr	r1, .L559+8
 7024 0060 FFF7FEFF 		bl	__aeabi_idiv
 7025 0064 031C     		mov	r3, r0
 7026 0066 FB61     		str	r3, [r7, #28]
1696:../Sources/system/CrystalClock.c ****   temp_reg = SIM_CLKDIV1;
 7027              		.loc 1 1696 0
 7028 0068 854A     		ldr	r2, .L559
 7029 006a 864B     		ldr	r3, .L559+4
 7030 006c D358     		ldr	r3, [r2, r3]
 7031 006e BB61     		str	r3, [r7, #24]
1697:../Sources/system/CrystalClock.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
 7032              		.loc 1 1697 0
 7033 0070 BA69     		ldr	r2, [r7, #24]
 7034 0072 864B     		ldr	r3, .L559+12
 7035 0074 1340     		and	r3, r2
 7036 0076 BB61     		str	r3, [r7, #24]
1698:../Sources/system/CrystalClock.c ****   // set all bus and flash dividers to same value to ensure clocking restrictions are met
1699:../Sources/system/CrystalClock.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 7037              		.loc 1 1699 0
 7038 0078 FB69     		ldr	r3, [r7, #28]
 7039 007a 1A04     		lsl	r2, r3, #16
 7040 007c E023     		mov	r3, #224
 7041 007e DB02     		lsl	r3, r3, #11
 7042 0080 1A40     		and	r2, r3
 7043 0082 BB69     		ldr	r3, [r7, #24]
 7044 0084 1343     		orr	r3, r2
 7045 0086 BB61     		str	r3, [r7, #24]
1700:../Sources/system/CrystalClock.c ****   SIM_CLKDIV1 = temp_reg; // set actual dividers
 7046              		.loc 1 1700 0
 7047 0088 7D4A     		ldr	r2, .L559
 7048 008a B969     		ldr	r1, [r7, #24]
 7049 008c 7D4B     		ldr	r3, .L559+4
 7050 008e D150     		str	r1, [r2, r3]
1701:../Sources/system/CrystalClock.c ****   
1702:../Sources/system/CrystalClock.c ****   bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same
 7051              		.loc 1 1702 0
 7052 0090 7A68     		ldr	r2, [r7, #4]
 7053 0092 7B49     		ldr	r1, .L559
 7054 0094 7B4B     		ldr	r3, .L559+4
 7055 0096 CB58     		ldr	r3, [r1, r3]
 7056 0098 1B0C     		lsr	r3, r3, #16
 7057 009a 0133     		add	r3, r3, #1
 7058 009c 101C     		mov	r0, r2
 7059 009e 191C     		mov	r1, r3
 7060 00a0 FFF7FEFF 		bl	__aeabi_uidiv
 7061 00a4 031C     		mov	r3, r0
 7062 00a6 7B61     		str	r3, [r7, #20]
1703:../Sources/system/CrystalClock.c ****   if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
 7063              		.loc 1 1703 0
 7064 00a8 7A69     		ldr	r2, [r7, #20]
 7065 00aa 794B     		ldr	r3, .L559+16
 7066 00ac 9A42     		cmp	r2, r3
 7067 00ae 03DD     		ble	.L545
 7068              		.loc 1 1703 0 is_stmt 0
 7069 00b0 7A69     		ldr	r2, [r7, #20]
 7070 00b2 754B     		ldr	r3, .L559+8
 7071 00b4 9A42     		cmp	r2, r3
 7072 00b6 05DD     		ble	.L546
 7073              	.L545:
1704:../Sources/system/CrystalClock.c ****   {
1705:../Sources/system/CrystalClock.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7074              		.loc 1 1705 0 is_stmt 1
 7075 00b8 714A     		ldr	r2, .L559
 7076 00ba 396A     		ldr	r1, [r7, #32]
 7077 00bc 714B     		ldr	r3, .L559+4
 7078 00be D150     		str	r1, [r2, r3]
1706:../Sources/system/CrystalClock.c ****     return 3; // error, bus clock frequency is not within 8MHz to 16MHz
 7079              		.loc 1 1706 0
 7080 00c0 0323     		mov	r3, #3
 7081 00c2 D8E0     		b	.L544
 7082              	.L546:
1707:../Sources/system/CrystalClock.c ****   }
1708:../Sources/system/CrystalClock.c ****                 
1709:../Sources/system/CrystalClock.c ****   if(!irc_select) //determine if slow or fast IRC to be trimmed
 7083              		.loc 1 1709 0
 7084 00c4 3B1C     		mov	r3, r7
 7085 00c6 0F33     		add	r3, r3, #15
 7086 00c8 1B78     		ldrb	r3, [r3]
 7087 00ca 002B     		cmp	r3, #0
 7088 00cc 13D1     		bne	.L547
1710:../Sources/system/CrystalClock.c ****   {
1711:../Sources/system/CrystalClock.c ****     if (irc_freq < 31250) // check frequency is above min spec.
 7089              		.loc 1 1711 0
 7090 00ce BA68     		ldr	r2, [r7, #8]
 7091 00d0 704B     		ldr	r3, .L559+20
 7092 00d2 9A42     		cmp	r2, r3
 7093 00d4 05DC     		bgt	.L548
1712:../Sources/system/CrystalClock.c ****     {
1713:../Sources/system/CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7094              		.loc 1 1713 0
 7095 00d6 6A4A     		ldr	r2, .L559
 7096 00d8 396A     		ldr	r1, [r7, #32]
 7097 00da 6A4B     		ldr	r3, .L559+4
 7098 00dc D150     		str	r1, [r2, r3]
1714:../Sources/system/CrystalClock.c ****       return 4;
 7099              		.loc 1 1714 0
 7100 00de 0423     		mov	r3, #4
 7101 00e0 C9E0     		b	.L544
 7102              	.L548:
1715:../Sources/system/CrystalClock.c ****     }
1716:../Sources/system/CrystalClock.c ****     if (irc_freq > 39062) // check frequency is below max spec.
 7103              		.loc 1 1716 0
 7104 00e2 BA68     		ldr	r2, [r7, #8]
 7105 00e4 6C4B     		ldr	r3, .L559+24
 7106 00e6 9A42     		cmp	r2, r3
 7107 00e8 19DD     		ble	.L549
1717:../Sources/system/CrystalClock.c ****     {
1718:../Sources/system/CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7108              		.loc 1 1718 0
 7109 00ea 654A     		ldr	r2, .L559
 7110 00ec 396A     		ldr	r1, [r7, #32]
 7111 00ee 654B     		ldr	r3, .L559+4
 7112 00f0 D150     		str	r1, [r2, r3]
1719:../Sources/system/CrystalClock.c ****       return 5;
 7113              		.loc 1 1719 0
 7114 00f2 0523     		mov	r3, #5
 7115 00f4 BFE0     		b	.L544
 7116              	.L547:
1720:../Sources/system/CrystalClock.c ****     }         
1721:../Sources/system/CrystalClock.c ****   }
1722:../Sources/system/CrystalClock.c ****   else
1723:../Sources/system/CrystalClock.c ****   {
1724:../Sources/system/CrystalClock.c ****     if (irc_freq < 3000000) // check frequency is above min spec.
 7117              		.loc 1 1724 0
 7118 00f6 BA68     		ldr	r2, [r7, #8]
 7119 00f8 684B     		ldr	r3, .L559+28
 7120 00fa 9A42     		cmp	r2, r3
 7121 00fc 05DC     		bgt	.L550
1725:../Sources/system/CrystalClock.c ****     {
1726:../Sources/system/CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7122              		.loc 1 1726 0
 7123 00fe 604A     		ldr	r2, .L559
 7124 0100 396A     		ldr	r1, [r7, #32]
 7125 0102 604B     		ldr	r3, .L559+4
 7126 0104 D150     		str	r1, [r2, r3]
1727:../Sources/system/CrystalClock.c ****       return 6;
 7127              		.loc 1 1727 0
 7128 0106 0623     		mov	r3, #6
 7129 0108 B5E0     		b	.L544
 7130              	.L550:
1728:../Sources/system/CrystalClock.c ****     }
1729:../Sources/system/CrystalClock.c ****     if (irc_freq > 5000000) // check frequency is below max spec.
 7131              		.loc 1 1729 0
 7132 010a BA68     		ldr	r2, [r7, #8]
 7133 010c 644B     		ldr	r3, .L559+32
 7134 010e 9A42     		cmp	r2, r3
 7135 0110 05DD     		ble	.L549
1730:../Sources/system/CrystalClock.c ****     {
1731:../Sources/system/CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7136              		.loc 1 1731 0
 7137 0112 5B4A     		ldr	r2, .L559
 7138 0114 396A     		ldr	r1, [r7, #32]
 7139 0116 5B4B     		ldr	r3, .L559+4
 7140 0118 D150     		str	r1, [r2, r3]
1732:../Sources/system/CrystalClock.c ****       return 7;
 7141              		.loc 1 1732 0
 7142 011a 0723     		mov	r3, #7
 7143 011c ABE0     		b	.L544
 7144              	.L549:
1733:../Sources/system/CrystalClock.c ****     }            
1734:../Sources/system/CrystalClock.c ****   } // if
1735:../Sources/system/CrystalClock.c ****         
1736:../Sources/system/CrystalClock.c **** // Set up autocal registers, must use floating point calculation
1737:../Sources/system/CrystalClock.c ****   if (irc_select) 
 7145              		.loc 1 1737 0
 7146 011e 3B1C     		mov	r3, r7
 7147 0120 0F33     		add	r3, r3, #15
 7148 0122 1B78     		ldrb	r3, [r3]
 7149 0124 002B     		cmp	r3, #0
 7150 0126 1FD0     		beq	.L551
1738:../Sources/system/CrystalClock.c ****     atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
 7151              		.loc 1 1738 0
 7152 0128 7869     		ldr	r0, [r7, #20]
 7153 012a FFF7FEFF 		bl	__aeabi_i2f
 7154 012e 041C     		add	r4, r0, #0
 7155 0130 B868     		ldr	r0, [r7, #8]
 7156 0132 FFF7FEFF 		bl	__aeabi_i2f
 7157 0136 031C     		add	r3, r0, #0
 7158 0138 201C     		add	r0, r4, #0
 7159 013a 191C     		add	r1, r3, #0
 7160 013c FFF7FEFF 		bl	__aeabi_fdiv
 7161 0140 031C     		add	r3, r0, #0
 7162 0142 181C     		add	r0, r3, #0
 7163 0144 5749     		ldr	r1, .L559+36
 7164 0146 FFF7FEFF 		bl	__aeabi_fmul
 7165 014a 031C     		add	r3, r0, #0
 7166 014c 181C     		add	r0, r3, #0
 7167 014e 8621     		mov	r1, #134
 7168 0150 C905     		lsl	r1, r1, #23
 7169 0152 FFF7FEFF 		bl	__aeabi_fmul
 7170 0156 031C     		add	r3, r0, #0
 7171 0158 3C1C     		mov	r4, r7
 7172 015a 2634     		add	r4, r4, #38
 7173 015c 181C     		add	r0, r3, #0
 7174 015e FFF7FEFF 		bl	__aeabi_f2uiz
 7175 0162 031C     		mov	r3, r0
 7176 0164 2380     		strh	r3, [r4]
 7177 0166 18E0     		b	.L552
 7178              	.L551:
1739:../Sources/system/CrystalClock.c ****   else
1740:../Sources/system/CrystalClock.c ****     atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
 7179              		.loc 1 1740 0
 7180 0168 7869     		ldr	r0, [r7, #20]
 7181 016a FFF7FEFF 		bl	__aeabi_i2f
 7182 016e 041C     		add	r4, r0, #0
 7183 0170 B868     		ldr	r0, [r7, #8]
 7184 0172 FFF7FEFF 		bl	__aeabi_i2f
 7185 0176 031C     		add	r3, r0, #0
 7186 0178 201C     		add	r0, r4, #0
 7187 017a 191C     		add	r1, r3, #0
 7188 017c FFF7FEFF 		bl	__aeabi_fdiv
 7189 0180 031C     		add	r3, r0, #0
 7190 0182 181C     		add	r0, r3, #0
 7191 0184 4749     		ldr	r1, .L559+36
 7192 0186 FFF7FEFF 		bl	__aeabi_fmul
 7193 018a 031C     		add	r3, r0, #0
 7194 018c 3C1C     		mov	r4, r7
 7195 018e 2634     		add	r4, r4, #38
 7196 0190 181C     		add	r0, r3, #0
 7197 0192 FFF7FEFF 		bl	__aeabi_f2uiz
 7198 0196 031C     		mov	r3, r0
 7199 0198 2380     		strh	r3, [r4]
 7200              	.L552:
1741:../Sources/system/CrystalClock.c ****         
1742:../Sources/system/CrystalClock.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
 7201              		.loc 1 1742 0
 7202 019a 434B     		ldr	r3, .L559+40
 7203 019c 3A1C     		mov	r2, r7
 7204 019e 2632     		add	r2, r2, #38
 7205 01a0 1288     		ldrh	r2, [r2]
 7206 01a2 D2B2     		uxtb	r2, r2
 7207 01a4 DA72     		strb	r2, [r3, #11]
1743:../Sources/system/CrystalClock.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 7208              		.loc 1 1743 0
 7209 01a6 404B     		ldr	r3, .L559+40
 7210 01a8 3A1C     		mov	r2, r7
 7211 01aa 2632     		add	r2, r2, #38
 7212 01ac 1288     		ldrh	r2, [r2]
 7213 01ae 120A     		lsr	r2, r2, #8
 7214 01b0 92B2     		uxth	r2, r2
 7215 01b2 D2B2     		uxtb	r2, r2
 7216 01b4 9A72     		strb	r2, [r3, #10]
1744:../Sources/system/CrystalClock.c **** 
1745:../Sources/system/CrystalClock.c **** // Enable autocal
1746:../Sources/system/CrystalClock.c ****   MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
 7217              		.loc 1 1746 0
 7218 01b6 3C4B     		ldr	r3, .L559+40
 7219 01b8 3B4A     		ldr	r2, .L559+40
 7220 01ba 127A     		ldrb	r2, [r2, #8]
 7221 01bc D1B2     		uxtb	r1, r2
 7222 01be 1F22     		mov	r2, #31
 7223 01c0 0A40     		and	r2, r1
 7224 01c2 D2B2     		uxtb	r2, r2
 7225 01c4 1A72     		strb	r2, [r3, #8]
1747:../Sources/system/CrystalClock.c ****   temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enabl
 7226              		.loc 1 1747 0
 7227 01c6 3B1C     		mov	r3, r7
 7228 01c8 0F33     		add	r3, r3, #15
 7229 01ca 1B78     		ldrb	r3, [r3]
 7230 01cc 9B01     		lsl	r3, r3, #6
 7231 01ce 8022     		mov	r2, #128
 7232 01d0 1343     		orr	r3, r2
 7233 01d2 BB61     		str	r3, [r7, #24]
1748:../Sources/system/CrystalClock.c ****   MCG_SC |= temp_reg;
 7234              		.loc 1 1748 0
 7235 01d4 344B     		ldr	r3, .L559+40
 7236 01d6 344A     		ldr	r2, .L559+40
 7237 01d8 127A     		ldrb	r2, [r2, #8]
 7238 01da D2B2     		uxtb	r2, r2
 7239 01dc D1B2     		uxtb	r1, r2
 7240 01de BA69     		ldr	r2, [r7, #24]
 7241 01e0 D2B2     		uxtb	r2, r2
 7242 01e2 0A43     		orr	r2, r1
 7243 01e4 D2B2     		uxtb	r2, r2
 7244 01e6 D2B2     		uxtb	r2, r2
 7245 01e8 1A72     		strb	r2, [r3, #8]
1749:../Sources/system/CrystalClock.c ****         
1750:../Sources/system/CrystalClock.c ****   while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
 7246              		.loc 1 1750 0
 7247 01ea C046     		mov	r8, r8
 7248              	.L553:
 7249              		.loc 1 1750 0 is_stmt 0
 7250 01ec 2E4B     		ldr	r3, .L559+40
 7251 01ee 1B7A     		ldrb	r3, [r3, #8]
 7252 01f0 DBB2     		uxtb	r3, r3
 7253 01f2 DBB2     		uxtb	r3, r3
 7254 01f4 5BB2     		sxtb	r3, r3
 7255 01f6 002B     		cmp	r3, #0
 7256 01f8 F8DB     		blt	.L553
1751:../Sources/system/CrystalClock.c ****         
1752:../Sources/system/CrystalClock.c ****   if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
 7257              		.loc 1 1752 0 is_stmt 1
 7258 01fa 2B4B     		ldr	r3, .L559+40
 7259 01fc 1B7A     		ldrb	r3, [r3, #8]
 7260 01fe DBB2     		uxtb	r3, r3
 7261 0200 1A1C     		mov	r2, r3
 7262 0202 2023     		mov	r3, #32
 7263 0204 1340     		and	r3, r2
 7264 0206 05D0     		beq	.L554
1753:../Sources/system/CrystalClock.c ****   {
1754:../Sources/system/CrystalClock.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7265              		.loc 1 1754 0
 7266 0208 1D4A     		ldr	r2, .L559
 7267 020a 396A     		ldr	r1, [r7, #32]
 7268 020c 1D4B     		ldr	r3, .L559+4
 7269 020e D150     		str	r1, [r2, r3]
1755:../Sources/system/CrystalClock.c ****     return 8;
 7270              		.loc 1 1755 0
 7271 0210 0823     		mov	r3, #8
 7272 0212 30E0     		b	.L544
 7273              	.L554:
1756:../Sources/system/CrystalClock.c ****   } 
1757:../Sources/system/CrystalClock.c ****   else 
1758:../Sources/system/CrystalClock.c ****   {      
1759:../Sources/system/CrystalClock.c ****     if (!irc_select)
 7274              		.loc 1 1759 0
 7275 0214 3B1C     		mov	r3, r7
 7276 0216 0F33     		add	r3, r3, #15
 7277 0218 1B78     		ldrb	r3, [r3]
 7278 021a 002B     		cmp	r3, #0
 7279 021c 0FD1     		bne	.L555
1760:../Sources/system/CrystalClock.c ****     {
1761:../Sources/system/CrystalClock.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 7280              		.loc 1 1761 0
 7281 021e 224B     		ldr	r3, .L559+40
 7282 0220 9B78     		ldrb	r3, [r3, #2]
 7283 0222 DBB2     		uxtb	r3, r3
 7284 0224 FF2B     		cmp	r3, #255
 7285 0226 04D0     		beq	.L556
 7286              		.loc 1 1761 0 is_stmt 0
 7287 0228 1F4B     		ldr	r3, .L559+40
 7288 022a 9B78     		ldrb	r3, [r3, #2]
 7289 022c DBB2     		uxtb	r3, r3
 7290 022e 002B     		cmp	r3, #0
 7291 0230 1CD1     		bne	.L557
 7292              	.L556:
1762:../Sources/system/CrystalClock.c ****       {
1763:../Sources/system/CrystalClock.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7293              		.loc 1 1763 0 is_stmt 1
 7294 0232 134A     		ldr	r2, .L559
 7295 0234 396A     		ldr	r1, [r7, #32]
 7296 0236 134B     		ldr	r3, .L559+4
 7297 0238 D150     		str	r1, [r2, r3]
1764:../Sources/system/CrystalClock.c ****         return 9;
 7298              		.loc 1 1764 0
 7299 023a 0923     		mov	r3, #9
 7300 023c 1BE0     		b	.L544
 7301              	.L555:
1765:../Sources/system/CrystalClock.c ****       }
1766:../Sources/system/CrystalClock.c ****     }
1767:../Sources/system/CrystalClock.c ****     else
1768:../Sources/system/CrystalClock.c ****     {
1769:../Sources/system/CrystalClock.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 7302              		.loc 1 1769 0
 7303 023e 1A4B     		ldr	r3, .L559+40
 7304 0240 DB78     		ldrb	r3, [r3, #3]
 7305 0242 DBB2     		uxtb	r3, r3
 7306 0244 1A1C     		mov	r2, r3
 7307 0246 1E23     		mov	r3, #30
 7308 0248 1340     		and	r3, r2
 7309 024a 5B08     		lsr	r3, r3, #1
 7310 024c 0F2B     		cmp	r3, #15
 7311 024e 07D0     		beq	.L558
1770:../Sources/system/CrystalClock.c ****           (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
 7312              		.loc 1 1770 0
 7313 0250 154B     		ldr	r3, .L559+40
 7314 0252 DB78     		ldrb	r3, [r3, #3]
 7315 0254 DBB2     		uxtb	r3, r3
 7316 0256 1A1C     		mov	r2, r3
 7317 0258 1E23     		mov	r3, #30
 7318 025a 1340     		and	r3, r2
 7319 025c 5B08     		lsr	r3, r3, #1
1769:../Sources/system/CrystalClock.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 7320              		.loc 1 1769 0
 7321 025e 05D1     		bne	.L557
 7322              	.L558:
1771:../Sources/system/CrystalClock.c ****       {
1772:../Sources/system/CrystalClock.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7323              		.loc 1 1772 0
 7324 0260 074A     		ldr	r2, .L559
 7325 0262 396A     		ldr	r1, [r7, #32]
 7326 0264 074B     		ldr	r3, .L559+4
 7327 0266 D150     		str	r1, [r2, r3]
1773:../Sources/system/CrystalClock.c ****         return 10;
 7328              		.loc 1 1773 0
 7329 0268 0A23     		mov	r3, #10
 7330 026a 04E0     		b	.L544
 7331              	.L557:
1774:../Sources/system/CrystalClock.c ****       }
1775:../Sources/system/CrystalClock.c ****     }
1776:../Sources/system/CrystalClock.c ****   }
1777:../Sources/system/CrystalClock.c ****   SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7332              		.loc 1 1777 0
 7333 026c 044A     		ldr	r2, .L559
 7334 026e 396A     		ldr	r1, [r7, #32]
 7335 0270 044B     		ldr	r3, .L559+4
 7336 0272 D150     		str	r1, [r2, r3]
1778:../Sources/system/CrystalClock.c ****   return 0;
 7337              		.loc 1 1778 0
 7338 0274 0023     		mov	r3, #0
 7339              	.L544:
1779:../Sources/system/CrystalClock.c **** }// atc
 7340              		.loc 1 1779 0
 7341 0276 181C     		mov	r0, r3
 7342 0278 BD46     		mov	sp, r7
 7343 027a 0BB0     		add	sp, sp, #44
 7344              		@ sp needed for prologue
 7345 027c 90BD     		pop	{r4, r7, pc}
 7346              	.L560:
 7347 027e C046     		.align	2
 7348              	.L559:
 7349 0280 00700440 		.word	1074032640
 7350 0284 44100000 		.word	4164
 7351 0288 0024F400 		.word	16000000
 7352 028c FFFFF8FF 		.word	-458753
 7353 0290 FF117A00 		.word	7999999
 7354 0294 117A0000 		.word	31249
 7355 0298 96980000 		.word	39062
 7356 029c BFC62D00 		.word	2999999
 7357 02a0 404B4C00 		.word	5000000
 7358 02a4 0000A841 		.word	1101529088
 7359 02a8 00400640 		.word	1074151424
 7360              		.cfi_endproc
 7361              	.LFE24:
 7363              		.section	.text.fll_freq,"ax",%progbits
 7364              		.align	2
 7365              		.global	fll_freq
 7366              		.code	16
 7367              		.thumb_func
 7369              	fll_freq:
 7370              	.LFB25:
1780:../Sources/system/CrystalClock.c **** 
1781:../Sources/system/CrystalClock.c **** 
1782:../Sources/system/CrystalClock.c **** 
1783:../Sources/system/CrystalClock.c **** 
1784:../Sources/system/CrystalClock.c **** int fll_freq(int fll_ref)
1785:../Sources/system/CrystalClock.c **** {
 7371              		.loc 1 1785 0
 7372              		.cfi_startproc
 7373 0000 80B5     		push	{r7, lr}
 7374              	.LCFI75:
 7375              		.cfi_def_cfa_offset 8
 7376              		.cfi_offset 7, -8
 7377              		.cfi_offset 14, -4
 7378 0002 84B0     		sub	sp, sp, #16
 7379              	.LCFI76:
 7380              		.cfi_def_cfa_offset 24
 7381 0004 00AF     		add	r7, sp, #0
 7382              	.LCFI77:
 7383              		.cfi_def_cfa_register 7
 7384 0006 7860     		str	r0, [r7, #4]
1786:../Sources/system/CrystalClock.c ****   int fll_freq_hz;
1787:../Sources/system/CrystalClock.c ****   
1788:../Sources/system/CrystalClock.c ****   // Check that only allowed ranges have been selected
1789:../Sources/system/CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 7385              		.loc 1 1789 0
 7386 0008 684B     		ldr	r3, .L599
 7387 000a DB78     		ldrb	r3, [r3, #3]
 7388 000c DBB2     		uxtb	r3, r3
 7389 000e 1A1C     		mov	r2, r3
 7390 0010 6023     		mov	r3, #96
 7391 0012 1340     		and	r3, r2
 7392 0014 5B09     		lsr	r3, r3, #5
 7393 0016 012B     		cmp	r3, #1
 7394 0018 01D9     		bls	.L562
1790:../Sources/system/CrystalClock.c ****   {
1791:../Sources/system/CrystalClock.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 7395              		.loc 1 1791 0
 7396 001a 3B23     		mov	r3, #59
 7397 001c C2E0     		b	.L563
 7398              	.L562:
1792:../Sources/system/CrystalClock.c ****   }
1793:../Sources/system/CrystalClock.c ****   
1794:../Sources/system/CrystalClock.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
 7399              		.loc 1 1794 0
 7400 001e 634B     		ldr	r3, .L599
 7401 0020 DB78     		ldrb	r3, [r3, #3]
 7402 0022 DBB2     		uxtb	r3, r3
 7403 0024 DBB2     		uxtb	r3, r3
 7404 0026 5BB2     		sxtb	r3, r3
 7405 0028 002B     		cmp	r3, #0
 7406 002a 54DA     		bge	.L564
1795:../Sources/system/CrystalClock.c ****   {
1796:../Sources/system/CrystalClock.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 7407              		.loc 1 1796 0
 7408 002c 5F4B     		ldr	r3, .L599
 7409 002e DB78     		ldrb	r3, [r3, #3]
 7410 0030 DBB2     		uxtb	r3, r3
 7411 0032 1A1C     		mov	r2, r3
 7412 0034 6023     		mov	r3, #96
 7413 0036 1340     		and	r3, r2
 7414 0038 5B09     		lsr	r3, r3, #5
 7415 003a 012B     		cmp	r3, #1
 7416 003c 17D0     		beq	.L567
 7417 003e 04D3     		bcc	.L566
 7418 0040 022B     		cmp	r3, #2
 7419 0042 26D0     		beq	.L568
 7420 0044 032B     		cmp	r3, #3
 7421 0046 35D0     		beq	.L569
 7422 0048 ABE0     		b	.L578
 7423              	.L566:
1797:../Sources/system/CrystalClock.c ****     {
1798:../Sources/system/CrystalClock.c ****     case 0:
1799:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 732);
 7424              		.loc 1 1799 0
 7425 004a 7B68     		ldr	r3, [r7, #4]
 7426 004c B722     		mov	r2, #183
 7427 004e 9200     		lsl	r2, r2, #2
 7428 0050 5343     		mul	r3, r2
 7429 0052 FB60     		str	r3, [r7, #12]
1800:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 7430              		.loc 1 1800 0
 7431 0054 FA68     		ldr	r2, [r7, #12]
 7432 0056 564B     		ldr	r3, .L599+4
 7433 0058 9A42     		cmp	r2, r3
 7434 005a 01DC     		bgt	.L570
 7435              		.loc 1 1800 0 is_stmt 0
 7436 005c 3323     		mov	r3, #51
 7437 005e A1E0     		b	.L563
 7438              	.L570:
1801:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
 7439              		.loc 1 1801 0 is_stmt 1
 7440 0060 FA68     		ldr	r2, [r7, #12]
 7441 0062 544B     		ldr	r3, .L599+8
 7442 0064 9A42     		cmp	r2, r3
 7443 0066 00DC     		bgt	.LCB7169
 7444 0068 8CE0     		b	.L591	@long jump
 7445              	.LCB7169:
 7446              		.loc 1 1801 0 is_stmt 0
 7447 006a 3423     		mov	r3, #52
 7448 006c 9AE0     		b	.L563
 7449              	.L567:
1802:../Sources/system/CrystalClock.c ****       break;
1803:../Sources/system/CrystalClock.c ****     case 1:
1804:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 1464);
 7450              		.loc 1 1804 0 is_stmt 1
 7451 006e 7B68     		ldr	r3, [r7, #4]
 7452 0070 B722     		mov	r2, #183
 7453 0072 D200     		lsl	r2, r2, #3
 7454 0074 5343     		mul	r3, r2
 7455 0076 FB60     		str	r3, [r7, #12]
1805:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 7456              		.loc 1 1805 0
 7457 0078 FA68     		ldr	r2, [r7, #12]
 7458 007a 4F4B     		ldr	r3, .L599+12
 7459 007c 9A42     		cmp	r2, r3
 7460 007e 01DC     		bgt	.L572
 7461              		.loc 1 1805 0 is_stmt 0
 7462 0080 3523     		mov	r3, #53
 7463 0082 8FE0     		b	.L563
 7464              	.L572:
1806:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 7465              		.loc 1 1806 0 is_stmt 1
 7466 0084 FA68     		ldr	r2, [r7, #12]
 7467 0086 4D4B     		ldr	r3, .L599+16
 7468 0088 9A42     		cmp	r2, r3
 7469 008a 00DC     		bgt	.LCB7192
 7470 008c 7CE0     		b	.L592	@long jump
 7471              	.LCB7192:
 7472              		.loc 1 1806 0 is_stmt 0
 7473 008e 3623     		mov	r3, #54
 7474 0090 88E0     		b	.L563
 7475              	.L568:
1807:../Sources/system/CrystalClock.c ****       break;
1808:../Sources/system/CrystalClock.c ****     case 2:
1809:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 2197);
 7476              		.loc 1 1809 0 is_stmt 1
 7477 0092 7B68     		ldr	r3, [r7, #4]
 7478 0094 4A4A     		ldr	r2, .L599+20
 7479 0096 5343     		mul	r3, r2
 7480 0098 FB60     		str	r3, [r7, #12]
1810:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 7481              		.loc 1 1810 0
 7482 009a FA68     		ldr	r2, [r7, #12]
 7483 009c 494B     		ldr	r3, .L599+24
 7484 009e 9A42     		cmp	r2, r3
 7485 00a0 01DC     		bgt	.L574
 7486              		.loc 1 1810 0 is_stmt 0
 7487 00a2 3723     		mov	r3, #55
 7488 00a4 7EE0     		b	.L563
 7489              	.L574:
1811:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 7490              		.loc 1 1811 0 is_stmt 1
 7491 00a6 FA68     		ldr	r2, [r7, #12]
 7492 00a8 474B     		ldr	r3, .L599+28
 7493 00aa 9A42     		cmp	r2, r3
 7494 00ac 00DC     		bgt	.LCB7214
 7495 00ae 6DE0     		b	.L593	@long jump
 7496              	.LCB7214:
 7497              		.loc 1 1811 0 is_stmt 0
 7498 00b0 3823     		mov	r3, #56
 7499 00b2 77E0     		b	.L563
 7500              	.L569:
1812:../Sources/system/CrystalClock.c ****       break;
1813:../Sources/system/CrystalClock.c ****     case 3:
1814:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 2929);
 7501              		.loc 1 1814 0 is_stmt 1
 7502 00b4 7B68     		ldr	r3, [r7, #4]
 7503 00b6 454A     		ldr	r2, .L599+32
 7504 00b8 5343     		mul	r3, r2
 7505 00ba FB60     		str	r3, [r7, #12]
1815:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 7506              		.loc 1 1815 0
 7507 00bc FA68     		ldr	r2, [r7, #12]
 7508 00be 444B     		ldr	r3, .L599+36
 7509 00c0 9A42     		cmp	r2, r3
 7510 00c2 01DC     		bgt	.L576
 7511              		.loc 1 1815 0 is_stmt 0
 7512 00c4 3923     		mov	r3, #57
 7513 00c6 6DE0     		b	.L563
 7514              	.L576:
1816:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 7515              		.loc 1 1816 0 is_stmt 1
 7516 00c8 FA68     		ldr	r2, [r7, #12]
 7517 00ca 424B     		ldr	r3, .L599+40
 7518 00cc 9A42     		cmp	r2, r3
 7519 00ce 00DC     		bgt	.LCB7236
 7520 00d0 5EE0     		b	.L594	@long jump
 7521              	.LCB7236:
 7522              		.loc 1 1816 0 is_stmt 0
 7523 00d2 3A23     		mov	r3, #58
 7524 00d4 66E0     		b	.L563
 7525              	.L564:
1817:../Sources/system/CrystalClock.c ****       break;
1818:../Sources/system/CrystalClock.c ****     }
1819:../Sources/system/CrystalClock.c ****   }
1820:../Sources/system/CrystalClock.c ****   else // if DMX32 = 0
1821:../Sources/system/CrystalClock.c ****   {
1822:../Sources/system/CrystalClock.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 7526              		.loc 1 1822 0 is_stmt 1
 7527 00d6 354B     		ldr	r3, .L599
 7528 00d8 DB78     		ldrb	r3, [r3, #3]
 7529 00da DBB2     		uxtb	r3, r3
 7530 00dc 1A1C     		mov	r2, r3
 7531 00de 6023     		mov	r3, #96
 7532 00e0 1340     		and	r3, r2
 7533 00e2 5B09     		lsr	r3, r3, #5
 7534 00e4 012B     		cmp	r3, #1
 7535 00e6 17D0     		beq	.L580
 7536 00e8 04D3     		bcc	.L579
 7537 00ea 022B     		cmp	r3, #2
 7538 00ec 26D0     		beq	.L581
 7539 00ee 032B     		cmp	r3, #3
 7540 00f0 36D0     		beq	.L582
 7541 00f2 56E0     		b	.L578
 7542              	.L579:
1823:../Sources/system/CrystalClock.c ****     {
1824:../Sources/system/CrystalClock.c ****     case 0:
1825:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 640);
 7543              		.loc 1 1825 0
 7544 00f4 7A68     		ldr	r2, [r7, #4]
 7545 00f6 131C     		mov	r3, r2
 7546 00f8 9B00     		lsl	r3, r3, #2
 7547 00fa 9B18     		add	r3, r3, r2
 7548 00fc DB01     		lsl	r3, r3, #7
 7549 00fe FB60     		str	r3, [r7, #12]
1826:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 7550              		.loc 1 1826 0
 7551 0100 FA68     		ldr	r2, [r7, #12]
 7552 0102 2B4B     		ldr	r3, .L599+4
 7553 0104 9A42     		cmp	r2, r3
 7554 0106 01DC     		bgt	.L583
 7555              		.loc 1 1826 0 is_stmt 0
 7556 0108 3323     		mov	r3, #51
 7557 010a 4BE0     		b	.L563
 7558              	.L583:
1827:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
 7559              		.loc 1 1827 0 is_stmt 1
 7560 010c FA68     		ldr	r2, [r7, #12]
 7561 010e 294B     		ldr	r3, .L599+8
 7562 0110 9A42     		cmp	r2, r3
 7563 0112 3FDD     		ble	.L595
 7564              		.loc 1 1827 0 is_stmt 0
 7565 0114 3423     		mov	r3, #52
 7566 0116 45E0     		b	.L563
 7567              	.L580:
1828:../Sources/system/CrystalClock.c ****       break;
1829:../Sources/system/CrystalClock.c ****     case 1:
1830:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 1280);
 7568              		.loc 1 1830 0 is_stmt 1
 7569 0118 7A68     		ldr	r2, [r7, #4]
 7570 011a 131C     		mov	r3, r2
 7571 011c 9B00     		lsl	r3, r3, #2
 7572 011e 9B18     		add	r3, r3, r2
 7573 0120 1B02     		lsl	r3, r3, #8
 7574 0122 FB60     		str	r3, [r7, #12]
1831:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 7575              		.loc 1 1831 0
 7576 0124 FA68     		ldr	r2, [r7, #12]
 7577 0126 244B     		ldr	r3, .L599+12
 7578 0128 9A42     		cmp	r2, r3
 7579 012a 01DC     		bgt	.L585
 7580              		.loc 1 1831 0 is_stmt 0
 7581 012c 3523     		mov	r3, #53
 7582 012e 39E0     		b	.L563
 7583              	.L585:
1832:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 7584              		.loc 1 1832 0 is_stmt 1
 7585 0130 FA68     		ldr	r2, [r7, #12]
 7586 0132 224B     		ldr	r3, .L599+16
 7587 0134 9A42     		cmp	r2, r3
 7588 0136 2FDD     		ble	.L596
 7589              		.loc 1 1832 0 is_stmt 0
 7590 0138 3623     		mov	r3, #54
 7591 013a 33E0     		b	.L563
 7592              	.L581:
1833:../Sources/system/CrystalClock.c ****       break;
1834:../Sources/system/CrystalClock.c ****     case 2:
1835:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 1920);
 7593              		.loc 1 1835 0 is_stmt 1
 7594 013c 7A68     		ldr	r2, [r7, #4]
 7595 013e 131C     		mov	r3, r2
 7596 0140 1B01     		lsl	r3, r3, #4
 7597 0142 9B1A     		sub	r3, r3, r2
 7598 0144 DB01     		lsl	r3, r3, #7
 7599 0146 FB60     		str	r3, [r7, #12]
1836:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 7600              		.loc 1 1836 0
 7601 0148 FA68     		ldr	r2, [r7, #12]
 7602 014a 1E4B     		ldr	r3, .L599+24
 7603 014c 9A42     		cmp	r2, r3
 7604 014e 01DC     		bgt	.L587
 7605              		.loc 1 1836 0 is_stmt 0
 7606 0150 3723     		mov	r3, #55
 7607 0152 27E0     		b	.L563
 7608              	.L587:
1837:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 7609              		.loc 1 1837 0 is_stmt 1
 7610 0154 FA68     		ldr	r2, [r7, #12]
 7611 0156 1C4B     		ldr	r3, .L599+28
 7612 0158 9A42     		cmp	r2, r3
 7613 015a 1FDD     		ble	.L597
 7614              		.loc 1 1837 0 is_stmt 0
 7615 015c 3823     		mov	r3, #56
 7616 015e 21E0     		b	.L563
 7617              	.L582:
1838:../Sources/system/CrystalClock.c ****       break;
1839:../Sources/system/CrystalClock.c ****     case 3:
1840:../Sources/system/CrystalClock.c ****       fll_freq_hz = (fll_ref * 2560);
 7618              		.loc 1 1840 0 is_stmt 1
 7619 0160 7A68     		ldr	r2, [r7, #4]
 7620 0162 131C     		mov	r3, r2
 7621 0164 9B00     		lsl	r3, r3, #2
 7622 0166 9B18     		add	r3, r3, r2
 7623 0168 5B02     		lsl	r3, r3, #9
 7624 016a FB60     		str	r3, [r7, #12]
1841:../Sources/system/CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 7625              		.loc 1 1841 0
 7626 016c FA68     		ldr	r2, [r7, #12]
 7627 016e 184B     		ldr	r3, .L599+36
 7628 0170 9A42     		cmp	r2, r3
 7629 0172 01DC     		bgt	.L589
 7630              		.loc 1 1841 0 is_stmt 0
 7631 0174 3923     		mov	r3, #57
 7632 0176 15E0     		b	.L563
 7633              	.L589:
1842:../Sources/system/CrystalClock.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 7634              		.loc 1 1842 0 is_stmt 1
 7635 0178 FA68     		ldr	r2, [r7, #12]
 7636 017a 164B     		ldr	r3, .L599+40
 7637 017c 9A42     		cmp	r2, r3
 7638 017e 0FDD     		ble	.L598
 7639              		.loc 1 1842 0 is_stmt 0
 7640 0180 3A23     		mov	r3, #58
 7641 0182 0FE0     		b	.L563
 7642              	.L591:
1802:../Sources/system/CrystalClock.c ****       break;
 7643              		.loc 1 1802 0 is_stmt 1
 7644 0184 C046     		mov	r8, r8
 7645 0186 0CE0     		b	.L578
 7646              	.L592:
1807:../Sources/system/CrystalClock.c ****       break;
 7647              		.loc 1 1807 0
 7648 0188 C046     		mov	r8, r8
 7649 018a 0AE0     		b	.L578
 7650              	.L593:
1812:../Sources/system/CrystalClock.c ****       break;
 7651              		.loc 1 1812 0
 7652 018c C046     		mov	r8, r8
 7653 018e 08E0     		b	.L578
 7654              	.L594:
1817:../Sources/system/CrystalClock.c ****       break;
 7655              		.loc 1 1817 0
 7656 0190 C046     		mov	r8, r8
 7657 0192 06E0     		b	.L578
 7658              	.L595:
1828:../Sources/system/CrystalClock.c ****       break;
 7659              		.loc 1 1828 0
 7660 0194 C046     		mov	r8, r8
 7661 0196 04E0     		b	.L578
 7662              	.L596:
1833:../Sources/system/CrystalClock.c ****       break;
 7663              		.loc 1 1833 0
 7664 0198 C046     		mov	r8, r8
 7665 019a 02E0     		b	.L578
 7666              	.L597:
1838:../Sources/system/CrystalClock.c ****       break;
 7667              		.loc 1 1838 0
 7668 019c C046     		mov	r8, r8
 7669 019e 00E0     		b	.L578
 7670              	.L598:
1843:../Sources/system/CrystalClock.c ****       break;
 7671              		.loc 1 1843 0
 7672 01a0 C046     		mov	r8, r8
 7673              	.L578:
1844:../Sources/system/CrystalClock.c ****     }
1845:../Sources/system/CrystalClock.c ****   }    
1846:../Sources/system/CrystalClock.c ****   return fll_freq_hz;
 7674              		.loc 1 1846 0
 7675 01a2 FB68     		ldr	r3, [r7, #12]
 7676              	.L563:
1847:../Sources/system/CrystalClock.c **** } // fll_freq
 7677              		.loc 1 1847 0
 7678 01a4 181C     		mov	r0, r3
 7679 01a6 BD46     		mov	sp, r7
 7680 01a8 04B0     		add	sp, sp, #16
 7681              		@ sp needed for prologue
 7682 01aa 80BD     		pop	{r7, pc}
 7683              	.L600:
 7684              		.align	2
 7685              	.L599:
 7686 01ac 00400640 		.word	1074151424
 7687 01b0 FF2C3101 		.word	19999999
 7688 01b4 40787D01 		.word	25000000
 7689 01b8 FF596202 		.word	39999999
 7690 01bc 80F0FA02 		.word	50000000
 7691 01c0 95080000 		.word	2197
 7692 01c4 FF869303 		.word	59999999
 7693 01c8 C0687804 		.word	75000000
 7694 01cc 710B0000 		.word	2929
 7695 01d0 FFB3C404 		.word	79999999
 7696 01d4 00E1F505 		.word	100000000
 7697              		.cfi_endproc
 7698              	.LFE25:
 7700              		.section	.text.what_mcg_mode,"ax",%progbits
 7701              		.align	2
 7702              		.global	what_mcg_mode
 7703              		.code	16
 7704              		.thumb_func
 7706              	what_mcg_mode:
 7707              	.LFB26:
1848:../Sources/system/CrystalClock.c **** 
1849:../Sources/system/CrystalClock.c **** 
1850:../Sources/system/CrystalClock.c **** unsigned char what_mcg_mode(void)
1851:../Sources/system/CrystalClock.c **** {
 7708              		.loc 1 1851 0
 7709              		.cfi_startproc
 7710 0000 80B5     		push	{r7, lr}
 7711              	.LCFI78:
 7712              		.cfi_def_cfa_offset 8
 7713              		.cfi_offset 7, -8
 7714              		.cfi_offset 14, -4
 7715 0002 00AF     		add	r7, sp, #0
 7716              	.LCFI79:
 7717              		.cfi_def_cfa_register 7
1852:../Sources/system/CrystalClock.c ****   // check if in FEI mode
1853:../Sources/system/CrystalClock.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 7718              		.loc 1 1853 0
 7719 0004 724B     		ldr	r3, .L611
 7720 0006 9B79     		ldrb	r3, [r3, #6]
 7721 0008 DBB2     		uxtb	r3, r3
 7722 000a 1A1C     		mov	r2, r3
 7723 000c 0C23     		mov	r3, #12
 7724 000e 1340     		and	r3, r2
 7725 0010 9B08     		lsr	r3, r3, #2
 7726 0012 0FD1     		bne	.L602
1854:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 7727              		.loc 1 1854 0
 7728 0014 6E4B     		ldr	r3, .L611
 7729 0016 9B79     		ldrb	r3, [r3, #6]
 7730 0018 DBB2     		uxtb	r3, r3
 7731 001a 1A1C     		mov	r2, r3
 7732 001c 1023     		mov	r3, #16
 7733 001e 1340     		and	r3, r2
1853:../Sources/system/CrystalClock.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 7734              		.loc 1 1853 0
 7735 0020 08D0     		beq	.L602
1855:../Sources/system/CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has sele
 7736              		.loc 1 1855 0
 7737 0022 6B4B     		ldr	r3, .L611
 7738 0024 9B79     		ldrb	r3, [r3, #6]
 7739 0026 DBB2     		uxtb	r3, r3
 7740 0028 1A1C     		mov	r2, r3
 7741 002a 2023     		mov	r3, #32
 7742 002c 1340     		and	r3, r2
1854:../Sources/system/CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 7743              		.loc 1 1854 0
 7744 002e 01D1     		bne	.L602
1856:../Sources/system/CrystalClock.c ****   {
1857:../Sources/system/CrystalClock.c ****     return FEI;                                                          // return FEI code
 7745              		.loc 1 1857 0
 7746 0030 0323     		mov	r3, #3
 7747 0032 CAE0     		b	.L603
 7748              	.L602:
1858:../Sources/system/CrystalClock.c ****   }
1859:../Sources/system/CrystalClock.c ****   // Check MCG is in PEE mode
1860:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 7749              		.loc 1 1860 0
 7750 0034 664B     		ldr	r3, .L611
 7751 0036 9B79     		ldrb	r3, [r3, #6]
 7752 0038 DBB2     		uxtb	r3, r3
 7753 003a 1A1C     		mov	r2, r3
 7754 003c 0C23     		mov	r3, #12
 7755 003e 1340     		and	r3, r2
 7756 0040 9B08     		lsr	r3, r3, #2
 7757 0042 032B     		cmp	r3, #3
 7758 0044 0FD1     		bne	.L604
1861:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7759              		.loc 1 1861 0
 7760 0046 624B     		ldr	r3, .L611
 7761 0048 9B79     		ldrb	r3, [r3, #6]
 7762 004a DBB2     		uxtb	r3, r3
 7763 004c 1A1C     		mov	r2, r3
 7764 004e 1023     		mov	r3, #16
 7765 0050 1340     		and	r3, r2
1860:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 7766              		.loc 1 1860 0
 7767 0052 08D1     		bne	.L604
1862:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has sele
 7768              		.loc 1 1862 0
 7769 0054 5E4B     		ldr	r3, .L611
 7770 0056 9B79     		ldrb	r3, [r3, #6]
 7771 0058 DBB2     		uxtb	r3, r3
 7772 005a 1A1C     		mov	r2, r3
 7773 005c 2023     		mov	r3, #32
 7774 005e 1340     		and	r3, r2
1861:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7775              		.loc 1 1861 0
 7776 0060 01D0     		beq	.L604
1863:../Sources/system/CrystalClock.c ****   {
1864:../Sources/system/CrystalClock.c ****     return PEE;                                                          // return PEE code
 7777              		.loc 1 1864 0
 7778 0062 0823     		mov	r3, #8
 7779 0064 B1E0     		b	.L603
 7780              	.L604:
1865:../Sources/system/CrystalClock.c ****   }
1866:../Sources/system/CrystalClock.c ****   // Check MCG is in PBE mode
1867:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 7781              		.loc 1 1867 0
 7782 0066 5A4B     		ldr	r3, .L611
 7783 0068 9B79     		ldrb	r3, [r3, #6]
 7784 006a DBB2     		uxtb	r3, r3
 7785 006c 1A1C     		mov	r2, r3
 7786 006e 0C23     		mov	r3, #12
 7787 0070 1340     		and	r3, r2
 7788 0072 9B08     		lsr	r3, r3, #2
 7789 0074 022B     		cmp	r3, #2
 7790 0076 16D1     		bne	.L605
1868:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7791              		.loc 1 1868 0
 7792 0078 554B     		ldr	r3, .L611
 7793 007a 9B79     		ldrb	r3, [r3, #6]
 7794 007c DBB2     		uxtb	r3, r3
 7795 007e 1A1C     		mov	r2, r3
 7796 0080 1023     		mov	r3, #16
 7797 0082 1340     		and	r3, r2
1867:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 7798              		.loc 1 1867 0
 7799 0084 0FD1     		bne	.L605
1869:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 7800              		.loc 1 1869 0
 7801 0086 524B     		ldr	r3, .L611
 7802 0088 9B79     		ldrb	r3, [r3, #6]
 7803 008a DBB2     		uxtb	r3, r3
 7804 008c 1A1C     		mov	r2, r3
 7805 008e 2023     		mov	r3, #32
 7806 0090 1340     		and	r3, r2
1868:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7807              		.loc 1 1868 0
 7808 0092 08D0     		beq	.L605
1870:../Sources/system/CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 7809              		.loc 1 1870 0
 7810 0094 4E4B     		ldr	r3, .L611
 7811 0096 5B78     		ldrb	r3, [r3, #1]
 7812 0098 DBB2     		uxtb	r3, r3
 7813 009a 1A1C     		mov	r2, r3
 7814 009c 0223     		mov	r3, #2
 7815 009e 1340     		and	r3, r2
1869:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 7816              		.loc 1 1869 0
 7817 00a0 01D1     		bne	.L605
1871:../Sources/system/CrystalClock.c ****   {
1872:../Sources/system/CrystalClock.c ****     return PBE;                                                          // return PBE code
 7818              		.loc 1 1872 0
 7819 00a2 0723     		mov	r3, #7
 7820 00a4 91E0     		b	.L603
 7821              	.L605:
1873:../Sources/system/CrystalClock.c ****   }
1874:../Sources/system/CrystalClock.c ****   // Check MCG is in FBE mode
1875:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 7822              		.loc 1 1875 0
 7823 00a6 4A4B     		ldr	r3, .L611
 7824 00a8 9B79     		ldrb	r3, [r3, #6]
 7825 00aa DBB2     		uxtb	r3, r3
 7826 00ac 1A1C     		mov	r2, r3
 7827 00ae 0C23     		mov	r3, #12
 7828 00b0 1340     		and	r3, r2
 7829 00b2 9B08     		lsr	r3, r3, #2
 7830 00b4 022B     		cmp	r3, #2
 7831 00b6 16D1     		bne	.L606
1876:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7832              		.loc 1 1876 0
 7833 00b8 454B     		ldr	r3, .L611
 7834 00ba 9B79     		ldrb	r3, [r3, #6]
 7835 00bc DBB2     		uxtb	r3, r3
 7836 00be 1A1C     		mov	r2, r3
 7837 00c0 1023     		mov	r3, #16
 7838 00c2 1340     		and	r3, r2
1875:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 7839              		.loc 1 1875 0
 7840 00c4 0FD1     		bne	.L606
1877:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 7841              		.loc 1 1877 0
 7842 00c6 424B     		ldr	r3, .L611
 7843 00c8 9B79     		ldrb	r3, [r3, #6]
 7844 00ca DBB2     		uxtb	r3, r3
 7845 00cc 1A1C     		mov	r2, r3
 7846 00ce 2023     		mov	r3, #32
 7847 00d0 1340     		and	r3, r2
1876:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7848              		.loc 1 1876 0
 7849 00d2 08D1     		bne	.L606
1878:../Sources/system/CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 7850              		.loc 1 1878 0
 7851 00d4 3E4B     		ldr	r3, .L611
 7852 00d6 5B78     		ldrb	r3, [r3, #1]
 7853 00d8 DBB2     		uxtb	r3, r3
 7854 00da 1A1C     		mov	r2, r3
 7855 00dc 0223     		mov	r3, #2
 7856 00de 1340     		and	r3, r2
1877:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 7857              		.loc 1 1877 0
 7858 00e0 01D1     		bne	.L606
1879:../Sources/system/CrystalClock.c ****   {
1880:../Sources/system/CrystalClock.c ****     return FBE;                                                          // return FBE code
 7859              		.loc 1 1880 0
 7860 00e2 0523     		mov	r3, #5
 7861 00e4 71E0     		b	.L603
 7862              	.L606:
1881:../Sources/system/CrystalClock.c ****   }
1882:../Sources/system/CrystalClock.c ****   // Check MCG is in BLPE mode
1883:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 7863              		.loc 1 1883 0
 7864 00e6 3A4B     		ldr	r3, .L611
 7865 00e8 9B79     		ldrb	r3, [r3, #6]
 7866 00ea DBB2     		uxtb	r3, r3
 7867 00ec 1A1C     		mov	r2, r3
 7868 00ee 0C23     		mov	r3, #12
 7869 00f0 1340     		and	r3, r2
 7870 00f2 9B08     		lsr	r3, r3, #2
 7871 00f4 022B     		cmp	r3, #2
 7872 00f6 0FD1     		bne	.L607
1884:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7873              		.loc 1 1884 0
 7874 00f8 354B     		ldr	r3, .L611
 7875 00fa 9B79     		ldrb	r3, [r3, #6]
 7876 00fc DBB2     		uxtb	r3, r3
 7877 00fe 1A1C     		mov	r2, r3
 7878 0100 1023     		mov	r3, #16
 7879 0102 1340     		and	r3, r2
1883:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 7880              		.loc 1 1883 0
 7881 0104 08D1     		bne	.L607
1885:../Sources/system/CrystalClock.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is
 7882              		.loc 1 1885 0
 7883 0106 324B     		ldr	r3, .L611
 7884 0108 5B78     		ldrb	r3, [r3, #1]
 7885 010a DBB2     		uxtb	r3, r3
 7886 010c 1A1C     		mov	r2, r3
 7887 010e 0223     		mov	r3, #2
 7888 0110 1340     		and	r3, r2
1884:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7889              		.loc 1 1884 0
 7890 0112 01D0     		beq	.L607
1886:../Sources/system/CrystalClock.c ****   {
1887:../Sources/system/CrystalClock.c ****     return BLPE;                                                         // return BLPE code
 7891              		.loc 1 1887 0
 7892 0114 0623     		mov	r3, #6
 7893 0116 58E0     		b	.L603
 7894              	.L607:
1888:../Sources/system/CrystalClock.c ****   }
1889:../Sources/system/CrystalClock.c ****   // check if in BLPI mode
1890:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 7895              		.loc 1 1890 0
 7896 0118 2D4B     		ldr	r3, .L611
 7897 011a 9B79     		ldrb	r3, [r3, #6]
 7898 011c DBB2     		uxtb	r3, r3
 7899 011e 1A1C     		mov	r2, r3
 7900 0120 0C23     		mov	r3, #12
 7901 0122 1340     		and	r3, r2
 7902 0124 9B08     		lsr	r3, r3, #2
 7903 0126 012B     		cmp	r3, #1
 7904 0128 16D1     		bne	.L608
1891:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 7905              		.loc 1 1891 0
 7906 012a 294B     		ldr	r3, .L611
 7907 012c 9B79     		ldrb	r3, [r3, #6]
 7908 012e DBB2     		uxtb	r3, r3
 7909 0130 1A1C     		mov	r2, r3
 7910 0132 1023     		mov	r3, #16
 7911 0134 1340     		and	r3, r2
1890:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 7912              		.loc 1 1890 0
 7913 0136 0FD0     		beq	.L608
1892:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 7914              		.loc 1 1892 0
 7915 0138 254B     		ldr	r3, .L611
 7916 013a 9B79     		ldrb	r3, [r3, #6]
 7917 013c DBB2     		uxtb	r3, r3
 7918 013e 1A1C     		mov	r2, r3
 7919 0140 2023     		mov	r3, #32
 7920 0142 1340     		and	r3, r2
1891:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 7921              		.loc 1 1891 0
 7922 0144 08D1     		bne	.L608
1893:../Sources/system/CrystalClock.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
 7923              		.loc 1 1893 0
 7924 0146 224B     		ldr	r3, .L611
 7925 0148 5B78     		ldrb	r3, [r3, #1]
 7926 014a DBB2     		uxtb	r3, r3
 7927 014c 1A1C     		mov	r2, r3
 7928 014e 0223     		mov	r3, #2
 7929 0150 1340     		and	r3, r2
1892:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 7930              		.loc 1 1892 0
 7931 0152 01D0     		beq	.L608
1894:../Sources/system/CrystalClock.c ****   {
1895:../Sources/system/CrystalClock.c ****     return BLPI;                                                         // return BLPI code
 7932              		.loc 1 1895 0
 7933 0154 0123     		mov	r3, #1
 7934 0156 38E0     		b	.L603
 7935              	.L608:
1896:../Sources/system/CrystalClock.c ****   }
1897:../Sources/system/CrystalClock.c ****   // check if in FBI mode
1898:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 7936              		.loc 1 1898 0
 7937 0158 1D4B     		ldr	r3, .L611
 7938 015a 9B79     		ldrb	r3, [r3, #6]
 7939 015c DBB2     		uxtb	r3, r3
 7940 015e 1A1C     		mov	r2, r3
 7941 0160 0C23     		mov	r3, #12
 7942 0162 1340     		and	r3, r2
 7943 0164 9B08     		lsr	r3, r3, #2
 7944 0166 012B     		cmp	r3, #1
 7945 0168 16D1     		bne	.L609
1899:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 7946              		.loc 1 1899 0
 7947 016a 194B     		ldr	r3, .L611
 7948 016c 9B79     		ldrb	r3, [r3, #6]
 7949 016e DBB2     		uxtb	r3, r3
 7950 0170 1A1C     		mov	r2, r3
 7951 0172 1023     		mov	r3, #16
 7952 0174 1340     		and	r3, r2
1898:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 7953              		.loc 1 1898 0
 7954 0176 0FD0     		beq	.L609
1900:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 7955              		.loc 1 1900 0
 7956 0178 154B     		ldr	r3, .L611
 7957 017a 9B79     		ldrb	r3, [r3, #6]
 7958 017c DBB2     		uxtb	r3, r3
 7959 017e 1A1C     		mov	r2, r3
 7960 0180 2023     		mov	r3, #32
 7961 0182 1340     		and	r3, r2
1899:../Sources/system/CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 7962              		.loc 1 1899 0
 7963 0184 08D1     		bne	.L609
1901:../Sources/system/CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
 7964              		.loc 1 1901 0
 7965 0186 124B     		ldr	r3, .L611
 7966 0188 5B78     		ldrb	r3, [r3, #1]
 7967 018a DBB2     		uxtb	r3, r3
 7968 018c 1A1C     		mov	r2, r3
 7969 018e 0223     		mov	r3, #2
 7970 0190 1340     		and	r3, r2
1900:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 7971              		.loc 1 1900 0
 7972 0192 01D1     		bne	.L609
1902:../Sources/system/CrystalClock.c ****   {  
1903:../Sources/system/CrystalClock.c ****     return FBI;                                                          // return FBI code 
 7973              		.loc 1 1903 0
 7974 0194 0223     		mov	r3, #2
 7975 0196 18E0     		b	.L603
 7976              	.L609:
1904:../Sources/system/CrystalClock.c ****   }
1905:../Sources/system/CrystalClock.c ****   // Check MCG is in FEE mode
1906:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 7977              		.loc 1 1906 0
 7978 0198 0D4B     		ldr	r3, .L611
 7979 019a 9B79     		ldrb	r3, [r3, #6]
 7980 019c DBB2     		uxtb	r3, r3
 7981 019e 1A1C     		mov	r2, r3
 7982 01a0 0C23     		mov	r3, #12
 7983 01a2 1340     		and	r3, r2
 7984 01a4 9B08     		lsr	r3, r3, #2
 7985 01a6 0FD1     		bne	.L610
1907:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 7986              		.loc 1 1907 0
 7987 01a8 094B     		ldr	r3, .L611
 7988 01aa 9B79     		ldrb	r3, [r3, #6]
 7989 01ac DBB2     		uxtb	r3, r3
 7990 01ae 1A1C     		mov	r2, r3
 7991 01b0 1023     		mov	r3, #16
 7992 01b2 1340     		and	r3, r2
1906:../Sources/system/CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 7993              		.loc 1 1906 0
 7994 01b4 08D1     		bne	.L610
1908:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has sele
 7995              		.loc 1 1908 0
 7996 01b6 064B     		ldr	r3, .L611
 7997 01b8 9B79     		ldrb	r3, [r3, #6]
 7998 01ba DBB2     		uxtb	r3, r3
 7999 01bc 1A1C     		mov	r2, r3
 8000 01be 2023     		mov	r3, #32
 8001 01c0 1340     		and	r3, r2
1907:../Sources/system/CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8002              		.loc 1 1907 0
 8003 01c2 01D1     		bne	.L610
1909:../Sources/system/CrystalClock.c ****   {
1910:../Sources/system/CrystalClock.c ****     return FEE;                                                          // return FEE code
 8004              		.loc 1 1910 0
 8005 01c4 0423     		mov	r3, #4
 8006 01c6 00E0     		b	.L603
 8007              	.L610:
1911:../Sources/system/CrystalClock.c ****   }
1912:../Sources/system/CrystalClock.c ****   else
1913:../Sources/system/CrystalClock.c ****   {
1914:../Sources/system/CrystalClock.c ****     return 0;                                                            // error condition
 8008              		.loc 1 1914 0
 8009 01c8 0023     		mov	r3, #0
 8010              	.L603:
1915:../Sources/system/CrystalClock.c ****   }
1916:../Sources/system/CrystalClock.c **** } // what_mcg_mode
 8011              		.loc 1 1916 0
 8012 01ca 181C     		mov	r0, r3
 8013 01cc BD46     		mov	sp, r7
 8014              		@ sp needed for prologue
 8015 01ce 80BD     		pop	{r7, pc}
 8016              	.L612:
 8017              		.align	2
 8018              	.L611:
 8019 01d0 00400640 		.word	1074151424
 8020              		.cfi_endproc
 8021              	.LFE26:
 8023              		.section	.text.clk_monitor_0,"ax",%progbits
 8024              		.align	2
 8025              		.global	clk_monitor_0
 8026              		.code	16
 8027              		.thumb_func
 8029              	clk_monitor_0:
 8030              	.LFB27:
1917:../Sources/system/CrystalClock.c **** 
1918:../Sources/system/CrystalClock.c **** 
1919:../Sources/system/CrystalClock.c **** /********************************************************************/
1920:../Sources/system/CrystalClock.c **** /* Functon name : clk_monitor_0
1921:../Sources/system/CrystalClock.c ****  *
1922:../Sources/system/CrystalClock.c ****  * This function simply enables or disables the OSC 0 clock monitor. This is
1923:../Sources/system/CrystalClock.c ****  * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
1924:../Sources/system/CrystalClock.c ****  * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
1925:../Sources/system/CrystalClock.c ****  * It MUST be disabled in all other modes or a reset may be generated. It must
1926:../Sources/system/CrystalClock.c ****  * also be disabled if it is desired to enter VLPR from BLPE mode.
1927:../Sources/system/CrystalClock.c ****  *
1928:../Sources/system/CrystalClock.c ****  * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
1929:../Sources/system/CrystalClock.c ****  *
1930:../Sources/system/CrystalClock.c ****  * Return value : none
1931:../Sources/system/CrystalClock.c ****  */
1932:../Sources/system/CrystalClock.c **** void clk_monitor_0(unsigned char en_dis)
1933:../Sources/system/CrystalClock.c **** {         
 8031              		.loc 1 1933 0
 8032              		.cfi_startproc
 8033 0000 80B5     		push	{r7, lr}
 8034              	.LCFI80:
 8035              		.cfi_def_cfa_offset 8
 8036              		.cfi_offset 7, -8
 8037              		.cfi_offset 14, -4
 8038 0002 82B0     		sub	sp, sp, #8
 8039              	.LCFI81:
 8040              		.cfi_def_cfa_offset 16
 8041 0004 00AF     		add	r7, sp, #0
 8042              	.LCFI82:
 8043              		.cfi_def_cfa_register 7
 8044 0006 021C     		mov	r2, r0
 8045 0008 FB1D     		add	r3, r7, #7
 8046 000a 1A70     		strb	r2, [r3]
1934:../Sources/system/CrystalClock.c ****   if (en_dis)
 8047              		.loc 1 1934 0
 8048 000c FB1D     		add	r3, r7, #7
 8049 000e 1B78     		ldrb	r3, [r3]
 8050 0010 002B     		cmp	r3, #0
 8051 0012 08D0     		beq	.L614
1935:../Sources/system/CrystalClock.c ****   {
1936:../Sources/system/CrystalClock.c ****     MCG_C6 |= MCG_C6_CME0_MASK;   
 8052              		.loc 1 1936 0
 8053 0014 094B     		ldr	r3, .L616
 8054 0016 094A     		ldr	r2, .L616
 8055 0018 5279     		ldrb	r2, [r2, #5]
 8056 001a D2B2     		uxtb	r2, r2
 8057 001c 2021     		mov	r1, #32
 8058 001e 0A43     		orr	r2, r1
 8059 0020 D2B2     		uxtb	r2, r2
 8060 0022 5A71     		strb	r2, [r3, #5]
 8061 0024 07E0     		b	.L613
 8062              	.L614:
1937:../Sources/system/CrystalClock.c ****   }
1938:../Sources/system/CrystalClock.c ****   else
1939:../Sources/system/CrystalClock.c ****   {
1940:../Sources/system/CrystalClock.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 8063              		.loc 1 1940 0
 8064 0026 054B     		ldr	r3, .L616
 8065 0028 044A     		ldr	r2, .L616
 8066 002a 5279     		ldrb	r2, [r2, #5]
 8067 002c D2B2     		uxtb	r2, r2
 8068 002e 2021     		mov	r1, #32
 8069 0030 8A43     		bic	r2, r1
 8070 0032 D2B2     		uxtb	r2, r2
 8071 0034 5A71     		strb	r2, [r3, #5]
 8072              	.L613:
1941:../Sources/system/CrystalClock.c ****   }
1942:../Sources/system/CrystalClock.c **** }    // end clk_monitor_0
 8073              		.loc 1 1942 0
 8074 0036 BD46     		mov	sp, r7
 8075 0038 02B0     		add	sp, sp, #8
 8076              		@ sp needed for prologue
 8077 003a 80BD     		pop	{r7, pc}
 8078              	.L617:
 8079              		.align	2
 8080              	.L616:
 8081 003c 00400640 		.word	1074151424
 8082              		.cfi_endproc
 8083              	.LFE27:
 8085              		.text
 8086              	.Letext0:
 8087              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 8088              		.file 3 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/MKL25Z4.h"
 8089              		.file 4 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/Control.h"
 8090              		.file 5 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/LineScanCamera.h"
 8091              		.file 6 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/PID.h"
 8092              		.file 7 "C:/Users/Brent Dimmig/workspace/Freesnail/Project_Headers/Accel.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CrystalClock.c
                            *COM*:00000004 straight_speed
                            *COM*:00000004 medium_speed
                            *COM*:00000004 turn_speed
                            *COM*:00000004 brake_speed
                            *COM*:00000004 speedC
                            *COM*:000000c8 LineScanData
                            *COM*:00001000 histogram
                            *COM*:00000008 kp
                            *COM*:00000008 ki
                            *COM*:00000008 kd
                            *COM*:00000008 lastError
                            *COM*:00000008 llastError
                            *COM*:00000004 lastOutput
                            *COM*:00000006 AccData
                            *COM*:00000002 Xout
                            *COM*:00000002 Yout
                            *COM*:00000002 Zout
                            *COM*:00000001 Xoffset
                            *COM*:00000001 Yoffset
                            *COM*:00000001 Zoffset
                            *COM*:00000004 ramp
                            *COM*:00000001 drs_val
                            *COM*:00000001 dmx32_val
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:41     .text.InitClock:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:46     .text.InitClock:00000000 InitClock
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:91     .text.pll_init:00000000 pll_init
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:80     .text.InitClock:00000020 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:86     .text.pll_init:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:615    .text.pll_init:00000324 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:633    .text.pll_init:00000364 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:924    .text.pll_init:0000053c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:931    .text.pee_pbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:936    .text.pee_pbe:00000000 pee_pbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1061   .text.pee_pbe:000000a8 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1067   .text.pbe_pee:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1072   .text.pbe_pee:00000000 pbe_pee
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1287   .text.pbe_pee:0000013c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1293   .text.pbe_fbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1298   .text.pbe_fbe:00000000 pbe_fbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1427   .text.pbe_fbe:000000ac $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1433   .text.fbe_pbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1438   .text.fbe_pbe:00000000 fbe_pbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1778   .text.fbe_pbe:00000208 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1788   .text.pbe_blpe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1793   .text.pbe_blpe:00000000 pbe_blpe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1872   .text.pbe_blpe:00000064 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1877   .text.blpe_pbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:1882   .text.blpe_pbe:00000000 blpe_pbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2194   .text.blpe_pbe:000001dc $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2202   .text.blpe_fbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2207   .text.blpe_fbe:00000000 blpe_fbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2336   .text.blpe_fbe:000000b0 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2342   .text.fbe_blpe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2347   .text.fbe_blpe:00000000 fbe_blpe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2426   .text.fbe_blpe:00000064 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2431   .text.fbe_fei:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2436   .text.fbe_fei:00000000 fbe_fei
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:7369   .text.fll_freq:00000000 fll_freq
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2676   .text.fbe_fei:00000158 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2684   .text.fei_fbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:2689   .text.fei_fbe:00000000 fei_fbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3174   .text.fei_fbe:000002e4 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3192   .text.fbe_fee:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3197   .text.fbe_fee:00000000 fbe_fee
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3397   .text.fbe_fee:00000130 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3403   .text.fee_fbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3408   .text.fee_fbe:00000000 fee_fbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3532   .text.fee_fbe:000000a8 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3538   .text.fbe_fbi:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3543   .text.fbe_fbi:00000000 fbe_fbi
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3953   .text.fbe_fbi:00000260 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3963   .text.fbi_fbe:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:3968   .text.fbi_fbe:00000000 fbi_fbe
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4463   .text.fbi_fbe:000002f4 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4481   .text.fbi_blpi:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4486   .text.fbi_blpi:00000000 fbi_blpi
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4596   .text.fbi_blpi:0000009c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4601   .text.blpi_fbi:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4606   .text.blpi_fbi:00000000 blpi_fbi
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4716   .text.blpi_fbi:0000009c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4721   .text.fbi_fee:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:4726   .text.fbi_fee:00000000 fbi_fee
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5248   .text.fbi_fee:0000032c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5264   .text.fbi_fee:00000364 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5284   .text.fbi_fee:00000380 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5289   .text.fee_fbi:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5294   .text.fee_fbi:00000000 fee_fbi
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5673   .text.fee_fbi:0000022c $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5683   .text.fbi_fei:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5688   .text.fbi_fei:00000000 fbi_fei
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5926   .text.fbi_fei:00000154 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5934   .text.fei_fbi:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:5939   .text.fei_fbi:00000000 fei_fbi
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6280   .text.fei_fbi:000001f8 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6290   .text.fei_fee:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6295   .text.fei_fee:00000000 fei_fee
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6756   .text.fei_fee:000002c4 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6774   .text.fee_fei:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6779   .text.fee_fei:00000000 fee_fei
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6936   .text.fee_fei:000000d8 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6949   .text.atc:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:6954   .text.atc:00000000 atc
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:7706   .text.what_mcg_mode:00000000 what_mcg_mode
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:7349   .text.atc:00000280 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:7364   .text.fll_freq:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:7686   .text.fll_freq:000001ac $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:7701   .text.what_mcg_mode:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:8019   .text.what_mcg_mode:000001d0 $d
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:8024   .text.clk_monitor_0:00000000 $t
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:8029   .text.clk_monitor_0:00000000 clk_monitor_0
C:\Users\BRENTD~1\AppData\Local\Temp\ccpfxSiM.s:8081   .text.clk_monitor_0:0000003c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_idiv
__aeabi_uidiv
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2uiz
